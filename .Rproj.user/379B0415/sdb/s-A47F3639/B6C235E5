{
    "contents" : ".reInitPob <- function(elitePop, fitnessElite, coveredElite, crowdingDistance, pctVariables, cubiertoActual, dataset, maxRegla, cate, num, crispSets, targetClass, popSize){\n  salida <- matrix(ncol = NCOL(elitePop), nrow = popSize)\n  fitnessSalida <- matrix(ncol = 4, nrow = popSize*2)\n  crowding <- numeric(popSize * 2)\n  numVariables <- round(NCOL(elitePop) * pctVariables)\n  coveredSalida <- matrix(FALSE, nrow = NROW(coveredElite), ncol = popSize)\n  \n  #Remove duplicated in elitePop and add this into salida\n  noDuplicados <- which(! duplicated(elitePop))\n\n  elitePop <- elitePop[noDuplicados,, drop = F]\n  fitnessElite <- fitnessElite[noDuplicados,, drop = F]\n  crowdingDistance <- crowdingDistance[noDuplicados]\n  coveredElite <- coveredElite[, noDuplicados, drop = F]\n  numIndividuos <- NROW(elitePop)\n\n    salida[seq_len(numIndividuos), ] <- elitePop\n    fitnessSalida[seq_len(NROW(fitnessElite)), ] <- fitnessElite\n    crowding[seq_len(length(crowdingDistance))] <- crowdingDistance\n    coveredSalida[,seq_len(NCOL(coveredElite))] <- coveredElite\n\n  restantes <- popSize - numIndividuos\n  # Initialization based on coverage of the rest of the population \n  # Find an example not covered and has the target class\n  \n#   noCubiertos <- which(! cubiertoActual)\n#   noCubiertos <- which( dataset[NROW(dataset), noCubiertos] == targetClass )\n#   \n#   #If there arenÂ´t examples that satisfies this condition, we take an arbitrary one\n#   if(length(noCubiertos) > 0)\n#     if(length(noCubiertos > 1))\n#       ejemplo <- dataset[seq_len(NROW(dataset) - 1), sample(noCubiertos, size = 1)]\n#     else\n#       ejemplo <- dataset[seq_len(NROW(dataset) - 1), noCubiertos]\n#   else\n#     ejemplo <- dataset[seq_len(NROW(dataset) - 1), sample(NCOL(dataset), size = 1)]\n#   \n#   #Get the values of all variable that cover the example\n#   valores <- numeric(length(ejemplo))\n#   for(i in seq_len(length(valores))){\n#     if(cate[i])\n#       valores[i] <- ejemplo[i] + 1\n#     \n#     if(num[i]){ # Numerical variable\n#       #Get the interval the variable belongs to\n#       valores[i] <- which( ejemplo[i] > crispSets[,1,i] & ejemplo[i] <= crispSets[,2,i]) - 1\n#     }\n#   }\n#   \n#   #Fill the population based on coverage\n#   if(restantes > 0){\n#     cantidadVariables <- sample(numVariables, size = restantes, replace = TRUE)\n#     variables <- lapply(X = cantidadVariables, FUN = function(x, numVars) sample(numVars, size = x, replace = FALSE), length(valores) )\n#     \n#     individuos <- lapply(X = variables, FUN = function(x, valores, numVariables, maxRegla){ cromosoma <- numeric(numVariables) + maxRegla; cromosoma[x] <- valores[x]; cromosoma }, valores, length(valores), maxRegla)\n#     salida[(numIndividuos + 1):popSize, ] <- matrix(unlist(individuos), ncol = length(valores), byrow = TRUE)\n#   }\n  \n  regla <- numeric(length(maxRegla))\n  \n  for(i in seq_len(restantes)){\n    regla[] <- 0\n    regla <- regla + maxRegla\n    \n    # Find an example not covered and has the target class\n    noCubiertos <- which(! cubiertoActual)\n    noCubiertos <- which( dataset[NROW(dataset), noCubiertos] == targetClass )\n    \n    if(length(noCubiertos) > 0)\n           if(length(noCubiertos > 1))\n            ejemplo <- dataset[seq_len(NROW(dataset) - 1), sample(noCubiertos, size = 1)]\n           else\n             ejemplo <- dataset[seq_len(NROW(dataset) - 1), noCubiertos]\n         else\n           ejemplo <- dataset[seq_len(NROW(dataset) - 1), sample(NCOL(dataset), size = 1)]\n      \n         #Get the values of all variable that cover the example\n            valores <- numeric(length(ejemplo))\n            for(ii in seq_len(length(valores))){\n              if(cate[ii])\n                valores[ii] <- ejemplo[ii] + 1\n              \n              if(num[ii]){ # Numerical variable\n                #Get the interval the variable belongs to\n               valores[ii] <- which( ejemplo[ii] > (crispSets[,1,ii] + .tolerance) & ejemplo[ii] <= (crispSets[,2,ii] + .tolerance)) - 1\n              }\n            }\n            \n            #Get the value of the selected variables that covers the example\n            numInterv <- sample(numVariables, size = 1)\n            vars <- sample(length(maxRegla), size = numInterv, replace = FALSE)\n            \n            regla[vars] <- valores[vars]\n            numIndividuos <- numIndividuos + 1\n            salida[numIndividuos,] <- regla\n  }\n  \n  list(pop = salida, fitness = fitnessSalida, crowd = crowding, cov = coveredSalida)\n}\n\n\n\n\n\n\n\n.selectionNMEEF <- function(pop, popSize, rank, crowding, fitness, covered) {\n  salida <- matrix(nrow = popSize, ncol = ncol(pop))\n  fitnessSalida <- matrix(nrow = popSize, ncol = 4)\n  coveredSalida <- matrix(nrow = NROW(covered), ncol = popSize)\n  mating <- matrix(NA, nrow = 2, ncol = popSize)\n  \n  equals <- seq_len(popSize) # Tournaments among the same individual isn´t allowed\n while(length(equals > 0)){\n    mating[,equals] <- matrix(sample(seq_len(popSize), size = length(equals) * 2, replace = TRUE) , nrow = 2)\n    equals <- which(mating[1,] == mating[2,])\n  }\n  \n  # First, we compare the individuals by his rank value (less is better)\n  winners1 <- which(rank[mating[1,]] < rank[mating[2,]])\n  winners2 <- which(rank[mating[2,]] < rank[mating[1,]])\n  \n  pos <- 1\n  if (length(winners1) > 0) {\n    salida[seq_len(length(winners1)),] <- pop[mating[1,winners1],]\n    fitnessSalida[seq_len(length(winners1)),] <- fitness[mating[1,winners1],]\n    coveredSalida[,seq_len(length(winners1))] <- covered[,mating[1,winners1]]\n    pos <- pos + length(winners1)\n  }\n  if (length(winners2) > 0) {\n    salida[pos:(pos+length(winners2) -1),] <- pop[mating[2,winners2],]\n    fitnessSalida[pos:(pos+length(winners2) -1 ),] <- fitness[mating[2,winners2],]\n    coveredSalida[,pos:(pos+length(winners2) -1 )] <- covered[,mating[2,winners2]]\n    pos <- pos + length(winners2)\n  }\n  \n  #If there are ties, we solve it by his crowding distance (more is better)\n  iguales <- which(rank[mating[2,]] == rank[mating[1,]])\n  if (length(iguales) > 0) {\n    mating <- mating[,iguales, drop = F]\n    \n    winners1 <- which(crowding[mating[1,]] >= crowding[mating[2,]])\n    winners2 <- which(crowding[mating[2,]] > crowding[mating[1,]])\n    if (length(winners1) > 0) {\n      salida[pos:(pos+length(winners1) - 1),] <- pop[mating[1,winners1],]\n      fitnessSalida[pos:(pos+length(winners1) -1),] <- fitness[mating[1,winners1],]\n      coveredSalida[,pos:(pos+length(winners1) -1 )] <- covered[,mating[1,winners1]]\n      pos <- pos + length(winners1)\n    }\n    if (length(winners2) > 0) {\n      salida[pos:(pos+length(winners2) -1),] <- pop[mating[2,winners2],]\n      fitnessSalida[pos:(pos+length(winners2) -1),] <- fitness[mating[2,winners2],]\n      coveredSalida[,pos:(pos+length(winners2) -1 )] <- covered[,mating[2,winners2]]\n    }\n  }\n  \n  #Returns the selected population, the fitness of this individuals and his covered examples. (crowding distance will be computed after)\n  list(population = salida, fitness = fitnessSalida, cov = coveredSalida)\n  \n}\n\n\n\n\n\n\n\n\n\n.calculateDominance <- function(q, p, strictDominance){\n  #We calculate if p domain q only.\n  \n  dominaP <- F\n  dominaQ <- F\n  \n  if(strictDominance){\n    dominaP <- any(p > q)\n    dominaQ <- any(p < q)\n  } else {\n    dominaQ <- any(p < q)\n    dominaP <- any(p >= q)\n  }\n  \n  #return\n  if(dominaQ == dominaP)\n    return(0L)\n  if(dominaQ)\n    return(1L)\n  if(dominaP)\n    return(-1L)\n}\n\n\n\n\n\n\n\n\n.crowdingDistance <- function(pop){\n  if(is.vector(pop)) \n    size <- 1\n  else\n    size <- NROW(pop)\n  \n  distance <- numeric(size)\n  measures <- numeric(size)\n  num_measures <- seq_len(NCOL(pop))\n  \n  \n  if(size <= 2){\n    distance <- Inf\n  } else {\n    #For every measure\n    for( i in num_measures){\n      measures <- pop[,i]\n      #Order measures\n      #indices <- order(measures, decreasing = FALSE)\n      \n      #/**/ REMOVE THIS AND USE ORDER\n      indices <- .qsort(measures, 1, length(measures), seq_len(length(measures)))\n      indices <- indices$indices\n      #/**/\n      \n      #Set boundary individuals distance as infinity\n      distance[c(indices[1], indices[size])] <- Inf\n      \n      #Compute distance of the rest.\n      for(j in 2:(size - 1)){\n        distancia <- measures[indices[j + 1]] - measures[indices[j - 1]]\n        if(distancia != 0){\n          distance[indices[j]] <- distance[indices[j]] + (distancia / (measures[indices[size]] - measures[indices[1]]) )\n        }\n      }\n    }\n  }\n  #Return\n  distance\n}\n\n\n\n\n\n\n\n\n.fillPopulation <- function(fronts, numFronts, fitness, coveredFrentes, popSize, nObjs){\n  suma <- 0\n  if(is.vector(fronts[[1]]))\n    cols <- length(fronts[[1]])\n  else\n    cols <- NCOL(fronts[[1]])\n  \n  newPop <- matrix(nrow = popSize, ncol = cols)\n  newRank <- numeric(popSize * 2) + Inf  #No ranked indivudals canÂ´t be selected\n  distance <- numeric(popSize)\n  fit <- matrix(ncol = 4, nrow = popSize)\n  frente <- 1\n  coveredbyInd <- matrix(FALSE, nrow = NROW(coveredFrentes[[1]]), ncol= popSize * 2)\n  #Indicate if the last front introduced in the population fits perfectly or we have to make the ordering by crowding distance of the front\n  FitPerfectly <- TRUE\n  \n  #for(i in seq_len(length(fronts))){\n  for(i in seq_len(numFronts)){\n    #If front fits in newPop, we introduce completely in it\n    frente <- i\n    if(! is.vector(fronts[[i]]))\n      rows <- NROW(fronts[[i]])\n    else \n      rows <- 1\n    \n    if( rows + suma <= popSize ){\n      \n      #Calculate crowding Distance\n      distance[(suma+1):(rows + suma)] <- .crowdingDistance(fitness[[i]][, seq_len(nObjs)])\n      #Add front in the new population, and update the rest of parameters.\n      newPop[(suma+1):(rows + suma), ] <- fronts[[i]]\n      newRank[(suma+1):(rows + suma)] <- i - 1\n      fit[(suma+1):(rows + suma), ] <- fitness[[i]]\n      coveredbyInd[, (suma+1):(rows + suma)] <- coveredFrentes[[i]]\n      suma <- suma + rows\n    } else {\n      break\n    }\n  }\n  \n    #If suma is less than popSize, front \"frente\" doesnt fit completely, so we must order by crowding distance\n    if(suma < popSize){\n      FitPerfectly <- FALSE\n      porRellenar <- popSize - suma\n      #Calculate crowding distance\n      distancia <- .crowdingDistance(fitness[[frente]])\n      \n      #Order by crowding distance and get the best individuals till the population is filled\n      #orden <- order(distancia, decreasing = TRUE)[seq_len(porRellenar)]\n      orden <- .qsort(distancia, 1, length(distancia), index = seq_len(length(distancia)))\n      orden <- orden$indices[length(orden$vector):(length(orden$vector) - porRellenar + 1) ]\n      \n      #Fill the population and update parameters\n      newPop[(suma + 1):popSize, ] <- fronts[[frente]][orden, , drop = F]\n      distance[(suma + 1):popSize] <- distancia[orden]\n      newRank[(suma+1):popSize] <- frente - 1\n      fit[(suma + 1):popSize, ] <- fitness[[frente]][orden, , drop = F]\n      coveredbyInd[, (suma + 1):popSize] <- coveredFrentes[[frente]][,orden,drop = F]\n    }\n  \n  list(population = newPop, distancia = distance, fitness = fit, rank = newRank, cov = coveredbyInd, fits = FitPerfectly)\n  \n  \n}\n\n\n\n\n\n\n\n\n.mutateNMEEF <- function(cromosoma, variable, max_valor_variables, DNF_Rule){\n  \n  # Estos pesos hay que quitarlos una vez SDIGA funcione correctamente.\n  mutation_type <- sample(x = 1:2, size = 1, prob = c(6/11, 5/11))   # Tipo 1 - tipo 2 aleatoriamente\n  \n  \n  if(! DNF_Rule){  #Reglas can-nicas\n    if(mutation_type == 1L){\n      \n      cromosoma[variable] <- max_valor_variables[variable] #Se pone el valor de no participacion\n      \n    } else {  #Asigna valor aleatorio en la variable (NO incluye valor de eliminacion)\n      \n      value <- sample(x = 0:(max_valor_variables[variable] - 1), size = 1)\n      cromosoma[variable] <- value \n      \n    }\n    \n  } else { #Reglas DNF\n    \n    variable <- variable + 1\n    rango <- (max_valor_variables[variable - 1] + 1):max_valor_variables[variable]\n    \n    \n    if(mutation_type == 1){  #Valor de no participaci-n de la variable\n      \n      cromosoma[rango] <- 0\n      \n    } else {  #Asigna valor aleatorio en la variable\n      \n      cromosoma[rango] <- sample(x = 0:1 , size = length(rango), replace = TRUE)\n      \n    }\n    \n  }\n  \n  \n  \n  cromosoma  # Return\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n#' @title Non-dominated Multi-objective Evolutionary algorithm for Extracting Fuzzy rules in Subgroup Discovery (NMEEF-SD)\n#' @description Perfoms a subgroup discovery task executing the algorithm NMEEF-SD\n#'\n#' @param paramFile The path of the parameters file. \\code{NULL} If you want to use training and test \\code{keel} variables\n#' @param training A \\code{keel} class variable with training data.\n#' @param test A \\code{keel} class variable with training data.\n#' @param output character vector with the paths of where store information file, rules file and test quality measures file, respectively.\n#' @param seed An integer to set the seed used for generate random numbers.\n#' @param nLabels Number of fuzzy labels defined in the datasets.\n#' @param nEval An integer for set the maximum number of evaluations in the evolutive process.\n#' @param popLength An integer to set the number of individuals in the population.\n#' @param crossProb Sets the crossover probability. A number in [0,1].\n#' @param mutProb Sets the mutation probability. A number in [0,1].\n#' @param RulesRep Representation used in the rules. \"can\" for canonical rules, \"dnf\" for DNF rules.\n#' @param Obj1 Sets the Objective nº 1. See \\code{Objective values} for more information about the possible values.\n#' @param Obj2 Sets the Objective nº 2. See \\code{Objective values} for more information about the possible values.\n#' @param Obj3 Sets the Objective nº 3. See \\code{Objective values} for more information about the possible values.\n#' @param minCnf Sets the minimum confidence that must have a rule in the Pareto front for being returned. A number in [0,1].\n#' @param reInitCoverage. Sets if the algorithm must perform the reinitialitation based on coverage when it is needed. A string with \"yes\" or \"no\".\n#' @param porcCob. Sets the maximum percentage of variables that participate in the rules genereted in the reinitialitation based on coverage. A number in [0,1]\n#' @param targetClass A string specifing the value the target variable. \\code{null} for search for all possible values.\n#' \n#' \n#' @details This function sets as target variable the last one that appear in the KEEL file. If you want \n#'     to change the target variable, you can use \\link{changeTargetVariable} for this objective.  \n#'     The target variable MUST be categorical, if it´s not, throws an error.\n#'     \n#'     If you specify in \\code{paramFile} something distintc to \\code{NULL} the rest of the parameters are\n#'     ignored and the algorithm tries to read the file specified. See \"Parameters file structure\" below \n#'     if you want to use a parameters file.\n#' \n#' @section How does this algorithm work?:\n#'     NMEEF-SD is a multiobjetctive genetic algorithm based on a NSGA-II approach. The algorithm\n#'     first makes a selection based on binary tournament and save the individuals in a offspring population.\n#'     Then, NMEEF-SD apply the genetic operators over individuals in offspring population\n#'     \n#'     For generate the population which participate in the next iteration of the evoluationary process\n#'     NMEEF-SD calculate the dominance among all individuals (join main population and offspring) and then, apply the NSGA-II fast sort algorithm to order\n#'     the population by fronts of dominance, the first front is the non-dominanted front (or Pareto), the second is \n#'     where the individuals dominated by one individual are, the thirt front dominated by two and so on.\n#'     \n#'     To promove diversity NMEEF-SD has a mechanism of reinitialization of the population based on coverage\n#'     if the Pareto doesn´t evolve during a 5%% of the total of evaluations.\n#'     \n#'     At the final of the evolutionary process, the algorithm returns only the individuals in the Pareto front\n#'     which has a confidence greater than a minimum confidence level.\n#'     \n#' @section Parameters file structure:\n#'   The \\code{paramFile} argument points to a file which has the necesary parameters for NMEEF-SD works.\n#'   This file \\strong{must} be, at least, those parameters (separated by a carriage return):\n#'   \\itemize{\n#'     \\item \\code{algorithm}  Specify the algorithm to execute. In this case. \"NMEEFSD\"\n#'     \\item \\code{inputData}  Specify two paths of KEEL files for training and test. In case of specify only the name of the file, the path will be the working directory.\n#'     \\item \\code{seed}  Sets the seed for the random number generator\n#'     \\item \\code{nLabels}  Sets the number of fuzzy labels to create when reading the files\n#'     \\item \\code{nEval}  Set the maximun number of \\strong{evaluations of rules} for stop the genetic process\n#'     \\item \\code{popLength}  Sets number of individuals of the main population\n#'     \\item \\code{ReInitCob}  Sets if NMEEF-SD do the reinitialization based on coverage. Values: \"yes\" or \"no\"  \n#'     \\item \\code{crossProb}  Crossover probability of the genetic algorithm. Value in [0,1]\n#'     \\item \\code{mutProb}  Mutation probability of the genetic algorithm. Value in [0,1]\n#'     \\item \\code{RulesRep}  Representation of each chromosome of the population. \"can\" for canonical representation. \"dnf\" for DNF representation.\n#'     \\item \\code{porcCob}  Sets the maximum percentage of variables participe in a rule when doing the reinitialization based on coverage. Value in [0,1]\n#'     \\item \\code{Obj1} Sets the objective nº 1. \n#'     \\item \\code{Obj2} Sets the objective nº 2. \n#'     \\item \\code{Obj3} Sets the objective nº 3. \n#'     \\item \\code{minCnf} Minimum confidence for returning a rule of the Pareto. Value in [0,1] \n#'     \\item \\code{StrictDominance} Sets if the comparison of individuals when calculating dominance must be using strict dominance or not. Values: \"yes\" or \"no\"\n#'     \\item \\code{targetClass}  Value of the target variable to search for subgroups. The target variable \\strong{is always the last variable.}. Use \\code{null} to search for every value of the target variable\n#'   }\n#'   \n#'   An example of parameter file could be:\n#'  \\preformatted{\n#' algorithm = NMEEFSD\n#' inputData = \"irisd-10-1tra.dat\" \"irisd-10-1tra.dat\" \"irisD-10-1tst.dat\"\n#' outputData = \"irisD-10-1-INFO.txt\" \"irisD-10-1-Rules.txt\" \"irisD-10-1-TestMeasures.txt\"\n#' seed = 1\n#' RulesRep = can\n#' nLabels = 3\n#' nEval = 10000\n#' popLength = 51\n#' crossProb = 0.6\n#' mutProb = 0.1\n#' ReInitCob = yes\n#' porcCob = 0.5\n#' Obj1 = comp\n#' Obj2 = unus\n#' Obj3 = null\n#' minCnf = 0.6\n#' StrictDominance = yes\n#' targetClass = Iris-setosa\n#' }\n#'   \n#'   @section Objective values:\n#'      You can use the following quality measures in the ObjX value of the parameter file using this values:\n#'       \\itemize{\n#'         \\item Unusualness -> \\code{unus}\n#'         \\item Crisp Support -> \\code{csup}\n#'         \\item Crisp Confidence -> \\code{ccnf}\n#'         \\item Fuzzy Support -> \\code{fsup}\n#'         \\item Fuzzy Confidence -> \\code{fcnf}\n#'         \\item Coverage -> \\code{cove}\n#'         \\item Significance -> \\code{sign}\n#'       }\n#'     \n#'     If you don´t want to use a objetive value you must specify \\code{null}\n#'  \n#'   \n#' @return The algorithm shows in the console the following results:\n#' \\enumerate{\n#'  \\item The parameters used in the algorithm\n#'  \\item The rules generated.\n#'  \\item The quality measures for test of every rule and the global results.\n#' }\n#' \n#'     Also, the algorithms save those results in the files specified in the \\code{output} parameter of the algorithm or \n#'     in the \\code{outputData} parameter in the parameters file.\n#' \n#' @references Carmona, C., González, P., del Jesús, M., & Herrera, F. (2010). NMEEF-SD: Non-dominated Multi-objective Evolutionary algorithm for Extracting Fuzzy rules in Subgroup Discovery. \n#' @examples    \n#'       NMEEF_SD(paramFile = NULL, \n#'                training = habermanTra, \n#'                test = habermanTst, \n#'                output = c(\"optionsFile.txt\", \"rulesFile.txt\", \"testQM.txt\"),\n#'                seed = 0, \n#'                nLabels = 3,\n#'                nEval = 10000, \n#'                popLength = 100, \n#'                mutProb = 0.1,\n#'                crossProb = 0.6,\n#'                RulesRep = \"can\",\n#'                Obj1 = \"CSUP\",\n#'                Obj2 = \"CCNF\",\n#'                Obj3 = \"null\",\n#'                minCnf = 0.6,\n#'                reInitCoverage = \"yes\",\n#'                porcCob = 0.5,\n#'                StrictDominance = \"yes\",\n#'                targetClass = \"null\"\n#'                )\n#'               \nNMEEF_SD <- function(paramFile = NULL, \n                     training = NULL, \n                     test = NULL, \n                     output = c(\"optionsFile.txt\", \"rulesFile.txt\", \"testQM.txt\"),\n                     seed = 0, \n                     nLabels = 3,\n                     nEval = 10000, \n                     popLength = 100, \n                     mutProb = 0.1,\n                     crossProb = 0.6,\n                     RulesRep = \"can\",\n                     Obj1 = \"CSUP\",\n                     Obj2 = \"CCNF\",\n                     Obj3 = \"null\",\n                     minCnf = 0.6,\n                     reInitCoverage = \"yes\",\n                     porcCob = 0.5,\n                     StrictDominance = \"yes\",\n                     targetClass = \"null\"\n                     )\n{\n \n  if(is.null(paramFile)){\n    #Generate our \"parameters file\"\n    if(class(training) != \"keel\" | class(test) != \"keel\")\n      stop(\"Training or test parameters is not a KEEL class\")\n    \n    if(is.null(training) | is.null(test)) \n      stop(\"Not provided a test or training file and neither a parameter file. Aborting...\")\n    \n    if(training[[1]] != test[[1]] )\n      stop(\"datasets does not have the same relation name.\")\n    \n    if(length(output) != 3 )\n      stop(\"You must specify three files to save the results.\")\n    \n    parametros <- list(seed = seed, \n                       algorithm = \"NMEEFSD\",\n                       outputData = output,\n                       nEval = nEval, \n                       popLength = popLength,\n                       nLabels = nLabels,\n                       mutProb = mutProb,\n                       crossProb = crossProb,\n                       RulesRep = RulesRep,\n                       Obj1 = Obj1, \n                       Obj2 = Obj2,\n                       Obj3 = Obj3,\n                       minCnf = minCnf,\n                       reInitPob = reInitCoverage,\n                       porcCob = porcCob,\n                       StrictDominance = StrictDominance,\n                       targetClass = targetClass)\n  } else {\n\n    # Parametros --------------------------\n    parametros <- .read.parametersFile2(file = paramFile)  # parametros del algoritmo\n    \n    if(parametros[[1]] != \"NMEEFSD\") stop(\"Parameters file has parameters for another algorithm, no for NMEEF-SD\")\n   \n    training <- read.keel(file = parametros$inputData[1], nLabels = parametros$nLabels )   # training data \n    test <- read.keel(file = parametros$inputData[2], nLabels = parametros$nLabels)        # test data\n   \n  }\n  \n  #Check if the last variable is categorical.\n  if(training$atributeTypes[length(training$atributeTypes)] != 'c' | test$atributeTypes[length(test$atributeTypes)] != 'c')\n    stop(\"Target variable is not categorical.\")\n  \n  \n  file.remove(parametros$outputData[which(file.exists(parametros$outputData))])\n  if(file.exists(\"testQualityMeasures.txt\")) file.remove(\"testQualityMeasures.txt\")\n  \n  if(tolower(parametros$RulesRep) == \"can\"){\n    DNF = FALSE\n  } else {\n    DNF = TRUE\n    vars <-  Reduce(f = '+', x = training[[\"conjuntos\"]], accumulate = TRUE)\n    vars <- vars[length(vars)]\n  }\n  \n  .show_parameters(params = parametros, train = training, test = test)\n  contador <- 0\n  \n  Objetivos <- .parseObjetives(parametros = parametros, \"NMEEFSD\", DNF)\n  \n  if(all(is.na(Objetivos[1:3]))) stop(\"No objetive values selected. You must select, at least, one objective value. Aborting...\")\n \n   cate <- training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'c'\n  num <- training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'r' | training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'e'\n  \n  \n  #---------------------------------------------------\n  \n  \n  #----- OBTENCION DE LAS REGLAS -------------------\n  if(parametros$targetClass != \"null\"){ # Ejecuci-n para una clase\n    cat(\"\\n\", \"\\n\", \"Searching rules for only one value of the target class...\", \"\\n\", \"\\n\", file =\"\", fill = TRUE) \n    reglas <- .findRule(parametros$targetClass, \"NMEEFSD\", training, parametros, DNF, cate, num, Objetivos, as.numeric(parametros[[\"porcCob\"]]), parametros[[\"StrictDominance\"]] == \"yes\", parametros[[\"reInitPob\"]] == \"yes\")\n    \n    if(! is.null(unlist(reglas)) ){\n      if(! DNF) \n        reglas <-  matrix(unlist(reglas), ncol =  training[[\"nVars\"]] + 1 , byrow = TRUE)\n      else \n        reglas <-  matrix(unlist(reglas), ncol = vars + 1 , byrow = TRUE)\n    } else {\n      cat(\"No rules found with a confidence greater than the specified\", file = \"\", fill = TRUE)\n      cat(\"No rules found with a confidence greater than the specified\\n\", file = parametros$outputData[2], append = TRUE)\n      reglas <- numeric()\n    }\n    \n  } else {  #Ejecucion para todas las clases\n    \n    cat(\"\\n\", \"\\n\", \"Searching rules for all values of the target class...\", \"\\n\", \"\\n\", file =\"\", fill = TRUE)  \n    \n    if(Sys.info()[1] == \"Windows\")\n      reglas <- lapply(X = training$class_names, FUN = .findRule, \"NMEEFSD\", training, parametros, DNF, cate, num, Objetivos, as.numeric(parametros[[\"porcCob\"]]), parametros[[\"StrictDominance\"]] == \"yes\", parametros[[\"reInitPob\"]] == \"yes\"  )\n    else\n      reglas <- mclapply(X = training$class_names, FUN = .findRule, \"NMEEFSD\", training, parametros, DNF, cate, num, Objetivos, as.numeric(parametros[[\"porcCob\"]]), parametros[[\"StrictDominance\"]] == \"yes\", parametros[[\"reInitPob\"]] == \"yes\"   , mc.cores = detectCores() )\n    \n    if(! is.null(unlist(reglas)) ){\n      if(! DNF) \n        reglas <-  matrix(unlist(reglas), ncol =  training[[\"nVars\"]] + 1 , byrow = TRUE)\n      else \n        reglas <-  matrix(unlist(reglas), ncol = vars + 1 , byrow = TRUE)\n      \n      #Print Rules (In windows, mclapply doesn´t work, so the rules are printed by \".findRule\" function)\n    if(Sys.info()[1] != \"Windows\")\n      for(i in seq_len(NROW(reglas))){\n        cat(\"GENERATED RULE\", i,   file = \"\", sep = \" \",fill = TRUE)\n        #cat(\"GENERATED RULE\", i,   file = parametros$outputData[2], sep = \" \",fill = TRUE, append = TRUE)\n        .print.rule(rule = as.numeric( reglas[i, - NCOL(reglas)] ), max = training$conjuntos, names = training$atributeNames, consecuente = reglas[i, NCOL(reglas)], types = training$atributeTypes,fuzzySets = training$fuzzySets, categoricalValues = training$categoricalValues, DNF, rulesFile = parametros$outputData[2])\n        cat(\"\\n\",\"\\n\",  file = \"\", sep = \"\",fill = TRUE)\n        #cat(\"\\n\",  file = parametros$outputData[2], sep = \"\",fill = TRUE, append = TRUE)\n      }\n    } else {\n      cat(\"No rules found with a confidence greater than the specified\", file = \"\", fill = TRUE)\n      cat(\"No rules found with a confidence greater than the specified\\n\", file = parametros$outputData[2], append = TRUE)\n      reglas <- numeric()\n    }\n    \n  }\n  \n  #---------------------------------------------------\n  \n  cat(\"\\n\", \"\\n\", \"Testing rules...\", \"\\n\", \"\\n\", file = \"\", sep = \" \", fill = TRUE)\n  \n  #--------  Testeo de las reglas --------------------\n  if(length(reglas) > 0){\n  sumNvars <- 0\n  sumCov <- 0\n  sumFsup <- 0\n  sumCsup <- 0\n  sumCconf <- 0\n  sumFconf <- 0\n  sumUnus <- 0\n  sumSign <- 0\n  sumAccu <- 0\n  \n  n_reglas <- NROW(reglas)\n  for(i in seq_len(n_reglas)){\n    val <- .probeRule2(rule = reglas[i, - NCOL(reglas)], testSet = test, targetClass = reglas[i, NCOL(reglas)], numRule = i, parametros = parametros, Objetivos = Objetivos, Pesos = Pesos, cate = cate, num = num, DNF = DNF)\n    test[[\"covered\"]] <- val[[\"covered\"]]\n    sumNvars <- sumNvars + val[[\"nVars\"]]\n    sumCov <- sumCov + val[[\"coverage\"]]\n    sumFsup <- sumFsup + val[[\"fsupport\"]]\n    sumCconf <- sumCconf + val[[\"cconfidence\"]]\n    sumFconf <- sumFconf + val[[\"fconfidence\"]]\n    sumUnus <- sumUnus + val[[\"unusualness\"]]\n    sumSign <- sumSign + val[[\"significance\"]]\n    sumAccu <- sumAccu + val[[\"accuracy\"]]\n  }\n  \n  \n  \n  #Medidas de calidad globales\n  cat(\"Global:\", file =\"\", fill = TRUE)\n  cat(paste(\"\\t - N_rules:\", NROW(reglas), sep = \" \"),\n      paste(\"\\t - N_vars:\", round(sumNvars / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Coverage:\", round(sumCov / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Significance:\", round(sumSign / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Unusualness:\", round(sumUnus / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Accuracy:\", round(sumAccu / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - CSupport:\", round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6), sep = \" \"),\n      paste(\"\\t - FSupport:\", round(sumFsup / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - FConfidence:\", round(sumFconf / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - CConfidence:\", round(sumCconf / n_reglas, 6), sep = \" \"),\n      file = \"\", sep = \"\\n\"\n  )\n  \n  #Medidas de calidad globales (Save in testMeasures File FOR THE WEB INTERFACE)\n  cat(\n    nrow(reglas),\n    round(sumNvars / n_reglas, 6),\n    round(sumCov / n_reglas, 6),\n    round(sumSign / n_reglas, 6),\n    round(sumUnus / n_reglas, 6),\n    round(sumAccu / n_reglas, 6),\n    round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6),\n    round(sumFsup / n_reglas, 6),\n    round(sumFconf / n_reglas, 6),\n    round(sumCconf / n_reglas, 6),\n    file = \"testQualityMeasures.txt\", sep = \"\\n\", append = TRUE\n  )\n  \n  #Medidas de calidad globales (Save in testMeasures File)\n  \n  cat( \"Global:\",\n       paste(\"\\t - N_rules:\", nrow(reglas), sep = \" \"),\n       paste(\"\\t - N_vars:\", round(sumNvars / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Coverage:\", round(sumCov / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Significance:\", round(sumSign / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Unusualness:\", round(sumUnus / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Accuracy:\", round(sumAccu / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - CSupport:\", round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6), sep = \" \"),\n       paste(\"\\t - FSupport:\", round(sumFsup / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - FConfidence:\", round(sumFconf / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - CConfidence:\", round(sumCconf / n_reglas, 6), sep = \" \"),\n       file = parametros$outputData[3], sep = \"\\n\", append = TRUE\n  )\n  } else {\n    cat(\"No rules for testing\", file = \"\", fill = TRUE)\n    cat(\"No rules for testing\", file = parametros$outputData[2], append = TRUE)\n  }\n  #---------------------------------------------------\n  \n}",
    "created" : 1434888256121.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2852018650",
    "id" : "B6C235E5",
    "lastKnownWriteTime" : 1434913071,
    "path" : "~/MEGA/MEGAsync/Universidad/Trabajo Fin de Grado/SDR/R/NMEEFSD.R",
    "project_path" : "R/NMEEFSD.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}