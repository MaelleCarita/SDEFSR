{
    "contents" : "##############################################################################\n#                                                                            #\n#                        GENETIC ALGORITHMS in R                             #\n#                                                                            #\n##############################################################################\n\n#\n# \n# Genetic algorithm for SDIGA\n#\n#\n\ngaSDIGA <- function(type = c(\"binary\", \"real-valued\", \"permutation\"), \n               fitness, ...,\n               min, max, nBits,\n               population = gaControl(type)$population,\n               selection = gaControl(type)$selection,\n               crossover = gaControl(type)$crossover, \n               mutation = gaControl(type)$mutation,\n               popSize = 50, \n               pcrossover = 0.8, \n               pmutation = 0.1, \n               elitism = base::max(1, round(popSize*0.05)), \n               maxiter = 100,\n               run = maxiter,\n               maxfitness = Inf,\n               names = NULL,\n               suggestions = NULL, \n               keepBest = FALSE,\n               parallel = FALSE,\n               monitor = gaMonitor,\n               DNFRules = FALSE,\n               seed = NULL) \n{\n  \n  call <- match.call()\n  \n  type <- match.arg(type)\n  if(!is.function(population)) population <- get(population)\n  if(!is.function(selection))  selection  <- get(selection)\n  if(!is.function(crossover))  crossover  <- get(crossover)\n  if(!is.function(mutation))   mutation   <- get(mutation)\n  \n  if(missing(fitness))\n  { stop(\"A fitness function must be provided\") }\n  if(!is.function(fitness)) \n  { stop(\"A fitness function must be provided\") }\n  if(popSize < 10) \n  { warning(\"The population size is less than 10.\") }\n  if(maxiter < 1) \n  { stop(\"The maximum number of iterations must be at least 1.\") }\n  if(elitism > popSize) \n  { stop(\"The elitism cannot be larger that population size.\") }\n  if(pcrossover < 0 | pcrossover > 1)\n  { stop(\"Probability of crossover must be between 0 and 1.\") }\n  if(is.numeric(pmutation))\n  { if(pmutation < 0 | pmutation > 1)\n  { stop(\"If numeric probability of mutation must be between 0 and 1.\") }\n  else if(!is.function(population))\n  { stop(\"pmutation must be a numeric value in (0,1) or a function.\") }\n  }\n  if(missing(min) & missing(max) & missing(nBits))\n  { stop(\"A min and max range of values (for 'real-valued' or 'permutation' GA) or nBits (for 'binary' GA) must be provided!\") }\n  \n  switch(type, \n         \"binary\"      = { nBits <- as.vector(nBits)[1]\n                           #min <- max <- NA\n                           nvars <- nBits \n         },\n         \"real-valued\" = { min <- as.vector(min)\n                           max <- as.vector(max)\n                           nBits <- NA\n                           if(length(min) != length(max))\n                           { stop(\"min and max must be vector of the same length!\") }\n                           nvars <- length(max) \n         },\n         \"permutation\" = { min <- as.vector(min)[1]\n                           max <- as.vector(max)[1]\n                           nBits <- NA\n                           nvars <- length(seq(min,max)) \n         }\n  )\n  \n  if(is.null(suggestions))\n  { suggestions <- matrix(nrow = 0, ncol = nvars) }\n  else\n  { if(is.vector(suggestions)) \n  { if(nvars > 1) suggestions <- matrix(suggestions, nrow = 1)\n    else          suggestions <- matrix(suggestions, ncol = 1) }\n  else\n  { suggestions <- as.matrix(suggestions) }\n  if(nvars != ncol(suggestions))\n    stop(\"Provided suggestions (ncol) matrix do not match number of variables of the problem!\")\n  }\n  \n  # Start parallel computing (if needed)\n  parallel <- if(is.logical(parallel)) \n  { if(parallel) startParallel(parallel) else FALSE }\n  else { startParallel(parallel) }\n  on.exit(if(parallel)\n    parallel::stopCluster(attr(parallel, \"cluster\")) )\n  \n  fitnessSummary <- matrix(as.double(NA), nrow = maxiter, ncol = 6)\n  colnames(fitnessSummary) <- names(gaSummary(rnorm(10)))\n  bestSol <- if(keepBest) vector(mode = \"list\", length = maxiter)\n  else         list()\n  Fitness <- rep(NA, popSize + 2)\n  \n  \n  \n  object <- new(\"ga\", \n                call = call, \n                type = type,\n                min = min, \n                max = max, \n                nBits = nBits, \n                names = if(is.null(names)) character() else names,\n                popSize = popSize,\n                iter = 0, \n                run = 1, \n                maxiter = maxiter,\n                suggestions = suggestions,\n                population = matrix(), \n                elitism = elitism, \n                pcrossover = pcrossover, \n                pmutation = if(is.numeric(pmutation)) pmutation else NA,\n                fitness = Fitness, \n                summary = fitnessSummary,\n                bestSol = bestSol)\n  n_evals <- 0\n  if(!is.null(seed)) set.seed(seed)\n  \n  if(!DNFRules)\n    nGenes <- nvars * popSize\n  else\n    nGenes <- (length(max) - 1) * popSize\n  \n  numMutaciones <- ceiling(pmutation * nGenes)\n  \n  object@DNFRules <- DNFRules\n  object@maxValuesRule <- max \n  object@popNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  \n  # generate beginning population\n \n  Pop <- matrix(as.double(NA), nrow = popSize + 2, ncol = nvars)\n  \n  ng <- min(nrow(suggestions), popSize)\n  if(ng > 0) # use suggestion if provided\n  { Pop[1:ng,] <- suggestions }\n  # fill the rest with a random population\n  if(popSize > ng)\n  { if( ! DNFRules) \n    Pop[(ng+1):popSize,] <- population(object)[1:(popSize-ng),]\n    else \n    Pop[(ng+1):popSize,] <- population(object)[1:(popSize-ng),]\n  }\n  object@population <- Pop\n  \n  # start iterations\n  for(iter in seq_len(maxiter))\n  {\n    # evalute fitness function (when needed) \n    if(!parallel)\n    { for(i in seq_len(popSize + 2))\n      if(is.na(Fitness[i]))\n      { Fitness[i] <- fitness(Pop[i,], ...) \n        n_evals <- n_evals + 1} \n    }\n    else\n    { Fitness <- foreach(i = seq_len(popSize), .combine = \"c\") %dopar%\n{ if(is.na(Fitness[i])){ \n  fitness(Pop[i,], ...) \n  n_evals <- n_evals + 1    \n  }\n  else                  Fitness[i] }\n    }\n\n#fitnessSummary[iter,] <- gaSummary(Fitness)\n\n# update object\nobject@iter <- iter\nobject@population <- Pop\nobject@fitness <- Fitness\nobject@summary <- fitnessSummary\n\n\n#PopNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n#fitnessNew <- rep(NA, popSize)\nord <- order(Fitness, decreasing = TRUE)\nPopSorted <- Pop[ord,,drop=FALSE]\nFitnessSorted <- Fitness[ord]\n\n#Keep the population sorted by fitness\nobject@population <- PopSorted\nobject@fitness <- FitnessSorted\n\n# if(keepBest) \n#   # object@bestSol[[iter]] <- unique(Pop[Fitness == bestEval[iter],,drop=FALSE])\n#   object@bestSol[[iter]] <- unique(Pop[Fitness == fitnessSummary[iter,1],,drop=FALSE])\n# \n# if(is.function(monitor)) \n# { monitor(object) }\n\n# check stopping criteria\n# if(iter > 1)\n# { if(fitnessSummary[iter,1] > fitnessSummary[iter-1,1]+gaControl(\"eps\")) \n#   object@run <- 1 \n#   else \n#     object@run <- object@run + 1 \n# }\nif(n_evals >= run) break  \nif(max(Fitness, na.rm = TRUE) >= maxfitness) break\nif(object@iter == maxiter) break  \n\n\n# selection\nif(is.function(selection))\n{ sel <- selection(object)\n  PopSorted <- sel$population\n  FitnessSorted <- sel$fitness\n}\nelse\n{ sel <- sample(1:popSize, size = popSize, replace = TRUE)\n  Pop <- object@population[sel,]\n  Fitness <- object@fitness[sel]\n}\nobject@population <- PopSorted\nobject@fitness <- FitnessSorted\n\n\n# crossover Only cross the 2 best individuals\n#       if(is.function(crossover) & pcrossover > 0)\n#         { \n#           nmating <- floor(popSize/2)\n#           mating <- matrix(sample(1:(2*nmating), size = (2*nmating)), ncol = 2)\n#           for(i in seq_len(nmating))\n#             { if(pcrossover > runif(1))\n#                 { parents <- mating[i,]\n#                   Crossover <- crossover(object, parents)\n#                   Pop[parents,] <- Crossover$children\n#                   Fitness[parents] <- Crossover$fitness\n#                 }\n#             }             \n#           object@population <- Pop\n#           object@fitness <- Fitness\n#         }\nparents <- c(1,2)\nCrossover <- crossover(object, parents) # Only the best individuals are crossed\nPopSorted[popSize + parents,] <- Crossover$children\nFitnessSorted[popSize + parents] <- Crossover$fitness\n\n# mutation (only .mutate popLength * probMut chromosomes)\npm <- if(is.function(pmutation)) pmutation(object) else pmutation\nif(DNFRules) nvars <- length(max) - 1\nif(is.function(mutation) & pm > 0)\n{ \n  genes <- sample(x = seq_len(nGenes), size = numMutaciones, replace = TRUE)\n  cromosomas <- floor(genes / nvars) + 1\n  vars <- (cromosomas %% nvars) + 1\n  if(!DNFRules)\n    Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nvars)\n  else\n    Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nBits)\n  FitnessSorted[cromosomas] <- NA\n  for(i in seq_len(length(vars))) \n  {     \n    Mutation[i,] <- mutation(object, cromosomas[i], vars[i])\n  }\n  PopSorted[cromosomas,] <- Mutation \n  \n  object@population <- PopSorted\n  object@fitness <- FitnessSorted\n}\n\nPop <- PopSorted\nFitness <- FitnessSorted\n\n# elitism\n#       if(elitism > 0) \n#         { ord <- order(object@fitness, na.last = TRUE)\n#           u <- which(!duplicated(PopSorted, margin = 1))\n#           Pop[ord[1:elitism],] <- PopSorted[u[1:elitism],]\n#           Fitness[ord[1:elitism]] <- FitnessSorted[u[1:elitism]]\n#           object@population <- Pop\n#           object@fitness <- Fitness\n#         } \n\n  }\n\n# in case of premature convergence remove NA from summary fitness evalutations\nobject@summary <- na.exclude(object@summary)\nattr(object@summary, \"na.action\") <- NULL\n\n# get solution(s)\nobject@fitnessValue <- max(object@fitness, na.rm = TRUE)\n\n# return an object of class 'ga'\nreturn(object)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n#\n# Genetic algorithm for MESDIF\n#\n#\n\ngaMESDIF <- function(type = c(\"binary\", \"real-valued\", \"permutation\"), \n               fitness, ...,\n               min, max, nBits,\n               population = gaControl(type)$population,\n               selection = gaControl(type)$selection,\n               crossover = gaControl(type)$crossover, \n               mutation = gaControl(type)$mutation,\n               popSize = 50, \n               pcrossover = 0.8, \n               pmutation = 0.1, \n               elitism = base::max(1, round(popSize*0.05)), \n               maxiter = 100,\n               run = maxiter,\n               maxfitness = Inf,\n               names = NULL,\n               suggestions = NULL, \n               keepBest = FALSE,\n               parallel = FALSE,\n               monitor = gaMonitor,\n               DNFRules = FALSE,\n               seed = NULL) \n{\n  \n  call <- match.call()\n  \n  type <- match.arg(type)\n  if(!is.function(population)) population <- get(population)\n  if(!is.function(selection))  selection  <- get(selection)\n  if(!is.function(crossover))  crossover  <- get(crossover)\n  if(!is.function(mutation))   mutation   <- get(mutation)\n  \n  if(missing(fitness))\n  { stop(\"A fitness function must be provided\") }\n  if(!is.function(fitness)) \n  { stop(\"A fitness function must be provided\") }\n  if(popSize < 10) \n  { warning(\"The population size is less than 10.\") }\n  if(maxiter < 1) \n  { stop(\"The maximum number of iterations must be at least 1.\") }\n  if(elitism > popSize) \n  { stop(\"The elitism cannot be larger that population size.\") }\n  if(pcrossover < 0 | pcrossover > 1)\n  { stop(\"Probability of crossover must be between 0 and 1.\") }\n  if(is.numeric(pmutation))\n  { if(pmutation < 0 | pmutation > 1)\n  { stop(\"If numeric probability of mutation must be between 0 and 1.\") }\n  else if(!is.function(population))\n  { stop(\"pmutation must be a numeric value in (0,1) or a function.\") }\n  }\n  if(missing(min) & missing(max) & missing(nBits))\n  { stop(\"A min and max range of values (for 'real-valued' or 'permutation' GA) or nBits (for 'binary' GA) must be provided!\") }\n  \n  switch(type, \n         \"binary\"      = { nBits <- as.vector(nBits)[1]\n                           #min <- max <- NA\n                           nvars <- nBits \n         },\n         \"real-valued\" = { min <- as.vector(min)\n                           max <- as.vector(max)\n                           nBits <- NA\n                           if(length(min) != length(max))\n                           { stop(\"min and max must be vector of the same length!\") }\n                           nvars <- length(max) \n         },\n         \"permutation\" = { min <- as.vector(min)[1]\n                           max <- as.vector(max)[1]\n                           nBits <- NA\n                           nvars <- length(seq(min,max)) \n         }\n  )\n  \n  if(is.null(suggestions))\n  { suggestions <- matrix(nrow = 0, ncol = nvars) }\n  else\n  { if(is.vector(suggestions)) \n  { if(nvars > 1) suggestions <- matrix(suggestions, nrow = 1)\n    else          suggestions <- matrix(suggestions, ncol = 1) }\n  else\n  { suggestions <- as.matrix(suggestions) }\n  if(nvars != ncol(suggestions))\n    stop(\"Provided suggestions (ncol) matrix do not match number of variables of the problem!\")\n  }\n  \n  # Start parallel computing (if needed)\n  parallel <- if(is.logical(parallel)) \n  { if(parallel) startParallel(parallel) else FALSE }\n  else { startParallel(parallel) }\n  on.exit(if(parallel)\n    parallel::stopCluster(attr(parallel, \"cluster\")) )\n  \n  fitnessSummary <- matrix(as.double(NA), nrow = maxiter, ncol = 6)\n  colnames(fitnessSummary) <- names(gaSummary(rnorm(10)))\n  bestSol <- if(keepBest) vector(mode = \"list\", length = maxiter)\n  else         list()\n  \n  #Define Fitness as a matrix, in MESDIF, each value of objectives is evaluated individually\n  Fitness <- matrix(NA, nrow = popSize + elitism, ncol = 4)\n  #This counts the number of indivuals that are dominated by this one\n  Dominados <- numeric(popSize + elitism)\n  \n  \n  object <- new(\"ga\", \n                call = call, \n                type = type,\n                min = min, \n                max = max, \n                nBits = nBits, \n                names = if(is.null(names)) character() else names,\n                popSize = popSize,\n                iter = 0, \n                run = 1, \n                maxiter = maxiter,\n                suggestions = suggestions,\n                population = matrix(), \n                elitism = elitism, \n                pcrossover = pcrossover, \n                pmutation = if(is.numeric(pmutation)) pmutation else NA,\n                fitness = Fitness, \n                summary = fitnessSummary,\n                bestSol = bestSol)\n  #This GA runs until a number of evaluations is reached, not iterations !\n  n_evals <- 0\n  if(!is.null(seed)) set.seed(seed)\n  \n  #Compute the number of genes, the mutation probability is applied over the gene.\n  if(!DNFRules)\n    nGenes <- nvars * popSize\n  else\n    nGenes <- (length(max) - 1) * popSize\n  \n  numMutaciones <- floor(pmutation * nGenes)\n  \n  object@DNFRules <- DNFRules\n  object@maxValuesRule <- max \n  object@popNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  \n  # generate beginning population and elite population\n  Pop <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  elitePop <- matrix(as.double(NA), nrow = elitism, ncol = nvars)\n  \n  #Sets the next gene to mute\n  Mu_next <- ceiling(log(runif(1)) / log(1 - pmutation))\n\n  \n  \n  ng <- min(nrow(suggestions), popSize)\n  if(ng > 0) # use suggestion if provided\n  { Pop[1:ng,] <- suggestions }\n  # fill the rest with a random population\n  if(popSize > ng)\n  { if( ! DNFRules) \n    Pop[(ng+1):popSize,] <- population(object, 0.25, round(nvars*0.25))[1:(popSize-ng),]\n    else \n      Pop[(ng+1):popSize,] <- population(object, 0.25, round((length(max) - 1)*0.25))[1:(popSize-ng),]\n  }\n  object@population <- Pop\n  \n  NonDominated <- logical(popSize + elitism) #Indicate wheter an individual is non-dominated\n  WhoDominateMe <- vector(mode = \"list\", length = popSize + elitism) #Indicate the inviduals which domain this one\n # AdaptationValue <- numeric(popSize + elitism) \n  \n  dots <- list(...) #Catch dots arguments\n  nObjs <- length( which(!is.na(dots[[9]])) ) - 1\n  \n  volumenEsfera <- .volSphere(nObjs)\n  \n  \n  nvariables <- nvars\n  # start iterations\n  for(iter in seq_len(maxiter))\n  {\n    #Create the union of this two populations and reinitializate all values\n    NonDominated[] <- FALSE\n    Dominados[] <- 0\n    \n    UnionPop <- matrix(NA, nrow = popSize + elitism, ncol = nvariables)\n   \n    UnionPop[seq_len(NROW(Pop)), ] <- Pop\n    UnionPop[(NROW(Pop) + 1):NROW(UnionPop),] <- elitePop\n    \n    #normalize DNF RULES\n#     if(DNFRules){\n#       UnionPop <- matrix(unlist(apply(X = UnionPop, MARGIN = 1, FUN = normalizeDNFRule, max)), ncol = nBits, byrow = TRUE)\n#     }\n    \n    #Remove duplicated individuals in the UnionPop\n    UnionPop <- na.exclude(UnionPop)\n    duplicados <- which(! duplicated(UnionPop))\n    UnionPop <- UnionPop[duplicados, , drop = F]\n    Fitness <- Fitness[duplicados, , drop = F]\n\n\n    # evalute fitness function (when needed) \n\n    if(!parallel)\n    { for(i in seq_len( NROW(UnionPop) ))\n      if(all(is.na(Fitness[i,])))\n      { Fitness[i,] <- fitness(UnionPop[i,], ...) \n        n_evals <- n_evals + 1} \n    }\n    else\n    { Fitness <- foreach(i = seq_len(popSize), .combine = \"c\") %dopar%\n{ if(is.na(Fitness[i])){ \n  fitness(Pop[i,], ...) \n  n_evals <- n_evals + 1    \n}\nelse                  Fitness[i] }\n    }\n\n#Compute dominated and non-dominated rules and initial adaptation Value\n#NÃºmero de individuos a los que domina cada regla\nf <- na.exclude(Fitness)[, seq_len(nObjs), drop = F]\nn_Ind <- NROW(f)\nfor(i in seq_len(n_Ind)){\n  nd <- apply(X = f, MARGIN = 1, FUN = function(x, regla){ all(regla <= x) & any(regla < x)}, f[i,])\n  Dominados[i] <- sum( apply(X = f, MARGIN = 1, FUN = function(x, regla){ all(regla >= x) & any(regla > x)}, f[i,]) )\n  NonDominated[i] <- all( ! nd )\n  WhoDominateMe[[i]] <- which(nd)\n}\n\n#Initial Adaptation Value\nAdaptationValue <- vapply(X = WhoDominateMe[seq_len(n_Ind)], FUN = function(x, dominados) sum(dominados[x]) ,  FUN.VALUE = 2, Dominados)\nkthDistances <- numeric(length(AdaptationValue))\n#Distance measurement (Distancia entre valores de la regla o entre valores de fitnes? Uso valores DE FITNESS)\ndistancia <- as.matrix( dist(x = f, method = \"euclidean\", upper = TRUE, diag = TRUE))^2\n\n#Order distance (The first colum is the distance with respect himself !! )\n# And calculate the final adaptation value for each rule\nkTH <- floor( sqrt(n_Ind - 1) )\nfor(i in seq_len(NROW(distancia))){\n  distancia[i,] <- distancia[i, order(distancia[i, ]), drop = F]\n  \n  #Gets k-th closest neighbor , in this case, k = sqrt(popSize - 1)\n  if(distancia[i, kTH] == 0){\n    #If k-th closest is 0, get the next closest greater than 0\n    aux <- distancia[i, (kTH + 1):ncol(distancia)] > 0\n    closest <- which(aux, useNames = F)\n    if(length(closest) > 0)\n      dist <- distancia[i, closest[1] + kTH]\n    else \n      #Exception: All individuals are equal\n      dist <- 1\n  } else {\n    dist <- distancia[i, kTH]\n  }\n  \n  kthDistances[i] <-  1 / dist^nObjs * kTH / n_Ind / volumenEsfera\n}\n\n#Normalize kthDistances\nkthDistances <- kthDistances / sum(kthDistances)\nAdaptationValue <- AdaptationValue + kthDistances\n  \n  \n  \n#Fill elite population\n#Compute the number of non-dominated individuals\ncantidadNoDominados <- sum(NonDominated)\n\nif( cantidadNoDominados <= elitism){\n  \n  #Adition operator (AÃ±ade los elitism mejores valores de adaptacion  a la poblacion elite)\n  eliteIndividuals <- order(AdaptationValue)[seq_len(elitism)]\n  elitePop <- UnionPop[eliteIndividuals, , drop = F]\n \n} else {\n  #Truncation operator\n  lista <- truncOperator(NonDominatedPop = UnionPop[which(NonDominated), , drop = F], elitePopSize = elitism, FitnessND = Fitness[which(NonDominated), , drop =  F])\n  elitePop <- lista[[1]]\n  eliteIndividuals <- which(NonDominated)[lista[[2]]]\n  \n  } \n\n# update object\nobject@iter <- iter\nobject@population <- Pop\nobject@fitness <- Fitness\nobject@summary <- fitnessSummary\n\n\n#PopNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n#fitnessNew <- rep(NA, popSize)\n# ord <- order(Fitness, decreasing = TRUE)\n# PopSorted <- Pop[ord,,drop=FALSE]\n# FitnessSorted <- Fitness[ord]\n# \n# #Keep the population sorted by fitness\n# object@population <- PopSorted\n# object@fitness <- FitnessSorted\n\n# if(keepBest) \n#   # object@bestSol[[iter]] <- unique(Pop[Fitness == bestEval[iter],,drop=FALSE])\n#   object@bestSol[[iter]] <- unique(Pop[Fitness == fitnessSummary[iter,1],,drop=FALSE])\n# \n# if(is.function(monitor)) \n# { monitor(object) }\n\n# check stopping criteria\n# if(iter > 1)\n# { if(fitnessSummary[iter,1] > fitnessSummary[iter-1,1]+gaControl(\"eps\")) \n#   object@run <- 1 \n#   else \n#     object@run <- object@run + 1 \n# }\nif(n_evals >= run) break  \nif(max(Fitness, na.rm = TRUE) >= maxfitness) break\nif(object@iter == maxiter) break  \n\n\n# selection by Binary Tournament (Adaptation Values is the value for the \"fitness\")\n#Copy the selected populatin into an intermediary population\nif(is.function(selection))\n{ sel <- selection(elitePop, popSize, nvariables, AdaptationValue[eliteIndividuals], Fitness[eliteIndividuals, , drop = F])\n  interPop <- sel$population\n  AdaptationValue <- sel$fitness\n  Fitness <- sel$obj\n}\nelse\n{ sel <- sample(1:popSize, size = popSize, replace = TRUE)\n  Pop <- object@population[sel,]\n  AdapatationValue <- object@fitness[sel]\n}\nobject@population <- interPop\n\n\n# crossover performed by a double-point crossover\n      if(is.function(crossover) & pcrossover > 0)\n        { \n          nmating <- round( (popSize/2) * pcrossover )\n          \n          #Create the population where we allocate the descendents from crossover and mutation\n          descPop <- matrix(NA, ncol = nvariables, nrow = popSize*2)\n          \n          #mating <- matrix(sample(seq_len(popSize), size = (2*nmating), replace = TRUE), ncol = 2, byrow = T)\n          for(i in seq_len(nmating))\n            { \n                parents <- sample(seq_len(popSize), size = 2, replace = TRUE)\n                Crossover <- crossover(object, parents)\n                descPop[c(2*i - 1, 2*i),] <- Crossover$children\n              \n                \n            }             \n          #object@population <- descPop\n          #nGenes <- NROW(na.exclude(descPop)) * nvariables\n        }\n\n# mutation (only .mutate popLength * probMut chromosomes)\npm <- if(is.function(pmutation)) pmutation(object) else pmutation\nif(DNFRules) nvars <- length(max) - 1\nif(is.function(mutation) & pm > 0)\n{ \n#   genes <- sample(x = seq_len(nGenes), size = numMutaciones, replace = TRUE)\n#   cromosomas <- ceiling(genes / nvariables)\n#   vars <- (genes %% nvars) + 1\n#   if(!DNFRules)\n#     Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nvars)\n#   else\n#     Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nBits)\n#   #Fitness[cromosomas, ] <- NA\n#   for(i in seq_len(length(vars))) \n#   {     \n#     Mutation[i,] <- mutation(object, cromosomas[i], vars[i])\n#   }\n#   suma <- nmating*2  + NROW(Mutation)\n#   descPop[(nmating * 2 + 1):suma,] <- Mutation \n#   \n#   descPop <- na.exclude(descPop) #Por si tenemos menos cromosomas mutados\n  suma <- nmating*2 + 1\n  while(Mu_next <= nGenes){\n    cromosoma <- ceiling( Mu_next  / nvars ) \n    gen <- (Mu_next %% nvars) + 1\n    \n    descPop[suma, ] <- mutation(object, cromosoma, gen)\n    suma <- suma + 1\n    #Calcuate next gene\n    Mu_next <- Mu_next + ceiling(log( runif(1) ) /  log(1 - pmutation))\n    \n  }\n  \n  Mu_next <- Mu_next - nGenes\n}\n\n#Replace the worst individuals in the population with the genereted in crossovers and mutations\n\n#orden <- order(AdaptationValue)\norden <- qsort(AdaptationValue, left = 1, right = length(AdaptationValue), index = seq_len(length(AdaptationValue)))\norden <- orden$indices\nPop <- interPop#[orden, , drop = F]\norden <- c(orden, (popSize+1):NROW(Fitness))\n#Fitness <- Fitness[orden,, drop = F] \n\n\nPop[orden[popSize:(popSize - (suma - 2))], ] <- descPop[seq_len(suma - 1),]\nFitness[orden[popSize:(popSize - (suma - 2))], ] <- NA\n\n  \n  }\n\n\n# Return Non-duplicated individuals in elite pop\n  if(DNFRules){\n    elitePop <- matrix(unlist(apply(X = elitePop, MARGIN = 1, FUN = normalizeDNFRule, max)), ncol = nBits, byrow = TRUE)\n    } \n    elitePop[which(!duplicated(elitePop)), , drop = F]\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n#\n# Genetic algorithm for NMEEF-SD\n#\n#\n\ngaNMEEF <- function(type = c(\"binary\", \"real-valued\", \"permutation\"), \n                     fitness, ...,\n                     min, max, nBits,\n                     population = gaControl(type)$population,\n                     selection = gaControl(type)$selection,\n                     crossover = gaControl(type)$crossover, \n                     mutation = gaControl(type)$mutation,\n                     popSize = 50, \n                     pcrossover = 0.8, \n                     pmutation = 0.1, \n                     elitism = base::max(1, round(popSize*0.05)), \n                     maxiter = 100,\n                     run = maxiter,\n                     maxfitness = Inf,\n                     names = NULL,\n                     suggestions = NULL, \n                     keepBest = FALSE,\n                     parallel = FALSE,\n                     monitor = gaMonitor,\n                     DNFRules = FALSE,\n                     seed = NULL,\n                     porcCob = 0.5,\n                     StrictDominance = TRUE,\n                     reInitPop = TRUE) \n{\n  \n  call <- match.call()\n  \n  type <- match.arg(type)\n  if(!is.function(population)) population <- get(population)\n  if(!is.function(selection))  selection  <- get(selection)\n  if(!is.function(crossover))  crossover  <- get(crossover)\n  if(!is.function(mutation))   mutation   <- get(mutation)\n  \n  if(missing(fitness))\n  { stop(\"A fitness function must be provided\") }\n  if(!is.function(fitness)) \n  { stop(\"A fitness function must be provided\") }\n  if(popSize < 10) \n  { warning(\"The population size is less than 10.\") }\n  if(maxiter < 1) \n  { stop(\"The maximum number of iterations must be at least 1.\") }\n  if(elitism > popSize) \n  { stop(\"The elitism cannot be larger that population size.\") }\n  if(pcrossover < 0 | pcrossover > 1)\n  { stop(\"Probability of crossover must be between 0 and 1.\") }\n  if(is.numeric(pmutation))\n  { if(pmutation < 0 | pmutation > 1)\n  { stop(\"If numeric probability of mutation must be between 0 and 1.\") }\n    else if(!is.function(population))\n    { stop(\"pmutation must be a numeric value in (0,1) or a function.\") }\n  }\n  if(missing(min) & missing(max) & missing(nBits))\n  { stop(\"A min and max range of values (for 'real-valued' or 'permutation' GA) or nBits (for 'binary' GA) must be provided!\") }\n  \n  switch(type, \n         \"binary\"      = { nBits <- as.vector(nBits)[1]\n         #min <- max <- NA\n         nvars <- nBits \n         },\n         \"real-valued\" = { min <- as.vector(min)\n         max <- as.vector(max)\n         nBits <- NA\n         if(length(min) != length(max))\n         { stop(\"min and max must be vector of the same length!\") }\n         nvars <- length(max) \n         },\n         \"permutation\" = { min <- as.vector(min)[1]\n         max <- as.vector(max)[1]\n         nBits <- NA\n         nvars <- length(seq(min,max)) \n         }\n  )\n  \n  if(is.null(suggestions))\n  { suggestions <- matrix(nrow = 0, ncol = nvars) }\n  else\n  { if(is.vector(suggestions)) \n  { if(nvars > 1) suggestions <- matrix(suggestions, nrow = 1)\n  else          suggestions <- matrix(suggestions, ncol = 1) }\n    else\n    { suggestions <- as.matrix(suggestions) }\n    if(nvars != ncol(suggestions))\n      stop(\"Provided suggestions (ncol) matrix do not match number of variables of the problem!\")\n  }\n  \n  # Start parallel computing (if needed)\n  parallel <- if(is.logical(parallel)) \n  { if(parallel) startParallel(parallel) else FALSE }\n  else { startParallel(parallel) }\n  on.exit(if(parallel)\n    parallel::stopCluster(attr(parallel, \"cluster\")) )\n  \n  fitnessSummary <- matrix(as.double(NA), nrow = maxiter, ncol = 6)\n  colnames(fitnessSummary) <- names(gaSummary(rnorm(10)))\n  bestSol <- if(keepBest) vector(mode = \"list\", length = maxiter)\n  else         list()\n  \n  #Define Fitness as a matrix, in NMEEF, each value of objectives is evaluated individually\n  Fitness <- matrix(NA, nrow = popSize * 2, ncol = 4)\n\n  \n  \n  object <- new(\"ga\", \n                call = call, \n                type = type,\n                min = min, \n                max = max, \n                nBits = nBits, \n                names = if(is.null(names)) character() else names,\n                popSize = popSize,\n                iter = 0, \n                run = 1, \n                maxiter = maxiter,\n                suggestions = suggestions,\n                population = matrix(), \n                elitism = elitism, \n                pcrossover = pcrossover, \n                pmutation = if(is.numeric(pmutation)) pmutation else NA,\n                fitness = Fitness, \n                summary = fitnessSummary,\n                bestSol = bestSol)\n  #This GA runs until a number of EVALUATIONS is reached, not iterations !\n  n_evals <- 0\n  if(!is.null(seed)) set.seed(seed)\n  \n  \n  #Compute the number of genes, the mutation probability is applied over the gene.\n  if(!DNFRules)\n    nGenes <- nvars * popSize\n  else\n    nGenes <- (length(max) - 1) * popSize\n  \n  \n  #Set the next gene to mute\n  numMutaciones <- round(pmutation * nGenes)\n  \n  object@DNFRules <- DNFRules\n  object@maxValuesRule <- max \n  object@popNew <- matrix(as.double(NA), nrow = popSize, ncol = nvars)\n  \n  # generate beginning population and Offspring pop\n  Pop <- matrix(as.integer(NA), nrow = popSize, ncol = nvars)\n  OffspringPop <- matrix(as.integer(NA), nrow = popSize, ncol = nvars)\n  UnionPop <- matrix(as.integer(NA), nrow = popSize *2, ncol = nvars)\n  \n  ng <- min(nrow(suggestions), popSize)\n  if(ng > 0) # use suggestion if provided\n  { Pop[1:ng,] <- suggestions }\n  # fill the rest with a random population\n  if(popSize > ng)\n  { if( ! DNFRules) \n    Pop[(ng+1):popSize,] <- population(object, 0.25, round(nvars*0.25))#[1:(popSize-ng),]\n  else \n    Pop[(ng+1):popSize,] <- population(object, 0.25, round((length(max) - 1)*0.25))[1:(popSize-ng),]\n  }\n  object@population <- Pop\n  \n  #This counts the number of indivuals that domain this one\n  Dominados <- numeric(popSize *2)\n  WhoIDomain <- vector(mode = \"list\", length = popSize *2) #Indicate the inviduals which are dominated by this one\n  rank <- numeric(popSize * 2) #Inidicate the rank of the individual\n  CrowdingDistance <- numeric(popSize * 2) #Indicate the crowding distance of the individual\n  dots <- list(...) #Catch dots arguments\n  nObjs <- sum(! is.na(dots[[9]])) - 1 # Number of objetives we are using. -1 because the last value indicate te use of dnf or can representation for fitness calc.\n  frentes <- vector(mode = \"list\", length = popSize * 2)\n  fitnessFrentes <- vector(mode = \"list\", length = popSize * 2)\n  coveredByIndividualFrentes <- vector(mode = \"list\", length = popSize * 2)\n  coveredByIndividual <- matrix(FALSE, ncol = popSize * 2, nrow = length( dots[[1]][[\"data\"]] ))\n  cubiertoActual <- cubiertoAnterior <- logical(length( dots[[1]][[\"data\"]] ))\n  nIterEvolve <- 0 #Evaluation where the population evolved the last time\n  fivePercent <- floor(run * 0.05)\n  nvariables <- nvars\n  dataset <- matrix(unlist(dots[[1]][[\"data\"]]), nrow = nvariables + 1)\n  targetClass <- which(dots[[1]][[\"class_names\"]] == dots[[3]]) - 1\n  \n  \n \n  #Evaluation of pop\n  for(i in seq_len( NROW(Pop) ))\n    if(all(is.na(Fitness[i,]))){\n      fit <- fitness(Pop[i,], ...) \n      Fitness[i,] <- fit[[1]]\n      coveredByIndividual[,i] <- as.logical(fit[[2]])\n      n_evals <- n_evals + 1\n    } \n  \n  \n  # start iterations\n  for(iter in seq_len(maxiter))\n  {\n    #reinitialize all values\n\n    #Dominados[] <- 0\n    UnionPop[] <- NA\n    OffspringPop[] <- NA\n    \n    \n    \n    \n    #Check stopping criteria\n    if(n_evals >= run) break  \n    if(max(Fitness, na.rm = TRUE) >= maxfitness) break\n    if(object@iter == maxiter) break  \n    \n    frentes <- vector(mode = \"list\", length = popSize * 2)\n    \n    # selection by Binary Tournament \n    # Copy the selected populatin into the offspring population\n    if(is.function(selection))\n    { \n    sel <- selection(Pop, popSize, rank, CrowdingDistance, Fitness, coveredByIndividual) \n    OffspringPop <- sel[[1]]\n    FitnessOffspring <- sel[[2]]\n    coveredByIndividual[,(popSize + 1):(popSize*2)] <- sel[[3]]\n    \n    }\n    else\n    { sel <- sample(1:popSize, size = popSize, replace = TRUE)\n    Pop <- object@population[sel,]\n    AdapatationValue <- object@fitness[sel]\n    }\n    \n    object@population <- OffspringPop\n   \n    # crossover performed by a double-point crossover on Offspring Pop\n    if(is.function(crossover) & pcrossover > 0)\n    { \n      nmating <- round( (popSize/2) * pcrossover )\n      \n      #mating <- matrix(sample(seq_len(popSize), size = 2*popSize, replace = TRUE), ncol = 2)\n      mating <- matrix(sample(seq_len(popSize), size = floor(popSize/2) * 2, replace = TRUE), ncol = 2)\n      equals <- which(mating[,1] == mating[,2])\n      \n      while(length(equals) > 0){\n        mating[equals,] <- matrix(sample(seq_len(popSize), size = 2*length(equals), replace = TRUE), ncol = 2)\n        equals <- which(mating[,1] == mating[,2])\n      }\n      \n      #throw popSize/2 random numbers\n      dados <- runif(floor(popSize/2))\n    \n      \n      #Check which pair of individuals cross\n      mating <- mating[which(dados <= pcrossover), , drop = F]\n    \n      for(i in seq_len(NROW(mating)))\n      { \n        parents <- mating[i,]\n        Crossover <- crossover(object, parents)\n        OffspringPop[parents,] <- Crossover$children\n        FitnessOffspring[parents,] <- NA\n        \n      }             \n    \n      object@population <- OffspringPop\n      nGenes <- NROW(na.exclude(OffspringPop)) * nvariables\n      \n    }\n    \n    # mutation \n    pm <- if(is.function(pmutation)) pmutation(object) else pmutation\n    if(DNFRules) nvars <- length(max) - 1\n    if(is.function(mutation) & pm > 0)\n    { \n      dados <- runif(nGenes)\n   \n      \n      genes <- which(dados <= pmutation)\n     \n      cromosomas <- ceiling(genes / nvariables)\n      vars <- (genes %% nvariables) + 1\n      \n#     \n#       if(!DNFRules)\n#         Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nvars)\n#       else\n#         Mutation <- matrix(data = NA, nrow = numMutaciones, ncol = nBits)\n      #Fitness[cromosomas, ] <- NA\n     \n      for(i in seq_len(length(vars))) \n      {     \n        object@population[cromosomas[i],] <- mutation(object, cromosomas[i], vars[i])\n      }\n      #print(Mutation)\n      OffspringPop <- object@population\n      \n      FitnessOffspring[cromosomas,] <- NA\n      #OffspringPop <- na.exclude(OffspringPop) #Por si tenemos menos cromosomas mutados\n      \n    }\n    \n    #Copy FitnessOffspring and evaluate individuals crossed and mutated\n    Fitness[(NROW(Pop) + 1):(popSize*2), ] <- FitnessOffspring\n  \n    \n   #Generate the next population.\n    \n    #Combine Pop and  OffspringPop into UnionPop\n    \n    UnionPop[seq_len(NROW(Pop)), ] <- Pop\n    UnionPop[(NROW(Pop) + 1):NROW(UnionPop), ] <- OffspringPop\n    #Evaluation of pop\n    for(i in (NROW(Pop) + 1):(popSize*2) )\n      if(all(is.na(Fitness[i,]))){\n        fit <- fitness(UnionPop[i,], ...) \n        Fitness[i,] <- fit[[1]]\n        coveredByIndividual[,i] <- as.logical( fit[[2]] )\n        n_evals <- n_evals + 1\n      } \n   \n  #Compute dominance values for performing fast sorting algorithm\n    f <- na.exclude(Fitness)[,seq_len(nObjs),drop=F]\n    n_Ind <- NROW(f)\n    for(i in seq_len(n_Ind)){\n      nd <- apply(X = f, MARGIN = 1, FUN = calculateDominance, f[i,,drop=F], StrictDominance)\n      Dominados[i] <- length(which(nd == 1L))\n      WhoIDomain[[i]] <- which(nd <= 0L)\n    }\n    \n    #Get the Pareto front\n    frentes[[1]] <- which(Dominados == 0)\n    \n    #Order UnionPop by dominance fronts (fast sorting algorithm)\n    p <- 1\n    while(length(frentes[[p]]) != 0){\n      p <- p+1\n      \n      for(i in frentes[[p - 1]]){\n        \n       if(length(WhoIDomain[[i]] > 0)){\n        Dominados[ WhoIDomain[[i]] ] <- Dominados[ WhoIDomain[[i]] ] - 1\n        alSaco <-  which(Dominados == 0)\n        if(length(alSaco) > 0){\n          frentes[[p]] <- c(frentes[[p]], alSaco)\n          rank[alSaco] <- p-1\n        }\n       } \n      } \n\n    }\n\n  \n    #Check if non-dominated front covers new examples and evolve\n    enElFrente <- frentes[[1]]\n    cubiertoActual <- apply(X = coveredByIndividual[, enElFrente, drop = F], MARGIN = 1, FUN = any)\n    \n    #Check if there are new examples covered \n    evolve <- any(! cubiertoAnterior[which(cubiertoActual)])\n    \n\n    \n    for(i in seq_len(p - 1)){\n      fitnessFrentes[[i]] <- Fitness[frentes[[i]], ,drop = F]\n      coveredByIndividualFrentes[[i]] <- coveredByIndividual[,frentes[[i]], drop = F]\n      frentes[[i]] <- UnionPop[frentes[[i]], , drop = F]\n      \n    }\n\n      if(evolve){\n        nIterEvolve <- n_evals\n      } \n    cubiertoAnterior <- cubiertoActual\n    \n      # fill the next population \n      aux <- fillPopulation(frentes, p - 1, fitnessFrentes, coveredByIndividualFrentes, popSize, nObjs)\n      Pop <- aux[[1]]\n      CrowdingDistance[seq_len(popSize)] <- aux[[2]]\n      Fitness[seq_len(popSize), ] <- aux[[3]]\n      rank <- aux[[4]]\n      coveredByIndividual <- aux[[5]]\n      \n      # Checks if we need to reinitialize the population\n      if(! evolve & ! aux[[6]] & reInitPop){\n      # Check reinit condicion\n      if(n_evals - nIterEvolve >= fivePercent){\n        \n        #re-initialize population\n    \n        #sel <- reInitPob(elitePop = frentes[[1]], fitnessElite = fitnessFrentes[[1]], coveredElite = coveredByIndividual[,enElFrente], crowdingDistance = CrowdingDistance, pctVariables = 0.5, cubiertoActual = cubiertoActual, dataset = dataset, maxRegla = dots[[1]][[\"conjuntos\"]], cate = dots[[14]], num = dots[[15]], crispSets = dots[[1]][[\"crispSets\"]], targetClass = targetClass, popSize = popSize )\n        sel <- reInitPob(elitePop = Pop, fitnessElite = Fitness[seq_len(popSize), ], coveredElite = coveredByIndividual[, seq_len(popSize)], crowdingDistance = CrowdingDistance, pctVariables = porcCob, cubiertoActual = cubiertoActual, dataset = dataset, maxRegla = dots[[1]][[\"conjuntos\"]], cate = dots[[14]], num = dots[[15]], crispSets = dots[[1]][[\"crispSets\"]], targetClass = targetClass, popSize = popSize )\n        Pop <- sel[[1]]\n        Fitness <- sel[[2]]\n        CrowdingDistance <- sel[[3]]\n        coveredByIndividual[,seq_len(popSize) ] <- sel[[4]]\n        \n        #Evaluation of generated pop\n        for(i in seq_len(popSize) )\n          if(all(is.na(Fitness[i,]))){\n            fit <- fitness(Pop[i,], ...) \n            Fitness[i,] <- fit[[1]]\n            coveredByIndividual[,i] <- as.logical( fit[[2]] )\n            newCovered <- which(! cubiertoAnterior[which(as.logical( fit[[2]] ))]) # Check if this rule covers new uncovered examples\n            n_evals <- n_evals + 1\n            if(length(newCovered) > 0){\n              nIterEvolve <- n_evals\n              cubiertoAnterior[newCovered] <- TRUE\n            }\n          }\n        \n        #Check if new population evolve\n        cubiertoActual <- apply(X = coveredByIndividual[, enElFrente, drop = F], MARGIN = 1, FUN = any)\n        evolve <- any(! cubiertoAnterior[which(cubiertoActual)])\n        cubiertoAnterior <- cubiertoActual\n        \n        if(evolve)\n          nIterEvolve <- n_evals\n         \n        rank[] <- 0\n        \n      }\n      }\n    \n      object@population <- Pop\n      object@fitness <- Fitness\n    \n  }\n  \n  \n  \n  \n  #get the last ranking\n  \n  #Compute dominance values for performing fast sorting algorithm\n  f <- na.exclude(Fitness)[1:popSize,seq_len(nObjs), drop = F]\n  n_Ind <- NROW(f)\n  for(i in seq_len(n_Ind)){\n    nd <- apply(X = f, MARGIN = 1, FUN = calculateDominance, f[i,], TRUE)\n    Dominados[i] <- length(which(nd == 1L))\n    WhoIDomain[[i]] <- which(nd <= 0L)\n  }\n  \n  #Get the Pareto front\n  frentes[[1]] <- which(Dominados == 0)\n  frentes[[1]] <- Pop[frentes[[1]], , drop = F]\n\n  \n  #Return individuals of the Pareto that has more confidence than the minimum.\n  unicos <- which(!duplicated(frentes[[1]]))\n  frentes[[1]] <- frentes[[1]][unicos, , drop = F]\n  \n  #Evaluate indivuduals for getting fuzzy confidence\n  dots[[9]] <- list(.confianzaDifusa, NA, NA, FALSE)\n  \n  for(i in seq_len(NROW( frentes[[1]])) ){\n      fit <- fitness(frentes[[1]][i,], dots[[1]],dots[[2]],dots[[3]],dots[[4]],dots[[5]],dots[[6]],dots[[7]],dots[[8]],dots[[9]],dots[[10]],dots[[11]],dots[[12]],dots[[13]],dots[[14]],dots[[15]],dots[[16]]) \n      Fitness[i,4] <- fit[[1]][1]\n  }\n  \n  frentes[[1]] <- frentes[[1]][which(Fitness[seq_len(NROW(frentes[[1]])),4] > 0.6), , drop = F]\n  frentes[[1]]\n  \n}\n\n\n\n\n#-------------------------------------------------------------------------------\n# ---  THis part is part of the definition of the \"ga\" class done in the GA Package\n#--------------------------------------------------------------------------------\n#\n# We need to change this behaviour, we don´t want to depend on this functions.\n# Because we don´t use it.\n\nsetClassUnion(\"numericOrNA\", members = c(\"numeric\", \"logical\", \"matrix\"))\nsetClassUnion(\"matrixOrList\", members = c(\"matrix\", \"list\"))\n\nsetClass(Class = \"ga\", \n         representation(call = \"language\",\n                        type = \"character\",\n                        min = \"numericOrNA\", \n                        max = \"numericOrNA\", \n                        nBits = \"numericOrNA\", \n                        names = \"character\",\n                        popSize = \"numeric\",\n                        iter = \"numeric\", \n                        run = \"numeric\", \n                        maxiter = \"numeric\",\n                        suggestions = \"matrix\",\n                        population = \"matrixOrList\",\n                        popNew = \"matrix\",\n                        elitism = \"numeric\", \n                        pcrossover = \"numeric\", \n                        pmutation = \"numericOrNA\",\n                        fitness = \"numericOrNA\",\n                        summary = \"matrix\",\n                        bestSol = \"list\",\n                        fitnessValue = \"numeric\",\n                        solution = \"matrix\",\n                        maxValuesRule = \"numericOrNA\",\n                        DNFRules = \"logical\"\n         ),\n         package = \"SDR\" \n) \n\nsetMethod(\"print\", \"ga\", function(x, ...) str(x))\n\nsetMethod(\"show\", \"ga\",\n          function(object)\n          { cat(\"An object of class \\\"ga\\\"\\n\")\n            cat(\"\\nCall:\\n\", deparse(object@call), \"\\n\\n\",sep=\"\")\n            cat(\"Available slots:\\n\")\n            print(slotNames(object))\n          }) \n\nsummary.ga <- function(object, ...)\n{\n  nvars <- ncol(object@population)\n  varnames <- parNames(object)\n  domain <- NULL\n  if(object@type == \"real-valued\")\n  { domain <- rbind(object@min, object@max)\n    rownames(domain) <- c(\"Min\", \"Max\")\n    if(ncol(domain) == nvars) \n      colnames(domain) <- varnames\n  }\n  suggestions <- NULL\n  if(nrow(object@suggestions) > 0) \n  { suggestions <- object@suggestions\n    dimnames(suggestions) <- list(1:nrow(suggestions), varnames) \n  }\n  \n  out <- list(type = object@type,\n              popSize = object@popSize,\n              maxiter = object@maxiter,\n              elitism = object@elitism,\n              pcrossover = object@pcrossover,\n              pmutation = object@pmutation,\n              domain = domain,\n              suggestions = suggestions,\n              iter = object@iter,\n              fitness = object@fitnessValue,\n              solution = object@solution)  \n  class(out) <- \"summary.ga\"\n  return(out)\n}\n\nsetMethod(\"summary\", \"ga\", summary.ga)\n\nprint.summary.ga <- function(x, digits = getOption(\"digits\"), ...)\n{\n  dotargs <- list(...)\n  if(is.null(dotargs$head)) dotargs$head <- 10\n  if(is.null(dotargs$tail)) dotargs$tail <- 1\n  if(is.null(dotargs$chead)) dotargs$chead <- 20\n  if(is.null(dotargs$ctail)) dotargs$ctail <- 1\n  \n  cat(\"+-----------------------------------+\\n\")\n  cat(\"|         Genetic Algorithm         |\\n\")\n  cat(\"+-----------------------------------+\\n\\n\")\n  cat(\"GA settings: \\n\")\n  cat(paste(\"Type                  = \", x$type, \"\\n\"))\n  cat(paste(\"Population size       = \", x$popSize, \"\\n\"))\n  cat(paste(\"Number of generations = \", x$maxiter, \"\\n\"))\n  cat(paste(\"Elitism               = \", x$elitism, \"\\n\"))\n  cat(paste(\"Crossover probability = \", format(x$pcrossover, digits = digits), \"\\n\"))\n  cat(paste(\"Mutation probability  = \", format(x$pmutation, digits = digits), \"\\n\"))\n  \n  if(x$type == \"real-valued\")\n  { cat(paste(\"Search domain \\n\"))\n    print(x$domain, digits = digits)\n  }\n  \n  if(!is.null(x$suggestions))\n  { cat(paste(\"Suggestions\", \"\\n\"))\n    do.call(\".printShortMatrix\", \n            c(list(x$suggestions, digits = digits), \n              dotargs[c(\"head\", \"tail\", \"chead\", \"ctail\")]))\n    # print(x$suggestions, digits = digits, ...)\n  }\n  \n  cat(\"\\nGA results: \\n\")\n  cat(paste(\"Iterations             =\", format(x$iter, digits = digits), \"\\n\"))\n  cat(paste(\"Fitness function value =\", format(x$fitness, digits = digits), \"\\n\"))\n  if(nrow(x$solution) > 1) \n  { cat(paste(\"Solutions              = \\n\")) }\n  else\n  { cat(paste(\"Solution               = \\n\")) }\n  do.call(\".printShortMatrix\", \n          c(list(x$solution, digits = digits), \n            dotargs[c(\"head\", \"tail\", \"chead\", \"ctail\")]))\n  # print(x$solution, digits = digits, ...)\n  \n  invisible()\n}\n\n\nplot.ga <- function(x, y, ylim, cex.points = 0.7,\n                    col = c(\"green3\", \"dodgerblue3\", adjustcolor(\"green3\", alpha.f = 0.1)),\n                    pch = c(16, 1), lty = c(1,2),\n                    grid = graphics:::grid, ...)\n{\n  object <- x  # Argh.  Really want to use 'object' anyway\n  is.final <- !(any(is.na(object@summary[,1])))\n  iters <- if(is.final) 1:object@iter else 1:object@maxiter\n  summary <- object@summary\n  if(missing(ylim)) \n  { ylim <- c(max(apply(summary[,c(2,4)], 2, \n                        function(x) min(range(x, na.rm = TRUE, finite = TRUE)))),\n              max(range(summary[,1], na.rm = TRUE, finite = TRUE))) \n  }\n  \n  plot(iters, summary[,1], type = \"n\", ylim = ylim, \n       xlab = \"Generation\", ylab = \"Fitness value\", ...)\n  if(is.final & is.function(grid)) \n  { grid() }\n  points(iters, summary[,1], type = ifelse(is.final, \"o\", \"p\"),\n         pch = pch[1], lty = lty[1], col = col[1], cex = cex.points)\n  points(iters, summary[,2], type = ifelse(is.final, \"o\", \"p\"),\n         pch = pch[2], lty = lty[2], col = col[2], cex = cex.points)\n  if(is.final)\n  { polygon(c(iters, rev(iters)), \n            c(summary[,4], rev(summary[,1])), \n            border = FALSE, col = col[3])\n    legend(\"bottomright\", legend = c(\"Best\", \"Mean\"), \n           col = col, pch = pch, lty = lty, pt.cex = cex.points, \n           inset = 0.01) }\n  else\n  { title(paste(\"Iteration\", object@iter), font.main = 1) }\n  \n  out <- cbind(iter = iters, summary)\n  invisible(out)\n}\n\nsetMethod(\"plot\", \"ga\", plot.ga)\n\n# questa non funziona quando installa il pacchetto con NAMESPACE\nsetGeneric(name = \"parNames\", \n           def = function(object, ...) { standardGeneric(\"parNames\") }\n)\n\nsetMethod(\"parNames\", \"ga\",\n          function(object, ...)\n          { \n            names <- object@names\n            nvars <- ncol(object@population)\n            if(length(names) == 0)\n            { names <- paste(\"x\", 1:nvars, sep = \"\") }\n            return(names)\n          })\n# per ora uso questo ma si dovrebbe ripristinare il metodo sopra:\n# gaParNames <- function(object, ...)\n# { \n#   names <- object@names\n#   nvars <- ncol(object@population)\n#   if(length(names) == 0)\n#     { names <- paste(\"x\", 1:nvars, sep = \"\") }\n#   return(names)\n# }\n\ngaMonitor <- function(object, digits = getOption(\"digits\"), ...)\n{ \n  fitness <- na.exclude(object@fitness)\n  cat(paste(\"Iter =\", object@iter, \n            \" | Mean =\", format(mean(fitness), digits = digits), \n            \" | Best =\", format(max(fitness), digits = digits), \"\\n\"))\n}\n\ngaSummary <- function(x, ...)\n{\n  # compute summary for each step\n  x <- na.exclude(as.vector(x))\n  q <- fivenum(x)\n  c(max = q[5], mean = mean(x), q3 = q[4], median = q[3], q1 = q[2], min = q[1])\n}\n\n\n\n\n\n\n\n\n\n\n\n\n#---------------------------------------------------------------------------------------------\n\n\n\n\n\n\n\n## \n## Modification of Permutation ga operators.\n##  This modification generate an integer random population in the range[min, max]\n##\n\n.generarPoblacion <- function(object, ...)\n{\n  # Generate a random permutation of size popSize in the range [min, max]  \n  min <- object@min\n  max <- object@max\n  type <- object@type\n  size <- object@popSize\n  \n  \n  if(! object@DNFRules){ # real-valued indica que se usan reglas tipo CAN\n    population <- matrix(as.double(NA), nrow = size, ncol = length( max ) )\n    for(i in 1:size)\n      for(j in 1:length(max))\n        #Se genera la poblacion inicial, el valor de no participaciÃ³n no cuenta ! \n        population[i,j] <- sample(0:(max[j]), size = 1, replace = TRUE)\n    \n  } else { # reglas DNF \n    v <- sample(x = c(0,1), size = max[length(max)] * size, replace = TRUE)\n    population <- matrix(data = v, nrow = size, ncol = max[length(max)],byrow = TRUE)\n  }\n  \n  return(population)\n}\n\n\n\n\n\n\n#  \n# GENERA LA POBLACION INICIAL PARA MESDIF\n# En el argumento ... deben de ir primero el porcentaje de poblacion que se genera completamente aleatorio\n# y en segundo lugar el nÃºmero mÃ¡ximo de variables que participan en la regla.\n.generarPoblacionMESDIF <- function(object, ...)\n{\n  # Generate a random permutation of size popSize in the range [min, max]  \n  min <- object@min\n  max <- object@max\n  type <- object@type\n  size <- object@popSize\n  lista <- list(...)\n  pctAleatorio <- lista[[1]]\n  numVarMax <- lista[[2]]\n  var_init <- logical(length(max))\n  \n  reglas <- ceiling(size * (1-pctAleatorio))\n  if(! object@DNFRules){ # real-valued indica que se usan reglas tipo CAN\n    population <- matrix(max, nrow = size, ncol = length( max ), byrow = TRUE )\n    # Biased Init\n    for(i in seq_len(reglas)){\n      var_init[] <- F\n      numVar <- sample(numVarMax, size = 1)\n      for(j in seq_len(numVar)){\n        var <- sample(length(max), size = 1)\n        while(var_init[var]){  #Hay que añadir esto tambien a reglas DNF\n          var <- sample(length(max), size = 1)\n        }\n        population[i, var] <- sample(0:(max[var]), size = 1, replace = TRUE) # No-Participate value is not into account\n        var_init[var] <- T\n        }\n    }\n    \n    \n    #Random Init\n    for(i in (reglas + 1):size){\n      \n      for(j in seq_len(length(max)))\n        \n        population[i,j] <- sample(0:(max[j]), size = 1, replace = TRUE)\n    }\n    \n    \n  } else { # reglas DNF \n    \n    # Random Init \n    v <- sample(x = c(0,1), size = max[length(max)] * size, replace = TRUE)\n    population <- matrix(data = v, nrow = size, ncol = max[length(max)],byrow = TRUE)\n    \n    #Biased Init\n    nReglasABorrar <- length(max) - 1 - numVarMax\n    for(i in (reglas + 1):size){\n      varia <- sample(length(max) - 1, size = nReglasABorrar, replace = FALSE)\n      for(j in seq_len(nReglasABorrar)){\n        population[i, ] <- borrar_gen(regla = population[i,], variable = varia[j], max_valor_variables = max, DNF_Rules = TRUE)\n      }\n    }\n  }\n  return(population)\n}\n\n\n\n\n\n\n\n\n\n#\n# Generates the initial population of NMEEF-SD\n#\n\n.generarPoblacionNMEEF <- function(object, ...)\n{\n  # Generate a random permutation of size popSize in the range [min, max]  \n  min <- as.integer(object@min)\n  max <- as.integer(object@max)\n  type <- object@type\n  size <- object@popSize\n  lista <- list(...)\n  pctAleatorio <- lista[[1]]\n  numVarMax <- lista[[2]]\n  var_init <- logical(length(max))\n  \n  reglas <- ceiling(size * (1-pctAleatorio))\n  if(! object@DNFRules){ # real-valued indica que se usan reglas tipo CAN\n    population <- matrix(max, nrow = size, ncol = length( max ), byrow = TRUE )\n    # Biased Init\n    for(i in seq_len(reglas)){\n      var_init[] <- F\n      numVar <- sample(numVarMax, size = 1)\n      for(j in seq_len(numVar)){\n        var <- sample(length(max), size = 1)\n        while(var_init[var]){  #Hay que añadir esto tambien a reglas DNF\n          var <- sample(length(max), size = 1)\n        }\n        population[i, var] <- sample(0:(max[var] - 1), size = 1, replace = TRUE) # No-Participate value is not into account\n        var_init[var] <- T\n      }\n    }\n      \n      #Random Init\n      for(i in (reglas + 1):size){\n        \n        for(j in seq_len(length(max)))\n          \n          population[i,j] <- sample(0:(max[j]), size = 1, replace = TRUE)\n      }\n      \n  } else { # reglas DNF \n    \n    # Random Init \n    v <- sample(x = c(0,1), size = max[length(max)] * size, replace = TRUE)\n    population <- matrix(data = v, nrow = size, ncol = max[length(max)],byrow = TRUE)\n    \n    #Biased Init\n    nReglasABorrar <- length(max) - 1 - numVarMax\n    for(i in (reglas + 1):size){\n      varia <- sample(length(max) - 1, size = nReglasABorrar, replace = FALSE)\n      for(j in seq_len(nReglasABorrar)){\n        population[i, ] <- borrar_gen(regla = population[i,], variable = varia[j], max_valor_variables = max, DNF_Rules = TRUE)\n      }\n    }\n  }\n\n  return(population)\n}\n\n\n\n\n\n\n\n\n\n#\n# Double-point crossover\n#\n.ga_dpCrossover <- function(object, parents, ...)\n{\n\n\n  if( ! object@DNFRules){ #REGLAS CAN\n     \n      parents <- object@population[parents,,drop = FALSE]\n      n <- ncol(parents)\n      children <- matrix(as.double(NA), nrow = 2, ncol = n)\n      fitnessChildren <- rep(NA, 2)\n      crossOverPoint1 <- sample(seq_len(n), size = 1, replace = TRUE)  \n      if(crossOverPoint1 == (n) )\n      { crossOverPoint2 <- n   } else {\n      crossOverPoint2 <- sample((crossOverPoint1 + 1):n, size = 1, replace = TRUE)\n      }\n      \n      children[1,] <- parents[1,]\n      children[2,] <- parents[2,]\n      \n      \n      \n      children[1, crossOverPoint1:crossOverPoint2] <- parents[2, crossOverPoint1:crossOverPoint2]\n      children[2, crossOverPoint1:crossOverPoint2] <- parents[1, crossOverPoint1:crossOverPoint2]\n      \n      out <- list(children = children, fitness = fitnessChildren)\n      return(out)\n  \n      } else { # REGLAS DNF \n      \n        \n        parents <- object@population[parents,,drop = FALSE]\n        max <- object@max\n        n <- length(max)\n        children <- matrix(as.double(NA), nrow = 2, ncol = max[length(max)])\n        fitnessChildren <- rep(NA, 2)\n        \n        #Cambiar n - 1 por n, ya que es para comparar con java\n        rangCrossover1 <- 2:(n) # Si la longitud de esto es 1, no se puede usar sample\n        if(length(rangCrossover1) > 1){\n          crossOverPoint1 <- sample(rangCrossover1, size = 1, replace = TRUE)  \n        } else {\n          crossOverPoint1 <- rangCrossover1\n        }\n        \n        if(crossOverPoint1 == (n) )\n        { crossOverPoint2 <- n   } else {\n          rangCrossover2 <- (crossOverPoint1 + 1):n\n          if(length(rangCrossover2) > 1){\n            crossOverPoint2 <- sample(rangCrossover2, size = 1, replace = TRUE)\n          } else {\n            crossOverPoint2 <- rangCrossover2\n          }\n        }\n      \n          rango <- (max[crossOverPoint1 - 1] + 1):max[crossOverPoint2]\n        \n        \n        children[1,] <- parents[1,]\n        children[2,] <- parents[2,]\n        \n        children[1, rango] <- parents[2, rango]\n        children[2, rango] <- parents[1, rango]\n        \n        out <- list(children = children, fitness = fitnessChildren)\n        return(out)\n        \n    }\n}\n\n\n\n\n\n\n\n\n\n# SDIga Mutation operator\n\n.gaCAN_Mutation <- function(object, parent, ...)\n{\n  \n  mutar <- parent <- as.vector(object@population[parent,]) \n  mutar <-  .mutate(cromosoma = mutar, variable = ...[[1]], max_valor_variables = object@maxValuesRule, DNF_Rule = object@DNFRules )\n  \n  return(mutar)\n}\n\n\n\n\n\n\n\n# MESDIF Mutation operatos\n\n.gaMESDIF_Mutation <- function(object, parent, ...)\n{\n  \n  mutar <- parent <- as.vector(object@population[parent,]) \n  mutar <-  .mutateMESDIF(cromosoma = mutar, variable = ...[[1]], max_valor_variables = object@maxValuesRule, DNF_Rule = object@DNFRules )\n  \n  return(mutar)\n}\n\n\n\n\n\n\n\n#NMEEF-SD Mutation operator\n\n.gaNMEEF_Mutation <- function(object, parent, ...)\n{\n  \n  mutar <- parent <- as.vector(object@population[parent,]) \n  mutar <-  .mutateNMEEF(cromosoma = mutar, variable = ...[[1]], max_valor_variables = object@maxValuesRule, DNF_Rule = object@DNFRules )\n  \n  return(mutar)\n}\n\n\n\n\n\n\n\n\n#Selection Function of SDIGA\n\n.ga_SDIgaSelection <- function(object){\n  n <- object@popSize \n  object@population[(n + 1):nrow(object@population), ] <- NA\n  \n  \n  object@fitness[(n + 1):length(object@fitness)] <- NA\n  \n  list(population = object@population, fitness = object@fitness)\n  \n}\n\n\n\n\n\n\n# Binary Tournament selection operator for MESDIF\n\n.ga_MESDIFBinTournamentSelection <- function(elitePop, sizePop, nvars, FitnessElite, ObjValues){\n  newPop <- matrix(NA, nrow = sizePop, ncol = nvars)\n \n  nas <- which(is.na(elitePop[,1,drop = F]))\n  if(length(nas) > 0 )ObjValues <- ObjValues[- nas, , drop = F]\n  elitePop <- na.exclude(elitePop)\n\n  seleccion <- sample(NROW(elitePop), size = sizePop * 2, replace = TRUE)\n  Fitness <- numeric(sizePop)\n  Obj <- matrix(NA, nrow = sizePop + NROW(elitePop), ncol = 4)\n  \n  fit <- FitnessElite[seleccion] \n  sel <- matrix(seleccion, nrow = 2)\n  fit <- matrix(fit, nrow = 2)\n  \n  vencedor <- fit[1,] <= fit[2,]\n\n  num <- sum(vencedor)\n \n  if(num > 0){\n    b <- which(vencedor)\n    a <- sel[1, b]\n    newPop[b, ] <- elitePop[a, ]\n    Fitness[b] <- FitnessElite[a]\n    Obj[b, ] <- ObjValues[a, ]\n  } \n  b <- which(!vencedor)\n  a <- sel[2, b]\n  newPop[b, ] <- elitePop[a, ]\n  Fitness[b] <- FitnessElite[a]\n  Obj[b, ] <- ObjValues[a, ]\n\n  Obj[(sizePop + 1):NROW(Obj), ] <- ObjValues\n  list(population = newPop, fitness = Fitness, obj = Obj)\n  \n  \n}\n\n\n\n\n\n#\n#\n# This function execute the corresponding genetic algorithm in function of the value of 'algorithm'\n#\n#\n\n.ejecutarga <- function(algorithm, dataset, targetClass, n_vars, por_cubrir, nLabels, N_evals, tam_pob, p_cross = 0.5, p_mut, seed, Objetivos = c(.LocalSupport, .confianza, NULL, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, cate, num, elitism = 5, porcCob = 0.5, strictDominance = TRUE, reInit = TRUE){\n  \n  ma <- dataset$conjuntos\n  \nif(DNFRules) {\n  ma <- Reduce(f = '+', x = ma, accumulate = TRUE)\n  ma <- c(0,ma)\n}\n  #Para reglas DNF, hay que utilizar como type el valor \"binary\", en vez de usar min y max, hay que usar el valor nBits, que indica la cantidad de genes que tiene cada cromosoma.\n  #Tambien hay que utilizar el valor 'max' para saber cu?ntos genes pertenecen a cada variable.\n  switch(algorithm, \n  \"SDIGA\" = { resultado <- gaSDIGA(type = if(!DNFRules) \"real-valued\" else \"binary\", \n                              #Fit12 es para reglas DNF hasta que no se solucione la optimizaciÃ³n de DNF para que sea igual que la CAN\n                  #fitness = .fit12, dataset, .separar(dataset = dataset), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, Pesos, DNFRules, Objetivos[[4]], FALSE,  cate, num,# Parametros de .fit12\n                  fitness = .fit13, dataset, matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, Pesos, DNFRules, Objetivos[[4]], FALSE,  cate, num,\n                  min = dataset[[4]][-length(dataset[[4]])],\n                  max = ma,\n                  nBits = ma[length(ma)],\n                  population = .generarPoblacion,\n                  selection = .ga_SDIgaSelection,\n                  crossover = .ga_dpCrossover,\n                  mutation = .gaCAN_Mutation,  \n                  popSize = tam_pob,\n                  pcrossover = 1 / tam_pob, #Con esto aseguramos que haya sÃ³lo un cruce, pero NO QUE SE CRUCEN LOS DOS MEJORES.\n                  pmutation = p_mut, # / length(ma), #Mutation probability applied at the gene\n                  elitism = 0,\n                  maxiter = N_evals,#floor( (N_evals - tam_pob) / (2 + tam_pob  * p_mut)),\n                  run = N_evals, # No queremos que se detenga la evaluacion.\n                  #  maxfitness = 1, # Si encontramos un cromosoma que tiene valor mÃ¡ximo, detenemos la bÃºsqueda.\n                  names = dataset[[2]][1:n_vars],\n                  keepBest = FALSE,\n                  parallel = FALSE,\n                  monitor = NULL,\n                  DNFRules = DNFRules,\n                  seed = seed) \n  }, \n  \"MESDIF\" =  { resultado <- gaMESDIF(type = if(!DNFRules) \"real-valued\" else \"binary\", \n                                #fitness = .fit12, dataset, .separar(dataset = dataset), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, Pesos, DNFRules, Objetivos[[4]], FALSE,  cate, num,# Parametros de .fit12\n                                fitness = .fitnessMESDIF, dataset, matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, c(0.7, 0.3, 0), DNFRules, Objetivos[[4]], FALSE,  cate, num,\n                                min = dataset[[4]][-length(dataset[[4]])],\n                                max = ma,\n                                nBits = ma[length(ma)],\n                                population = .generarPoblacionMESDIF,\n                                selection = .ga_MESDIFBinTournamentSelection,\n                                crossover = .ga_dpCrossover,\n                                mutation = .gaMESDIF_Mutation,  \n                                popSize = tam_pob,\n                                pcrossover = p_cross, \n                                pmutation = p_mut / length(ma),\n                                elitism = elitism,\n                                maxiter = N_evals,\n                                run = N_evals, # No queremos que se detenga la evaluacion.\n                                names = dataset[[2]][1:n_vars],\n                                keepBest = FALSE,\n                                parallel = FALSE,\n                                monitor = NULL,\n                                DNFRules = DNFRules,\n                                seed = seed) \n                return(resultado)\n  }, \n  \"NMEEFSD\" =  { resultado <- gaNMEEF(type = if(!DNFRules) \"real-valued\" else \"binary\", \n                                      #fitness = .fit12, dataset, .separar(dataset = dataset), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, Pesos, DNFRules, Objetivos[[4]], FALSE,  cate, num,# Parametros de .fit12\n                                      fitness = .fitnessMESDIF, dataset, matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass, por_cubrir, n_vars, nLabels, ma, FALSE, Objetivos, c(0.7,0.3,0), DNFRules, Objetivos[[4]], FALSE,  cate, num, TRUE, \n                                      min = dataset[[4]][-length(dataset[[4]])],\n                                      max = ma,\n                                      nBits = ma[length(ma)],\n                                      population = .generarPoblacionNMEEF,\n                                      selection = .selectionNMEEF,\n                                      crossover = .ga_dpCrossover,\n                                      mutation = .gaNMEEF_Mutation,  \n                                      popSize = tam_pob,\n                                      pcrossover = p_cross, \n                                      pmutation = p_mut,\n                                      elitism = 0,\n                                      maxiter = N_evals,\n                                      run = N_evals, \n                                      names = dataset[[2]][1:n_vars],\n                                      keepBest = FALSE,\n                                      parallel = FALSE,\n                                      monitor = NULL,\n                                      DNFRules = DNFRules,\n                                      seed = seed, \n                                      porcCob = porcCob,\n                                      StrictDominance = strictDominance,\n                                      reInitPop = reInit) \n  return(resultado) #Devolver las que superen minConf\n  }\n  )\n  #Only for SDIGA\n  .getBestRule(resultado)\n}\n\n\n\n#\n# Mark examples of the dataset covered by the rule returned by genetic algorithm\n# ONLY FOR SDIGA\n#\n\n.marcar_ejemplos <- function(regla, dataset, targetClass, nVars, maxRegla, por_cubrir, nLabels, Objetivos = c(.LocalSupport, .confianza, NA, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, cate, num){\n  \n  \n  #Devolver ejemplos nuevos cubiertos de la clase objetivo\n  #Cambiar por fit13\n  cover <- .fit13(regla = regla, dataset = dataset, noClass = matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass = targetClass, por_cubrir = por_cubrir, n_Vars = nVars,nLabels = nLabels, max_regla = maxRegla , marcar = TRUE, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNFRules, difuso = Objetivos[[4]], cate = cate, num = num)\n  \n  sumaNuevos <- sum(cover[[1]]) - sum(dataset[[\"covered\"]])\n  confi <- cover[[2]]\n  por_cubrir <- por_cubrir - sumaNuevos\n  \n  return( list(cubreNuevos = sumaNuevos > 0, covered = cover , porCubrir = por_cubrir, confidence = confi) )\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n#\n# Returns de best rule of the genetic algorithm. In case of draw, returns the rule with less atributes.\n# \n# ONLY FOR SDIGA \n#\n.getBestRule <- function(resultado){\n  bestFitness <- resultado@fitnessValue\n  \n  empates <- which(resultado@fitness == bestFitness)\n  if(length(empates) > 1){\n    if(!resultado@DNFRules){\n      lista <- apply(X = resultado@population[empates, ], MARGIN = 1, FUN = function(x, max) sum(x != max), resultado@max )\n    } else{\n      \n      lista <- apply(X = resultado@population[empates, ], MARGIN = 1, FUN = function(x, max){\n        particip <- .getParticipantes(regla = x, max_regla = max, DNFRules = TRUE)\n        val <- numeric(0)\n        for(i in 2:length(max)){\n          if(particip[i-1])\n            val <- c(val, (max[i-1]+1):max[i])\n        }\n        sum(x[val] != 0)\n      } , resultado@max ) # ESTO HAY QUE CAMBIARLO !!\n      \n    }\n    orden <- order(lista[which(lista > 0)])\n    \n    return(resultado@population[ orden[1] , ])\n  } else {\n    return(resultado@population[ empates , ])\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#Return the fitness value(s) of a rule\n\n.fit13 <- function(regla, dataset, noClass, targetClass, por_cubrir, n_Vars, nLabels, max_regla, marcar = FALSE, Objetivos = c(.LocalSupport, .confianza, NULL, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, difuso = FALSE ,test = FALSE, cate, num){\n\n  \n  if( ! any(is.na(regla))) { #Si la regla no tiene NA se puede evaluar\n    \n    regla <- as.integer(regla)\n    participantes <- logical(length(max_regla))\n    participantes <- .getParticipantes(regla = regla, max_regla = max_regla, DNFRules = DNFRules)\n    \n    \n    #If it's not the empty rule\n    if(any(participantes)){\n      \n      cat_particip <- which(cate & participantes)\n      num_particip <- which(num & participantes)\n      \n      max_regla_cat <- max_regla[cat_particip]\n      max_regla_num <- max_regla[num_particip]\n      \n      if(!DNFRules) { # CAN RULES\n        \n        #Split into numerical variables and categorical ones. (And participate in the rule)\n        if(length(cat_particip) > 0){\n          rule_cat <- regla[cat_particip]\n        }\n        \n        if(length(num_particip) > 0){\n          rule_num <- regla[num_particip]\n          \n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          #  Get values for xmin, xmedio and xmax for fuzzy computation.   \n          n_matrices <- dim(fuzzy_sets)[3]  \n   \n          xmin <- fuzzy_sets[cbind(rule_num + 1, 1, seq_len(n_matrices))]\n          xmax <- fuzzy_sets[cbind(rule_num + 1, 3, seq_len(n_matrices))]\n          xmedio <- fuzzy_sets[cbind(rule_num + 1, 2, seq_len(n_matrices))]\n          \n          #Get values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          xminC <- crispSets[cbind(rule_num + 1, 1, seq_len(n_matricesCrisp))]\n          xmaxC <- crispSets[cbind(rule_num + 1, 2, seq_len(n_matricesCrisp))]\n        }\n        \n        gr_perts <- .compara_CAN9(ejemplo = noClass, rule_cat = rule_cat, rule_num = rule_num, catParticip = cat_particip, numParticip = num_particip, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices, xminCrisp = xminC, xmaxCrisp = xmaxC,  max_regla_cat, max_regla_num)\n        \n      } else { # DNF RULES (FALTA EL TRATAMIENTO DE VARIABLES CATEGORICAS)\n        \n        \n        \n        \n        valNum <- mapply(FUN = ':', (max_regla_num + 1), (max_regla_num + nLabels), SIMPLIFY = FALSE)  \n        regla_num <- lapply(X = valNum, FUN = function(x, rule) rule[x], regla )\n        \n        if(length(num_particip) > 0){\n          \n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          \n          #  Gets values for xmin, xmedio and xmax for fuzzy computation. \n          # The format is a matrix, which columns has at first value the number of numerical \n          # variable, and then, the values for xmin, xmedio, xmax, and only for values that participate in the rule\n          n_matrices <- dim(fuzzy_sets)[3] \n          valuesFuzzy <- .getFuzzyValues(regla_num = regla_num, fuzzy = fuzzy_sets)\n         \n          #Gets values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          valuesCrisp <- .getFuzzyValues(regla_num = regla_num, fuzzy = crispSets, crisp = TRUE)\n        }\n        \n        #gr_perts <- lapply(X = noClass, FUN = .comparaDNF3, regla = regla, regla_num, cat_particip, num_particip,  max_regla_cat, max_regla_num, nLabels, fuzzy_sets, crispSets, valuesFuzzy, valuesCrisp)\n        gr_perts <- .comparaDNF4(ejemplo = noClass, regla = regla, regla_num, cat_particip, num_particip,  max_regla_cat, max_regla_num, nLabels, fuzzy_sets, crispSets, valuesFuzzy, valuesCrisp)\n        \n        \n        #gr_perts <- unlist(gr_perts)\n      }\n      \n      \n      values <- .get_values6(gr_perts = gr_perts, nombre_clases = dataset[[\"class_names\"]], dataset = dataset[[\"data\"]], targetClass = targetClass, examples_perClass = dataset[[\"examplesPerClass\"]],cov = dataset[[\"covered\"]], Ns = dataset[[\"Ns\"]], N_vars = n_Vars + 1, por_cubrir = por_cubrir, marcar = marcar, test = test, difuso = difuso)\n      \n      #Compute fitness\n      if(! marcar){\n        #fitness <- (0.7 * .LocalSupport(values) + 0.3 * .unusualness(values)) / 1.0\n        #fitness <- 0.7 * .LocalSupport(values) + 0.3 * .confianza(values)\n        # Para la realizaciÃ³n del cÃ¡lculo del fitnes se utilizan las medidas locales Crisp o difusas de la .confianza, da igual, pero son las LOCALES !!!!\n        #fitness <- 0.7 * .FLocalSupport(values) + 0.3 * .confianza(values)\n        fitness <- 0\n        if(is.function(Objetivos[[1]]) && Pesos[1] > 0){ \n          fitness <- fitness + (Objetivos[[1]](values) * Pesos[1])\n        }\n        if(is.function(Objetivos[[2]]) && Pesos[2] > 0){ \n          fitness <- fitness + (Objetivos[[2]](values) * Pesos[2])\n        }\n        if(is.function(Objetivos[[3]]) && Pesos[3] > 0) {\n          fitness <- fitness + (Objetivos[[3]](values) * Pesos[3])\n        }      \n        fitness <- fitness / (sum(Pesos))\n        # cat(\"Ns:\", values[[4]], \" - Local Support: \", .LocalSupport(values), \" - .confianza:\", .confianza(values), \" - Support: \", .Csupport(values),\" - .coverage:\", .coverage(values), \" - Fitness: \", fitness, file = \"\", fill = TRUE)\n        \n        fitness #Return\n      } else {\n        \n        values #Return\n      }\n      \n    } else{\n      0 #Return\n    }\n    \n  } else {\n    0 #Return\n  }\n  \n}\n\n\n.fitnessMESDIF <- function(regla, dataset, noClass, targetClass, por_cubrir, n_Vars, nLabels, max_regla, marcar = FALSE, Objetivos = c(.LocalSupport, .confianza, NULL, FALSE), Pesos = c(0.7,0.3,0), DNFRules = FALSE, difuso = FALSE ,test = FALSE, cate, num, NMEEF = FALSE){\n  require(parallel)\n  \n  if( ! any(is.na(regla))) { #Si la regla no tiene NA se puede evaluar\n    \n    regla <- as.numeric(regla)\n    participantes <- logical(length(max_regla))\n    participantes <- .getParticipantes(regla = regla, max_regla = max_regla, DNFRules = DNFRules)\n    \n    \n    #If it's not the empty rule\n    if(any(participantes)){\n      \n      cat_particip <- which(cate & participantes)\n      num_particip <- which(num & participantes)\n      \n      max_regla_cat <- max_regla[cat_particip]\n      max_regla_num <- max_regla[num_particip]\n      \n      if(!DNFRules) { # CAN RULES\n        \n        #Split into numerical variables and categorical ones. (And participate in the rule)\n        \n        rule_cat <- regla[cat_particip]\n        rule_num <- regla[num_particip]\n        \n        if(length(num_particip) > 0){\n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          #  Get values for xmin, xmedio and xmax for fuzzy computation.   \n          n_matrices <- dim(fuzzy_sets)[3]  \n          xmin <- fuzzy_sets[cbind(rule_num + 1, 1, seq_len(n_matrices))]\n          xmax <- fuzzy_sets[cbind(rule_num + 1, 3, seq_len(n_matrices))]\n          xmedio <- fuzzy_sets[cbind(rule_num + 1, 2, seq_len(n_matrices))]\n          \n          #Get values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          xminC <- crispSets[cbind(rule_num + 1, 1, seq_len(n_matricesCrisp))]\n          xmaxC <- crispSets[cbind(rule_num + 1, 2, seq_len(n_matricesCrisp))]\n        }\n        \n        gr_perts <- .compara_CAN9(ejemplo = noClass, rule_cat = rule_cat, rule_num = rule_num, catParticip = cat_particip, numParticip = num_particip, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices, xminCrisp = xminC, xmaxCrisp = xmaxC,  max_regla_cat, max_regla_num)\n        \n      } else { # DNF RULES\n        \n        \n        \n        \n        valNum <- mapply(FUN = ':', (max_regla_num + 1), (max_regla_num + nLabels), SIMPLIFY = FALSE)  \n        regla_num <- lapply(X = valNum, FUN = function(x, rule) rule[x], regla )\n        \n        if(length(num_particip) > 0){\n          \n          fuzzy_sets <- dataset[[\"fuzzySets\"]][1:nLabels, 1:3, num_particip, drop = F]\n          crispSets <- dataset[[\"crispSets\"]][1:nLabels, 1:2, num_particip, drop = F]\n          \n          #  Gets values for xmin, xmedio and xmax for fuzzy computation. \n          # The format is a matrix, which columns has at first value the number of numerical \n          # variable, and then, the values for xmin, xmedio, xmax, and only for values that participate in the rule\n          n_matrices <- dim(fuzzy_sets)[3] \n          valuesFuzzy <- .getFuzzyValues(regla_num = regla_num, fuzzy = fuzzy_sets)\n          \n          #Gets values for xmin and xmax for crisp computation\n          n_matricesCrisp <- dim(crispSets)[3]  \n          valuesCrisp <- .getFuzzyValues(regla_num = regla_num, fuzzy = crispSets, crisp = TRUE)\n        }\n        \n        #gr_perts <- lapply(X = .separar(dataset), FUN = .comparaDNF3, regla = regla, regla_num, cat_particip, num_particip,  max_regla_cat, max_regla_num, nLabels, fuzzy_sets, crispSets, valuesFuzzy, valuesCrisp)\n        gr_perts <- .comparaDNF4(ejemplo = noClass, regla = regla, regla_num, cat_particip, num_particip,  max_regla_cat, max_regla_num, nLabels, fuzzy_sets, crispSets, valuesFuzzy, valuesCrisp)\n        \n        \n        #gr_perts <- unlist(gr_perts)\n      }\n      \n      \n      if(!DNFRules)\n        values <- .get_values6(gr_perts = gr_perts, nombre_clases = dataset[[\"class_names\"]], dataset = dataset[[\"data\"]], targetClass = targetClass, examples_perClass = dataset[[\"examplesPerClass\"]],cov = dataset[[\"covered\"]], Ns = dataset[[\"Ns\"]], N_vars = n_Vars + 1, por_cubrir = por_cubrir, marcar = marcar, test = test, difuso = difuso, NMEEF)\n      else\n        values <- .get_values6(gr_perts = gr_perts, nombre_clases = dataset[[\"class_names\"]], dataset = dataset[[\"data\"]], targetClass = targetClass, examples_perClass = dataset[[\"examplesPerClass\"]],cov = dataset[[\"covered\"]], Ns = dataset[[\"Ns\"]], N_vars = n_Vars + 1, por_cubrir = por_cubrir, marcar = marcar, test = test, difuso = difuso, NMEEF)\n      \n      #Compute fitness\n      if(! marcar){\n        #fitness <- (0.7 * .LocalSupport(values) + 0.3 * .unusualness(values)) / 1.0\n        #fitness <- 0.7 * .LocalSupport(values) + 0.3 * .confianza(values)\n        # Para la realizaciÃ³n del cÃ¡lculo del fitnes se utilizan las medidas locales Crisp o difusas de la .confianza, da igual, pero son las LOCALES !!!!\n        #fitness <- 0.7 * .FLocalSupport(values) + 0.3 * .confianza(values)\n        fitness <- numeric(4)\n        fitness[1] <- if(is.function( Objetivos[[1]])) Objetivos[[1]](values) else 0\n        fitness[2] <- if(is.function( Objetivos[[2]])) Objetivos[[2]](values) else 0\n        fitness[3] <- if(is.function( Objetivos[[3]])) Objetivos[[3]](values) else 0\n        if(! NMEEF)\n          fitness #Return\n        else \n          list(fit = fitness, covered = values[[13]]) # Return\n      } else {\n        \n        values #Return\n      }\n      \n    } else{\n      c(0,0,0,0) #Return\n    }\n    \n  } else {\n    c(0,0,0,0) #Return\n  }\n  \n}\n\n\n",
    "created" : 1434888254071.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "547729682",
    "id" : "101A879",
    "lastKnownWriteTime" : 1434767408,
    "path" : "~/MEGA/MEGAsync/Universidad/Trabajo Fin de Grado/SDR/R/ga.R",
    "project_path" : "R/ga.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}