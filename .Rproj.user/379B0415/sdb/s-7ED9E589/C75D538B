{
    "contents" : "\n#\n#\n# Calculate the volume of a sphere in n dimensions for SPEA2 fitness calculation.\n#\n#\n.volSphere <- function(dimensions){\n  vol = 1\n  \n  if(dimensions %% 2 == 0){\n    d2 <- dimensions / 2\n    for ( i in seq_len(d2))\n      vol <- vol * i\n    vol <- (pi^d2) / vol\n    \n  } else {\n    v <- (dimensions-1)/2+1\n    for ( i in v:dimensions)\n      vol <- vol * i;\n    vol = 2^dimensions * pi^(v - 1) * vol\n  }\n  vol\n}\n\n\n\n\n\n#\n#\n# Mutation operator for MESDIF\n#\n#\n.mutateMESDIF <- function(cromosoma, variable, max_valor_variables, DNF_Rule){\n  \n  \n  mutation_type <- sample(x = 1:2, size = 1)   #Type 1 -> Eliminate the variable, Type 2 -> change the value for a random one\n  \n  \n  if(! DNF_Rule){  #Reglas can?nicas\n    if(mutation_type == 1L){\n      \n      cromosoma[variable] <- max_valor_variables[variable] #Se pone el valor de no participacion\n      \n    } else {  #Assign a random value (elimination value NOT INCLUDED)\n      \n      value <- sample(x = 0:(max_valor_variables[variable] - 1), size = 1)\n      cromosoma[variable] <- value \n      \n    }\n    \n  } else { #Reglas DNF\n    \n    variable <- variable + 1\n    rango <- (max_valor_variables[variable - 1] + 1):max_valor_variables[variable]\n    \n    \n    if(mutation_type == 1){  #Valor de no participaci?n de la variable\n      \n      cromosoma[rango] <- 0\n      \n    } else {  #Asigna valor aleatorio en la variable\n      \n      cromosoma[rango] <- sample(x = 0:1 , size = length(rango), replace = TRUE)\n      \n    }\n    \n  }\n  \n  \n  \n  cromosoma  # Return\n  \n}\n\n\n\n\n\n#\n#\n# Truncation operator for the elite population in MESDIF\n# This is called when the number of non-dominated individuals are greater than elite population size.\n#\n#\ntruncOperator <- function(NonDominatedPop, elitePopSize, FitnessND ){\n  #Calculate distance between individuals\n  distancia <- as.matrix( dist(x = FitnessND, method = \"euclidean\") ) ^2\n \n  #Distance between themselves eliminated.\n  diag(distancia) <- Inf\n  \n  #Order the distance matrix\n  sortedIndex <- apply(X = distancia, MARGIN = 1,FUN = order)\n  \n  individuos <- NROW(NonDominatedPop)\n  noMantener <- logical(individuos)\n  \n  while(individuos > elitePopSize){\n    \n    #Find the minimal distance among individuals\n    minimo <- which(distancia == min(distancia), arr.ind = TRUE,useNames = FALSE)\n  \n    if(NROW(minimo) == 1){\n      #Remove the individual directly\n      noMantener[minimo[,2]] <- T\n      distancia[minimo[,2],  ] <- Inf\n      distancia[,minimo[,2]  ] <- Inf\n      \n    } else {\n      \n    fila <- minimo[1,1]\n    columna <- minimo[1,2]\n    \n    \n    #We found the two closest individuals, now we have to erase one of them. This will be who have the minimum distance between his k-th closest neighbour\n    pos <- 1\n    while(distancia[sortedIndex[pos,fila], fila]== distancia[sortedIndex[pos,columna], columna] & pos < NROW(distancia)){\n      pos <- pos + 1\n    }\n \n    #Erase the closest individual\n    if(distancia[sortedIndex[pos,fila],fila] < distancia[sortedIndex[pos,columna],columna]){\n   \n      noMantener[fila] <- T\n      distancia[fila,  ] <- Inf\n      distancia[,fila  ] <- Inf\n      \n      #The position in sortedIndex is now the last.\n      sortedIndex <- apply(sortedIndex, MARGIN = 2, function(x, value, individuos){\n        x[which(x == value):(individuos - 1)] <- x[which(x == value):(individuos - 1) + 1];\n        x[individuos] <- value;\n        x\n      }, fila, individuos)\n      \n    } else {\n      \n      noMantener[columna] <- T\n      distancia[, columna] <- Inf\n      distancia[columna, ] <- Inf\n     \n      sortedIndex <- apply(sortedIndex, MARGIN = 2, function(x, value, individuos){\n            x[which(x == value):(individuos - 1)] <- x[which(x == value):(individuos - 1) + 1];\n            x[individuos] <- value;\n            x\n            }, columna, individuos)\n      \n    }\n    }\n    \n    individuos <- individuos - 1\n  }\n \n list(poblation = NonDominatedPop[which(! noMantener), , drop = F], individuals = which(! noMantener) )\n}\n\n\n\n#' \n#' @title Multiobjective Evolutionary Subgroup DIscovery Fuzzy rules (MESDIF) Algorithm\n#' @description This function search for interesting subgroups by executing the MESDIF algorithm. \n#' @param paramFile The path of the parameters file.\n#' @section How does this algorithm work?:\n#'   This algorithm performs a multi-objective genetic algorithm based on elitism (following the SPEA2 approach). The elite population has \n#'   a fixed size and it is filled by non-dominated individuals.\n#'   \n#'   An individual is non-dominated when \\code{(! all(ObjI1 <= ObjI2) & any(ObjI1 < ObjI2))} where ObjI1\n#'   is the objetive value for our individual and ObjI2 is the objetive value for another individual.\n#'   The number of dominated individuals by each one determine, in addition with a niches technique that considers\n#'   the proximity among values of the objectives a fitness value for the selection.\n#'   \n#'   The number of non-dominated individuals might be greater or less than elite population size and in those cases\n#'   MESDIF implements a truncation operator and a fill operator respectively. Then, genetic operators are\n#'   applied.\n#'   \n#'   At the final of the evolutive process it returns the rules stored in elite population.\n#'   \n#' @section Parameters file structure:\n#'   The \\code{paramFile} argument points to a file which has the necesary parameters for MESDIF works.\n#'   This file \\strong{must} be, at least, those parameters (separated by a carriage return):\n#'   \\itemize{\n#'     \\item \\code{algorithm}  Specify the algorithm to execute. In this case. \"MESDIF\"\n#'     \\item \\code{inputData}  Specify two paths of KEEL files for training and test. In case of specify only the name of the file, the path will be the working directory.\n#'     \\item \\code{seed}  Sets the seed for the random number generator\n#'     \\item \\code{nLabels}  Sets the number of fuzzy labels to create when reading the files\n#'     \\item \\code{nEval}  Set the maximun number of \\strong{evaluations of rules} for stop the genetic process\n#'     \\item \\code{popLength}  Sets number of individuals of the main population\n#'     \\item \\code{eliteLength}  Sets number of individuals of the elite population. Must be less than \\code{popLength}  \n#'     \\item \\code{crossProb}  Crossover probability of the genetic algorithm. Value in [0,1]\n#'     \\item \\code{mutProb}  Mutation probability of the genetic algorithm. Value in [0,1]\n#'     \\item \\code{Obj1} Sets the objetive nº 1. \n#'     \\item \\code{Obj2} Sets the objetive nº 2. \n#'     \\item \\code{Obj3} Sets the objetive nº 3. \n#'     \\item \\code{Obj4} Sets the objetive nº 4.\n#'     \\item \\code{RulesRep}  Representation of each chromosome of the population. \"can\" for canonical representation. \"dnf\" for DNF representation.\n#'     \\item \\code{targetClass}  Value of the target variable to search for subgroups. The target variable \\strong{is always the last variable.} Use \\code{null} to search for every value of the target variable\n#'   }\n#'   \n#'   An example of parameter file could be:\n#'  \\preformatted{\n#'  algorithm = MESDIF\n#'  inputData = \"irisd-10-1tra.dat\" \"irisd-10-1tst.dat\"\n#'  seed = 0\n#'  nLabels = 3\n#'  nEval = 10000\n#'  popLength = 100\n#'  eliteLength = 3\n#'  crossProb = 0.6\n#'  mutProb = 0.01\n#'  RulesRep = can\n#'  Obj1 = comp\n#'  Obj2 = unus\n#'  Obj3 = null\n#'  Obj4 = null\n#'  targetClass = Iris-setosa }\n#'\n#'   @section Objective values:\n#'      You can use the following quality measures in the ObjX value of the parameter file using this values:\n#'       \\itemize{\n#'         \\item Unusualness -> \\code{unus}\n#'         \\item Crisp Support -> \\code{csup}\n#'         \\item Crisp Confidence -> \\code{ccnf}\n#'         \\item Fuzzy Support -> \\code{fsup}\n#'         \\item Fuzzy Confidence -> \\code{fcnf}\n#'         \\item Coverage -> \\code{cove}\n#'         \\item Significance -> \\code{sign}\n#'       }\n#'     \n#'     If you don´t want to use a objetive value you must specify \\code{null}\n#' \n#' \n#' @return The algorithm shows in the console the following results:\n#' \\enumerate{\n#'  \\item The parameters used in the algorithm\n#'  \\item The rules generated.\n#'  \\item The quality measures for test of every rule and the global results.\n#' }\n#' \n#' \n#' \n#' @references \n#' \\itemize{\n#'  \\item Berlanga, F., Del Jesus, M., González, P., Herrera, F., & Mesonero, M. (2006). Multiobjective Evolutionary Induction of Subgroup Discovery Fuzzy Rules: A Case Study in Marketing.\n#'  \\item Zitzler, E., Laumanns, M., & Thiele, L. (2001). SPEA2: Improving the Strength Pareto Evolutionary Algorithm. \n#' }\n#' \nMESDIF <- function(paramFile = NULL,\n                   training = NULL, \n                   test = NULL, \n                   output = c(\"optionsFile.txt\", \"rulesFile.txt\", \"testQM.txt\"),\n                   seed = 0, \n                   nLabels = 3,\n                   nEval = 10000, \n                   popLength = 100, \n                   eliteLength = 3,\n                   crossProb = 0.6,\n                   mutProb = 0.01, \n                   RulesRep = \"can\",\n                   Obj1 = \"CSUP\", \n                   Obj2 = \"CCNF\",\n                   Obj3 = \"null\",\n                   Obj4 = \"null\",\n                   targetClass = \"null\"\n                   )\n{\n \n  if(is.null(paramFile)){\n    #Generate our \"parameters file\"\n    if(class(training) != \"keel\" | class(test) != \"keel\")\n      stop(\"Training or test parameters is not a KEEL class\")\n    \n    if(is.null(training) | is.null(test)) \n      stop(\"Not provided a test or training file and neither a parameter file. Aborting...\")\n    \n    if(training[[1]] != test[[1]] )\n      stop(\"datasets does not have the same relation name.\")\n    \n    \n    parametros <- list(seed = seed, \n                       algorithm = \"MESDIF\",\n                       outputData = output,\n                       nEval = nEval, \n                       popLength = popLength,\n                       elitePop = eliteLength,\n                       nLabels = nLabels,\n                       mutProb = mutProb,\n                       crossProb = crossProb,\n                       RulesRep = RulesRep,\n                       Obj1 = Obj1, \n                       Obj2 = Obj2,\n                       Obj3 = Obj3,\n                       Obj4 = Obj4,\n                       targetClass = targetClass)\n  } else {\n  # Parametros --------------------------\n    parametros <- read.parametersFile2(file = paramFile)  # parametros del algoritmo\n    if(parametros$algorithm != \"MESDIF\") \n      stop(paste(\"The algorithm specificied (\", parametros$algorithm, \") in parameters file is not MESDIF. Check parameters file. Aborting program...\"))\n    \n    test <- read.keel(file = parametros$inputData[2], nLabels = parametros$nLabels)        # test data\n    \n    training <- read.keel(file = parametros$inputData[1], nLabels = parametros$nLabels )   # training data\n  }\n  \n  \n  file.remove(parametros$outputData[which(file.exists(parametros$outputData))])\n  if(file.exists(\"testQualityMeasures.txt\")) file.remove(\"testQualityMeasures.txt\")\n  \n  if(tolower(parametros$RulesRep) == \"can\"){\n    DNF = FALSE\n  } else {\n    DNF = TRUE\n    vars <-  Reduce(f = '+', x = training[[\"conjuntos\"]], accumulate = TRUE)\n    vars <- vars[length(vars)]\n  }\n  \n  .show_parameters(params = parametros, train = training, test = test)\n  contador <- 0\n  \n  Objetivos <- .parseObjetives(parametros = parametros, \"MESDIF\", DNF)\n  \n  if(all(is.na(Objetivos[1:3]))) stop(\"No objetive values selected. You must select, at least, one objective value. Aborting...\")\n  \n  cate <- training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'c'\n  num <- training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'r' | training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'e'\n \n  \n  #---------------------------------------------------\n  \n  \n  #----- OBTENCION DE LAS REGLAS -------------------\n  if(parametros$targetClass != \"null\"){ # Ejecuci?n para una clase\n    cat(\"\\n\", \"\\n\", \"Searching rules for only one value of the target class...\", \"\\n\", \"\\n\", file =\"\", fill = TRUE) \n    reglas <- findRule(parametros$targetClass, \"MESDIF\", training, parametros, DNF, cate, num, Objetivos)\n    if(! DNF) \n      reglas <-  matrix(unlist(reglas), ncol =  training[[\"nVars\"]] + 1 , byrow = TRUE)\n    else \n      reglas <-  matrix(unlist(reglas), ncol = vars + 1 , byrow = TRUE)\n    \n  } else {  #Ejecucion para todas las clases\n    \n    cat(\"\\n\", \"\\n\", \"Searching rules for all values of the target class...\", \"\\n\", \"\\n\", file =\"\", fill = TRUE)  \n    \n    #If we are on Windowns, we can´t use mclapply because it use FORK() for parallelism\n    if(Sys.info()[1] == \"Windows\")\n      reglas <- lapply(X = training$class_names, FUN = findRule, \"MESDIF\",training, parametros, DNF, cate, num, Objetivos)\n    else\n      reglas <- mclapply(X = training$class_names, FUN = findRule, \"MESDIF\",training, parametros, DNF, cate, num, Objetivos   , mc.cores = detectCores() )\n  \n    \n    if(! DNF) \n      reglas <-  matrix(unlist(reglas), ncol =  training[[\"nVars\"]] + 1 , byrow = TRUE)\n    else \n      reglas <-  matrix(unlist(reglas), ncol = vars + 1 , byrow = TRUE)\n    \n  #Print Rules if we are not in Windows because mclapply doesn´t show any output.\n  if(Sys.info()[1] != \"Windows\")\n  for(i in seq_len(NROW(reglas))){\n    cat(\"GENERATED RULE\", i,   file = \"\", sep = \" \",fill = TRUE)\n    #cat(\"GENERATED RULE\", i,   file = parametros$outputData[2], sep = \" \",fill = TRUE, append = TRUE)\n    print.rule(rule = as.numeric( reglas[i, - NCOL(reglas)] ), max = training$conjuntos, names = training$atributeNames, consecuente = reglas[i, NCOL(reglas)], types = training$atributeTypes,fuzzySets = training$fuzzySets, categoricalValues = training$categoricalValues, DNF, rulesFile = parametros$outputData[2])\n    cat(\"\\n\",\"\\n\",  file = \"\", sep = \"\",fill = TRUE)\n    #cat(\"\\n\",  file = parametros$outputData[2], sep = \"\",fill = TRUE, append = TRUE)\n  }\n    \n    \n  }\n  \n  #---------------------------------------------------\n  \n  cat(\"\\n\", \"\\n\", \"Testing rules...\", \"\\n\", \"\\n\", file = \"\", sep = \" \", fill = TRUE)\n  \n  #--------  Testeo de las reglas --------------------\n  sumNvars <- 0\n  sumCov <- 0\n  sumFsup <- 0\n  sumCsup <- 0\n  sumCconf <- 0\n  sumFconf <- 0\n  sumUnus <- 0\n  sumSign <- 0\n  sumAccu <- 0\n  \n  n_reglas <- NROW(reglas)\n  for(i in seq_len(n_reglas)){\n    val <- .probeRule2(rule = reglas[i, - NCOL(reglas)], testSet = test, targetClass = reglas[i, NCOL(reglas)], numRule = i, parametros = parametros, Objetivos = Objetivos, Pesos = Pesos, cate = cate, num = num, DNF = DNF)\n    test[[\"covered\"]] <- val[[\"covered\"]]\n    sumNvars <- sumNvars + val[[\"nVars\"]]\n    sumCov <- sumCov + val[[\"coverage\"]]\n    sumFsup <- sumFsup + val[[\"fsupport\"]]\n    sumCconf <- sumCconf + val[[\"cconfidence\"]]\n    sumFconf <- sumFconf + val[[\"fconfidence\"]]\n    sumUnus <- sumUnus + val[[\"unusualness\"]]\n    sumSign <- sumSign + val[[\"significance\"]]\n    sumAccu <- sumAccu + val[[\"accuracy\"]]\n  }\n  \n  \n  \n  #Medidas de calidad globales\n  cat(\"Global:\", file =\"\", fill = TRUE)\n  cat(paste(\"\\t ? N_rules:\", NROW(reglas), sep = \" \"),\n      paste(\"\\t ? N_vars:\", round(sumNvars / n_reglas, 6), sep = \" \"),\n      paste(\"\\t ? Coverage:\", round(sumCov / n_reglas, 6), sep = \" \"),\n      paste(\"\\t ? Significance:\", round(sumSign / n_reglas, 6), sep = \" \"),\n      paste(\"\\t ? Unusualness:\", round(sumUnus / n_reglas, 6), sep = \" \"),\n      paste(\"\\t ? Accuracy:\", round(sumAccu / n_reglas, 6), sep = \" \"),\n      paste(\"\\t ? CSupport:\", round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6), sep = \" \"),\n      paste(\"\\t ? FSupport:\", round(sumFsup / n_reglas, 6), sep = \" \"),\n      paste(\"\\t ? FConfidence:\", round(sumFconf / n_reglas, 6), sep = \" \"),\n      paste(\"\\t ? CConfidence:\", round(sumCconf / n_reglas, 6), sep = \" \"),\n      file = \"\", sep = \"\\n\"\n  )\n  \n  #Medidas de calidad globales (Save in testMeasures File)\n  cat( \"Global:\",\n       paste(\"\\t - N_rules:\", nrow(reglas), sep = \" \"),\n       paste(\"\\t - N_vars:\", round(sumNvars / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Coverage:\", round(sumCov / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Significance:\", round(sumSign / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Unusualness:\", round(sumUnus / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - Accuracy:\", round(sumAccu / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - CSupport:\", round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6), sep = \" \"),\n       paste(\"\\t - FSupport:\", round(sumFsup / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - FConfidence:\", round(sumFconf / n_reglas, 6), sep = \" \"),\n       paste(\"\\t - CConfidence:\", round(sumCconf / n_reglas, 6), sep = \" \"),\n       file = parametros$outputData[3], sep = \"\\n\", append = TRUE\n  )\n  \n  \n  #Medidas de calidad globales (Save in testMeasures File)\n  cat(\n    nrow(reglas),\n    round(sumNvars / n_reglas, 6),\n    round(sumCov / n_reglas, 6),\n    round(sumSign / n_reglas, 6),\n    round(sumUnus / n_reglas, 6),\n    round(sumAccu / n_reglas, 6),\n    round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6),\n    round(sumFsup / n_reglas, 6),\n    round(sumFconf / n_reglas, 6),\n    round(sumCconf / n_reglas, 6),\n    file = \"testQualityMeasures.txt\", sep = \"\\n\", append = TRUE\n  )\n  #---------------------------------------------------\n  \n}\n\n\n\nfindRule <- function(targetClass, algorithm, training, parametros, DNF, cate, num, Objetivos, porcCob = 0.5, strictDominance = TRUE, reInit = TRUE){\n  #Check if target class is valid\n  if(! any(training$class_names == targetClass)) stop(\"Invalid target class value provided.\")\n  cat(\" ? Target value:\", targetClass ,\"\\n\", file = \"\", sep = \" \", fill = TRUE)\n  \n  por_cubrir = training$examplesPerClass[[targetClass]]\n  rule <- .ejecutarga(algorithm = algorithm, dataset = training, targetClass = targetClass, n_vars = training$nVars, por_cubrir = por_cubrir, nLabels = parametros$nLabels, N_evals = parametros$nEval,  tam_pob = parametros$popLength, p_cross = parametros$crossProb, p_mut = parametros$mutProb, seed = parametros$seed, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, cate = cate, num = num, elitism = parametros[[\"elitePop\"]], porcCob = porcCob, strictDominance = strictDominance, reInit = reInit)     \n  \n  \n  reglas <- vector(mode = \"list\", length = NROW(rule))\n  rule <- cbind(rule, targetClass)\n  for(i in seq_len(length(reglas))){\n    reglas[[i]] <- rule[i,]\n    cat(\"GENERATED RULE\", i,   file = \"\", sep = \" \",fill = TRUE)\n    cat(\"GENERATED RULE\", i,   file = parametros$outputData[2], sep = \" \",fill = TRUE, append = TRUE)\n    print.rule(rule = as.numeric( rule[i, - NCOL(rule)] ), max = training$conjuntos, names = training$atributeNames, consecuente = targetClass, types = training$atributeTypes,fuzzySets = training$fuzzySets, categoricalValues = training$categoricalValues, DNF, rulesFile = parametros$outputData[2])\n    cat(\"\\n\",\"\\n\",  file = \"\", sep = \"\",fill = TRUE)\n    cat(\"\\n\",  file = parametros$outputData[2], sep = \"\",fill = TRUE, append = TRUE)\n  }\n  reglas\n}",
    "created" : 1434888255627.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "1000135538",
    "id" : "C75D538B",
    "lastKnownWriteTime" : 1434893462,
    "path" : "~/MEGA/MEGAsync/Universidad/Trabajo Fin de Grado/SDR/R/MESDIF.R",
    "project_path" : "R/MESDIF.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}