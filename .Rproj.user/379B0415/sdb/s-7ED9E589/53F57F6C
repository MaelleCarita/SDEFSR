{
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\n# library(graphics)\n#library(GA)\n\n#Sources-----------------\n# source(\"leerDatos.R\")\n# source(\"Difuso.R\")\n# source(\"ga.R\")\n# source(\"MESDIF.R\")\n# source(\"NMEEFSD.R\")\n# source(\"PruebasEficiencia.R\")\n# source(\"QualityMeasures.R\")\n# source(\"SDIGA.R\")\n#---------------------------\n\n#Limit size for an input file\nMAX_SIZE_MB = 10\noptions(shiny.maxRequestSize= MAX_SIZE_MB * 1024^2)\n\n\ndataTra <- NULL\ndatosTra <- NULL\n\ndataTst <- NULL\ndatosTst <- NULL\n\nrutaTra <- \"\"\nrutaTst <- \"\"\n\ndata <- NULL\ndatos <- NULL\ngraficoSectores <- T\nfileAnterios <- \"Tra\"\n\n# The colors for the graphs (obtened from Material Design: http://www.google.ch/design/spec/style/color.html#color-color-palette)\ncolors <- c(\"#E8F5E9\", \"#A5D6A7\", \"#4CAF50\", \"#388E3C\", \"#FFF9C4\", \"#FFF176\", \n            \"#FFEB3B\", \"#FDD835\", \"#F9A825\")\n\n\nlastValue <- 0\n\nshinyServer(function(input, output, session) {\n  \n  \n  #on exit clean temporal file\n  on.exit({ \n    if(file.exists(paste(getwd(), \"/rulesFile.txt\",  sep = \"\"))) file.remove(paste(getwd(), \"/rulesFile.txt\",  sep = \"\"))\n    if(file.exists(paste(getwd(), \"/optionsFile.txt\",  sep = \"\"))) file.remove(paste(getwd(), \"/optionsFile.txt\",  sep = \"\"))\n    if(file.exists(paste(getwd(), \"/testQualityMeasures.txt\",  sep = \"\"))) file.remove(paste(getwd(), \"/testQualityMeasures.txt\",  sep = \"\"))\n  })\n  \n  \n  \n  \n  output$statistics <- renderTable({\n    #----Inputs de los que escucha ------\n    input$traTstRadio\n    input$classNames\n    input$traFile\n    input$tstFile\n    #------------------------------\n    if(input$targetClassSelect == \"NA\" || length(input$targetClassSelect) == 0 || is.null(input$targetClassSelect))\n      return(NULL)\n    \n     pos <- which(data[[2]] == input$targetClassSelect)\n     if(length(pos) > 0){\n       \n    if(data[[3]][pos] != 'c'){\n      resu <- summary(datos[which(data[[2]] == input$targetClassSelect), ])\n      as.matrix(resu)\n    }else{\n      \n      posiciones <- NULL\n      for(i in input$classNames){\n        p <- which(data[[15]][[pos]][datos[pos,] + 1] == i)\n        if(length(p) > 0 )\n          posiciones <- c(posiciones, p)\n      }\n      \n      \n      resu <- summary(data[[2]][datos[which(data[[2]] == input$targetClassSelect), posiciones] + 1])\n      as.matrix(resu)\n    }\n     }\n  })\n  \n  \n  output$datasetInfo <- renderPlot({\n    \n    #----Inputs de los que escucha ------\n    tra <- input$traTstRadio\n    graficoSectores <- input$visualizacion == \"Pie Chart\"\n    input$traTstRadio\n    input$ejecutar\n    #------------------------------------\n    \n    if(input$targetClassSelect == \"NA\" || length(input$targetClassSelect) == 0 || is.null(input$targetClassSelect))\n      return(NULL)\n \n    pos <- which(data[[2]] == input$targetClassSelect)\n    if(length(pos) == 0)\n      return(NULL)\n    \n    categorico <- data[[3]][pos] == 'c'\n    \n    if(graficoSectores & categorico){\n    \n        posiciones <- NULL\n        for(i in input$classNames){\n          p <- which(data[[15]][[pos]][datos[pos,] + 1] == i)\n          if(length(p) > 0 )\n            posiciones <- c(posiciones, p)\n        }\n        if(!is.null(posiciones)){\n          tabla <- table(data[[15]][[pos]][datos[pos,]+1][posiciones])\n          pie(x = tabla,\n              labels = paste(names(tabla), tabla, sep = \": \"),\n              radius = 1, \n              clockwise = TRUE,\n              col = colors, \n              main = \"Distribution of examples over variables\"\n          )\n        }\n    \n    \n    } else {\n      if(categorico){\n        posiciones <- NULL\n        for(i in input$classNames){\n          p <- which(data[[15]][[pos]][datos[pos,] + 1] == i)\n          if(length(p) > 0 )\n            posiciones <- c(posiciones, p)\n        }\n        barplot(tabla <- table(data[[15]][[pos]][datos[pos,]+1][posiciones]),\n                main = \"Distribution of examples over variables\",\n                col = colors\n                )\n      } else {\n        updateRadioButtons(session, \"visualizacion\", selected = \"Histogram\")\n        hist(x = datos[pos,],\n             col = colors,\n             main = \"Distribution of examples over variables\",\n             ylab = \"Frequency\",\n             xlab = \"Value\")\n      }\n    }\n    \n  })\n  \n  \n  \n  \n  \n  # Observe Training File\n observe({\n   if(! is.null(input$traFile)){\n     tryCatch({\n    if(rutaTra != paste(input$traFile[,1],input$traFile[,4])){\n      file <- input$traFile\n      rutaTra <<- paste(input$traFile[,1],input$traFile[,4])\n      dataTra <<- read.keel(file$datapath, nLabels = input$nLabels)\n      updateSelectInput(session = session, \n                        inputId = \"targetClassSelect\", \n                        label = \"Select the target variable\", \n                        choices = dataTra[[2]], selected = dataTra[[2]][length(dataTra[[2]])])\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(dataTra[[3]][length(dataTra[[2]])] == 'c') \n                                      c(\"All Values\", dataTra[[15]][[length(dataTra[[2]])]])\n                                  else\n                                    \"This is not a categorical variable!\"\n                          )\n      updateRadioButtons(session, \"traTstRadio\", \n                         label = \"Visualize file: \", \n                         choices = c(\"Training File\", \"Test File\"), \n                         selected = \"Training File\")\n      \n      data <<- dataTra\n      datosTra <<- matrix(unlist(dataTra$data), nrow = dataTra$nVars + 1)\n      datos <<- datosTra\n      updateAttributes(session, dataTra[[2]][length(dataTra[[2]])])\n    }\n     } , error = function(e) print(e)) \n   }\n })\n  \n  \n  \n  # Observe Test File\n  observe({\n    if(! is.null(input$tstFile)){\n      if(rutaTst != paste(input$tstFile[,1], input$tstFile[,4])){\n        file <- input$tstFile\n        rutaTst <<- paste(input$tstFile[,1], input$tstFile[,4])\n        dataTst <<- read.keel(file$datapath,nLabels = input$nLabels)\n        updateSelectInput(session = session, \n                          inputId = \"targetClassSelect\", \n                          label = \"Select the target variable\", \n                          choices = dataTst[[2]], selected = dataTst[[2]][length(dataTst[[2]])])\n        updateSelectInput(session = session, \n                          inputId = \"targetValueSelect\", \n                          label = \"Select the target value\", \n                          choices = if(dataTst[[3]][length(dataTst[[2]])] == 'c') \n                            c(\"All Values\", dataTst[[15]][[length(dataTst[[2]])]] )\n                          else\n                            \"This is not a categorical variable!\"\n        )\n        updateRadioButtons(session, \"traTstRadio\", \n                           label = \"Visualize file: \", \n                           choices = c(\"Training File\", \"Test File\"), \n                           selected = \"Test File\")\n        data <<- dataTst\n        datosTst <<- matrix(unlist(dataTst$data), nrow = dataTst$nVars + 1)\n        datos <<- datosTst\n        updateAttributes(session, dataTst[[2]][length(dataTst[[2]])])\n        \n      }\n    }\n  })\n  \n   #Observe nLabels\n  observe({ \n    nLabels <- input$nLabels\n    \n    if(! is.null(dataTra)){\n      dataTra <<- modifyFuzzyCrispIntervals(dataTra, nLabels)\n    }\n    \n    if(! is.null(dataTst)){\n      dataTst <<- modifyFuzzyCrispIntervals(dataTst, nLabels)\n    }\n  })\n  \n  \n  \n  \n  \n  #Observe Visualize File\n  observe({\n    file <- input$traTstRadio\n    if(file == \"Training File\" & fileAnterios == \"Tst\"){\n      fileAnterios <<- \"Tra\"\n      data <<- dataTra\n      datos <<- datosTra\n      updateSelectInput(session = session, \n                        inputId = \"targetClassSelect\", \n                        label = \"Select the target variable\", \n                        choices = data[[2]], selected = data[[2]][length(data[[2]])])\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(!is.null(data) ) if(data[[3]][length(data[[2]])] == 'c') \n                          c(\"All Values\", data[[15]][[length(data[[2]])]])\n                        else\n                          \"This is not a categorical variable!\"\n      )\n      \n      updateAttributes(session, data[[2]][length(data[[2]])])\n      \n    } else if(file == \"Test File\" & fileAnterios == \"Tra\") {\n      fileAnterios <<- \"Tst\"\n      data <<- dataTst\n      datos <<- datosTst\n      updateSelectInput(session = session, \n                        inputId = \"targetClassSelect\", \n                        label = \"Select the target variable\", \n                        choices = data[[2]], selected = data[[2]][length(data[[2]])])\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(!is.null(data) )if(data[[3]][length(data[[2]])] == 'c') \n                          c(\"All Values\", data[[15]][[length(data[[2]])]])\n                        else\n                          \"This is not a categorical variable!\"\n      )\n      updateAttributes(session, data[[2]][length(data[[2]])])\n   \n      }\n  })\n  \n  #Observe Target Variable\n  observe({\n    \n    pos <- which(data[[2]] == input$targetClassSelect)\n    if(length(pos) > 0){\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(data[[3]][pos] == 'c') \n                          c(\"All Values\", data[[15]][[pos]])\n                        else\n                          \"This is not a categorical variable!\"\n      )\n    }\n    updateAttributes(session, input$targetClassSelect)\n \n  })\n  \n  \n  #EJECUTAR ALGORITMO\n\n  observe({\n    input$ejecutar\n  \n    value <- input$ejecutar\n\n  \n    if(input$ejecutar <= lastValue) return(NULL)\n    \n    tryCatch({\n    # Read parameters and check errors\n    # ----------------------------------------------\n    if(any(is.null(dataTra), is.null(dataTst)) )\n      stop(\"You must supply a training file and a test file. \")\n    \n    if(dataTra[[1]] != dataTst[[1]])\n      stop(\"Training and test file must be the same relation.\")\n    \n    targetValue <- isolate(input$targetValueSelect)\n    if(targetValue == \"This is not a categorical variable!\")\n      stop(\"No categorical variable selected as target variable.\")\n    \n    if(targetValue == \"All Values\")\n      targetValue <- \"null\"\n    \n    #Set target Variable.\n\n      dataTst <<- changeTargetVariable(dataTst, which(input$targetClassSelect == dataTst[[2]]))\n      dataTra <<- changeTargetVariable(dataTra, which(input$targetClassSelect == dataTra[[2]]))\n    \n      \n    targetClass <- isolate(input$targetClassSelect)\n    algorithm <- isolate(input$algoritmo)\n    \n    nLabels <- isolate(input$nLabels)\n    rulesRep <- if(isolate(input$rulesRep == \"Canonical\")) \"can\" else \"dnf\"\n    nEvals <- isolate(input$nEval)\n    popSize <- isolate(input$popSize)\n    crossProb <- isolate(input$crossProb)\n    mutProb <- isolate(input$mutProb)\n    seed <- isolate(input$seed)\n    #------------------------------------------------------\n    \n  \n    \n    # Preparation of specific parameters and execution of the algoritm.\n    switch(algorithm,\n           \"SDIGA\"= {\n             minConf <- isolate(input$minConf)\n             Obj1 <- getObjetives(isolate(input$Obj1))\n             w1 <- isolate(input$w1)\n             Obj2 <- getObjetives(isolate(input$Obj2))\n             w2 <- isolate(input$w2)\n             Obj3 <- getObjetives(isolate(input$Obj3))\n             w3 <- isolate(input$w3)\n             lSearch = if(isolate(input$lSearch)) \"yes\" else \"no\"\n            \n             # Execute the algorithm\n             #sink(\"tempFile.txt\")\n             SDIGA(training = dataTra, \n                   test = dataTst, \n                   seed = seed, \n                   nLabels = nLabels, \n                   nEval = nEvals,\n                   popLength = popSize, \n                   mutProb = mutProb,\n                   RulesRep = rulesRep, \n                   Obj1 = Obj1, \n                   w1 = w1, \n                   Obj2 = Obj2, \n                   w2 = w2, \n                   Obj3 = Obj3, \n                   w3 = w3, \n                   minConf = minConf,\n                   lSearch = lSearch,\n                   targetClass = targetValue )\n             #sink(NULL)\n             \n            \n           },\n           \"MESDIF\" = {\n             \n             elitePop <- isolate(input$elitePop)\n             if(elitePop > popSize) stop(\"Elite population must be smaller than population size\")\n             Obj1 <- getObjetives(isolate(input$Obj1M))\n             Obj2 <- getObjetives(isolate(input$Obj2M))\n             Obj3 <- getObjetives(isolate(input$Obj3M))\n             Obj4 <- getObjetives(isolate(input$Obj3M))\n             \n            \n             # Execute the algorithm\n             #sink(\"tempFile.txt\")\n             MESDIF(training = dataTra,\n                    test = dataTst,\n                    seed = seed,\n                    nLabels = nLabels,\n                    nEval = nEvals,\n                    popLength = popSize,\n                    eliteLength = elitePop,\n                    crossProb = crossProb,\n                    mutProb = mutProb,\n                    RulesRep = rulesRep,\n                    Obj1 = Obj1,\n                    Obj2 = Obj2,\n                    Obj3 = Obj3,\n                    Obj4 = Obj4,\n                    targetClass = targetValue)\n             #sink(NULL)\n             \n           },\n           \"NMEEF-SD\" = {\n             minCnf <- isolate(input$minConf)\n             Obj1 <- getObjetives(isolate(input$Obj1N))\n             Obj2 <- getObjetives(isolate(input$Obj2N))\n             Obj3 <- getObjetives(isolate(input$Obj3N))\n             strictDominance <- if(isolate(input$strictDominance)) \"yes\" else \"no\"\n             reInit <- if(isolate(input$reInitPob)) \"yes\" else \"no\"\n             porcCob <- isolate(input$porcCob)\n             \n             #Execute te algorithm\n             NMEEF_SD(training = dataTra,\n                      test = dataTst,\n                      seed = seed,\n                      nLabels = nLabels,\n                      nEval = nEvals,\n                      popLength = popSize,\n                      mutProb = mutProb,\n                      crossProb = crossProb,\n                      RulesRep = rulesRep,\n                      Obj1 = Obj1,\n                      Obj2 = Obj2,\n                      Obj3 = Obj3,\n                      minCnf = minCnf,\n                      reInitCoverage = reInit,\n                      porcCob = porcCob,\n                      StrictDominance = strictDominance,\n                      targetClass = targetValue)\n           }\n    )\n    \n    },\n    error = function(e){\n      cat(as.character(e), file = \"rulesFile.txt\")\n      cat(as.character(e), file = \"optionsFile.txt\")\n      cat(as.character(e), file = \"testQualityMeasures.txt\")\n      return(NULL)\n    }\n    )\n\n    \n    if (input$ejecutar > 0){\n      updateTabsetPanel(session = session, inputId = \"tabSet\", selected = \"Rules generated\")\n    }\n    lastValue <<- value\n  })\n\n  \n  \n  \n  \n  \n  # RESULTADOS \n  \n  output$resultados <- renderDataTable({\n    \n    input$ejecutar\n      if(file.exists(\"rulesFile.txt\")){\n      #get and parse the results\n      contents <- readChar(\"rulesFile.txt\", file.info(\"rulesFile.txt\")$size)\n      rules <- strsplit(contents, \"GENERATED RULE \", fixed = TRUE )\n      if(length(rules[[1]]) > 1){\n        rules <- substr(rules[[1]][2:length(rules[[1]])] , 3, stop = nchar(rules[[1]][2:length(rules[[1]])]))\n        \n        invalid <- grep(\" # Invalid (Low confidence or support)\", rules, fixed = T) \n        if(length(invalid) > 0) rules <- rules[ - invalid ]\n        \n        rules <- gsub(\" - Target value: .*\", \"\", rules, perl = T)\n        rules <- sub(\":\", \"\", rules, fixed = FALSE)\n        rules <- gsub(pattern = \"\\n\", x = rules, replacement = \"<br/>\", fixed = T)\n      }\n      file.remove(\"rulesFile.txt\")\n      \n      # Show the results\n      rules <- matrix(c(seq_len(length(rules)), rules), ncol = 2)\n      colnames(rules) <- c(\"Num Rule\", \"Rule\")\n     \n      as.data.frame(rules)\n    }\n}, escape = FALSE, options = list(pageLength = 10))\n  \n  \n  \n  \n  output$execInfo <- renderUI({\n    input$ejecutar\n    if(file.exists(\"optionsFile.txt\")){\n      #get and process results\n      contents <- readChar(\"optionsFile.txt\", file.info(\"optionsFile.txt\")$size)\n      contents <- gsub(pattern = \"\\n\", replacement = \"<br/>\", x = contents, fixed = TRUE)\n      file.remove(\"optionsFile.txt\")\n      \n      #Show results as html\n      strong( HTML(contents), style = \"font-family: 'consolas'\" )\n         \n    }\n  })\n  \n  \n  output$medidas <- renderDataTable({\n    input$ejecutar\n    if(file.exists(\"testQualityMeasures.txt\")){\n      #get and process results\n      contents <- readChar(\"testQualityMeasures.txt\", file.info(\"testQualityMeasures.txt\")$size)\n      contents <- as.numeric(unlist( strsplit(contents, \"\\n\", fixed = TRUE) ) )\n      \n      mat <- matrix(contents, ncol = 10, byrow = TRUE)\n      aux <- mat[seq_len(nrow(mat) - 1) , 1:9]\n      mat[seq_len(nrow(mat) - 1) , 2:10] <- aux\n      mat[seq_len(nrow(mat) - 1) , 1] <- NA\n      colnames(mat) <- c(\"nRules\", \"nVars\", \"Coverage\", \"Significance\", \"Unusualness\", \"Accuracy\", \"CSupport\", \"FSupport\", \"CConfidence\", \"FConfidence\")\n      rownames(mat) <- c( seq_len((length(contents) / 10 - 1)), \"Global: \")\n      file.remove(\"testQualityMeasures.txt\")\n      \n      #Show results as html\n      #as.table(mat)\n      as.data.frame(mat, stringsAsFactors = FALSE)\n     \n    }\n  })\n\n})\n\ngetObjetives <- function(obj){\n  switch(obj,\n         \"null\" = {\"null\"},\n          \"Crisp Support\" = {\"CSUP\"},\n         \"Fuzzy Support\" = {\"FSUP\"},\n         \"Crisp Confidence\" = {\"CCNF\"},\n         \"Fuzzy Confidence\" = {\"FCNF\"},\n         \"Coverage\" = {\"COVE\"},\n         \"Significance\" = {\"SIGN\"},\n         \"Unusualness\" = {\"UNUS\"}\n         )\n}\n\n\nupdateAttributes <- function(session, attribute){\n  if(attribute == \"NA\" || length(attribute) == 0 || is.null(attribute))\n    return(NULL)\n  \n    if( data[[3]][which(data[[2]] == attribute)] == 'c' )\n      updateCheckboxGroupInput(session, inputId = \"classNames\", label = \"Select attributes\", choices = data[[15]][[which(data[[2]] == attribute)]], selected = data[[15]][[which(data[[2]] == attribute)]], inline = T)\n    else\n      updateCheckboxGroupInput(session, \"classNames\", label = \"Select attributes\", choices = list(), inline = T)\n  \n}\n\n\nmakeSDIGAParamFile <- function(input, nLabels, ruleRep, nEvals, popSize, crossProb, mutProb, seed, minConf, Obj1, w1, Obj2, w2, Obj3, w3, lSearch, targetClass){\n  fichero <- paste(\n    \"algorithm = SDIGA\\n\",\n    \"inputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"outputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"seed = \", seed, \"\\n\",\n    \"nLabels = \", nLabels, \"\\n\",\n    \"nEval = \", nEvals, \"\\n\",\n    \"popLength = \", popSize, \"\\n\",\n    \"crossProb = \", crossProb, \"\\n\",\n    \"mutProb = \", mutProb, \"\\n\",\n    \"minConf = \", minConf, \"\\n\",\n    \"RulesRep = \", ruleRep, \"\\n\",\n    \"Obj1 = \", if(is.null(Obj1)) \"null\" else Obj1, \"\\n\",\n    \"Obj2 = \", if(is.null(Obj2)) \"null\" else Obj2, \"\\n\",\n    \"Obj3 = \", if(is.null(Obj3)) \"null\" else Obj3, \"\\n\",\n    \"w1 = \", w1, \"\\n\",\n    \"w2 = \", w2, \"\\n\",\n    \"w3 = \", w3, \"\\n\",\n    \"lSearch = \", lSearch, \"\\n\",\n    \"targetClass = \", if(targetClass == \"All Values\") \"null\" else targetClass, \"\\n\"\n    , sep = \"\"\n  )\n  \n  cat(fichero, file = \"param.txt\", append = FALSE)\n  fichero\n}\n\nmakeMESDIFParamFile <- function(input, nLabels, ruleRep, nEvals, popSize, eliteSize, crossProb, mutProb, seed, Obj1, Obj2, Obj3, Obj4, targetClass){\n  fichero <- paste(\n    \"algorithm = MESDIF\\n\",\n    \"inputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"outputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"seed = \", seed, \"\\n\",\n    \"nLabels = \", nLabels, \"\\n\",\n    \"nEval = \", nEvals, \"\\n\",\n    \"popLength = \", popSize, \"\\n\",\n    \"eliteLength = \", eliteSize, \"\\n\",\n    \"crossProb = \", crossProb, \"\\n\",\n    \"mutProb = \", mutProb, \"\\n\",\n    \"RulesRep = \", ruleRep, \"\\n\",\n    \"Obj1 = \", if(is.null(Obj1)) \"null\" else Obj1, \"\\n\",\n    \"Obj2 = \", if(is.null(Obj2)) \"null\" else Obj2, \"\\n\",\n    \"Obj3 = \", if(is.null(Obj3)) \"null\" else Obj3, \"\\n\",\n    \"Obj4 = \", if(is.null(Obj4)) \"null\" else Obj4, \"\\n\",\n    \"echo = no\", \"\\n\",\n    \"targetClass = \", if(targetClass == \"All Values\") \"null\" else targetClass, \"\\n\"\n    , sep = \"\"\n  )\n  \n  cat(fichero, file = \"param.txt\", append = FALSE)\n  fichero\n}\n ",
    "created" : 1434900956088.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "406469702",
    "id" : "53F57F6C",
    "lastKnownWriteTime" : 1434900888,
    "path" : "~/MEGA/MEGAsync/Universidad/Trabajo Fin de Grado/SDR/inst/shiny/server.R",
    "project_path" : "inst/shiny/server.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}