{
    "contents" : "\n# This variable is for fix precision errors in numeric comparisons using the operator '==', '<=' or '>='\n.tolerance <- 1e-10\n\n#\n#\n# This function creates all the fuzzy intervals for a dataset\n#\n#\n.create_fuzzyIntervals <- function(min, max, num_sets, types){\n  #mapply(.FuzzyIntervals, min, max, num_sets, types, SIMPLIFY = FALSE)\n  n_mats <- length(min)\n  lst <- lapply(X = 1:n_mats, FUN = function(x) .FuzzyIntervals(min = min[x], max = max[x], num_sets = num_sets, types = types[x]))\n  \n  arr <- do.call(cbind, lst)\n  dim(arr) <- c(num_sets, 3, n_mats)\n  arr\n}\n\n\n#\n#\n#  Function to create fuzzy intervals over a single variable.\n#\n#\n\n.FuzzyIntervals <- function(min, max, num_sets, types){\n  \n  xmin <- min - ( (max - min) / (num_sets - 1) )\n  xmedio <- min\n  xmax <- 0\n  \n  \n  \n  cjto_fuzzy <- matrix(nrow = num_sets, ncol = 3)\n  \n  for(j in 1:num_sets){ # For each fuzzy set\n    if(types != \"c\"){ \n      xmax <- min + ( (max - min) / (num_sets - 1) ) * j\n      \n     \n      \n      #Save fuzzy set\n      cjto_fuzzy[j, 1] <- xmin\n      cjto_fuzzy[j, 2] <- xmedio\n      cjto_fuzzy[j, 3] <- xmax\n      \n      #Modify variables \n      xmin <- xmedio\n      xmedio <- xmax\n    }\n  }\n  #Return\n  cjto_fuzzy\n  \n}\n\n\n\n\n\n#-----------------------------------------------------------------------------------\n#    Creates crisp sets relative to the fuzzy sets generated before.\n#    This works because the fuzzy sets are all triangular. If it doesn´t, it doesn´t work\n#-----------------------------------------------------------------------------------\n\n.createCrispIntervals <- function(fuzzyIntervals){\n  n_mat <- dim(fuzzyIntervals)[3]\n  n_vars <- dim(fuzzyIntervals)[1]\n  crispIntervals <- lapply(X = 1:n_mat, FUN = function(x, fuzzy) .CrispIntervals(fuzzy[,,x]) , fuzzyIntervals)\n  \n  arr <- do.call(cbind, crispIntervals)\n  dim(arr) <- c(n_vars, 2, n_mat)\n  arr\n}\n\n\n\n\n\n\n#\n#\n# Create crisp sets for a single variable \n# \n#\n.CrispIntervals <- function(fuzzyInterval){\n  n_vars <- dim(fuzzyInterval)[1] # Cada fila de la matriz es una variable\n  \n  crispMatrix <- matrix(nrow = n_vars, ncol = 2)\n  min <- fuzzyInterval[1,1]\n  max <- (fuzzyInterval[1,3] + fuzzyInterval[1,2]) / 2\n  crispMatrix[1,1] <- min\n  crispMatrix[1,2] <- max\n  for(i in 2:n_vars){\n    min <- max\n    max <- (fuzzyInterval[i,3] + fuzzyInterval[i,2]) / 2\n    crispMatrix[i,1] <- min\n    crispMatrix[i,2] <- max\n  }\n  crispMatrix\n}\n\n\n\n\n\n#\n#\n# Compute the belonging degree of an entire example set for the specified\n#   fuzzy sets, this sets must be specified by means of their min, max \n#   and half value.\n#   If you want to get the belonging degree for a subset of variables. Then\n#   you must get only the values of the example corresponding to those variables\n#   before execute this function.\n#\n#\n.grado_pertenencia5 <- function(x, xmin, xmedio, xmax, n_matrices){\n  \n  x <- as.numeric(x)\n  \n  resultado <- numeric(length(x)) + 1\n  xminX <- numeric(length(x)) + xmin + .tolerance\n  xmedioX <- numeric(length(x)) + xmedio + .tolerance\n  xmaxX <- numeric(length(x)) + xmax + .tolerance\n  \n  \n  fuera_limites <- which( x <= xminX | x >= xmaxX )\n  menorXMedio <- which( x < xmedioX & x > xminX )\n  mayorXMedio <- which( x > xmedioX & x < xmaxX )\n  \n  resultado[fuera_limites] <- 0\n  resultado[menorXMedio] <- (( x[menorXMedio] - xminX[menorXMedio] ) * (1 / (xmedioX[menorXMedio] - xminX[menorXMedio] )))\n  resultado[mayorXMedio] <- (( xmaxX[mayorXMedio] - x[mayorXMedio] ) * (1 / (xmaxX[mayorXMedio] - xmedioX[mayorXMedio] )))\n  \n  resultado <- matrix(resultado, ncol = n_matrices, byrow = TRUE)\n  \n  resultado\n}\n\n\n\n\n#\n#\n# It is like grado_pertenencia5 but for crisp belonging and you must specify the min and max\n#   value for crisp sets\n#\n#\n\n.gradoPertenenciaCrisp2 <- function(x, xmin, xmax, DNF = FALSE){\n  \n  x <- as.numeric(x)\n  result <- numeric(length(x))\n  \n \n    resulta <- which((x > xmin + .tolerance) & x <= (xmax + .tolerance))\n    result[resulta] <- 1\n    result <- matrix(result, ncol = length(xmax), byrow = TRUE)\n    result\n \n    \n}\n\n\n\n\n\n#\n#\n#  Return the maximum fuzzy degree for all variables that participe in a DNF rule.\n#\n#\n.getMaxFuzzyForAVariable2 <- function(values, ejemplo_num){\n\n  resultado <- .grado_pertenencia5(x = as.vector(ejemplo_num), xmin = values[2,], xmedio = values[3,], xmax = values[4,], n_matrices = NCOL(values))\n \n  #Obtengo correctamente los grados de pertenencia, pero no consigo obtener el mÃ¡ximo de cada variable.  \n  a <- which(!duplicated(values[1,]))\n  long <- length(a)\n  rangos <- vector(mode = \"list\", length = long)\n  \n  for(i in seq_len(long)){\n    if(! is.na(a[i +1 ])){\n      rangos[[i]]  <- a[i]:(a[i + 1] - 1)  \n    } else {\n      rangos[[i]] <- a[i]:NCOL(resultado)\n    }\n  }\n  \n\nif(NCOL(resultado) > 1){\n  resultado <- t( apply(X = resultado, MARGIN = 1, FUN = function(x, rangos)  vapply(X = rangos, FUN = function(x, vector) max(vector[x]), FUN.VALUE = 1, x) , rangos) )\n  resultado <- apply(X = resultado, MARGIN = 1, FUN = min)\n} else {\n  resultado <- t( apply(X = resultado, MARGIN = 1, FUN = function(x, rangos)  vapply(X = rangos, FUN = function(x, vector) max(vector[x]), FUN.VALUE = 1, x) , rangos) )\n  \n}\n  resultado\n  \n}\n\n\n\n\n\n\n\n\n#\n#\n# The same but for crips set on DNF Rules\n#\n#\n.getMaxCrispForAVariable2 <- function(values, ejemplo_num){\n  resultado <- .gradoPertenenciaCrisp2(x = as.vector(ejemplo_num), xmin = values[2,], xmax = values[3,], DNF = TRUE)\n  #Obtengo correctamente los grados de pertenencia, pero no consigo obtener el mÃ¡ximo de cada variable.  \n  a <- which(!duplicated(values[1,]))\n  long <- length(a)\n  rangos <- vector(mode = \"list\", length = long)\n  \n  for(i in seq_len(long)){\n    if(! is.na(a[i +1 ])){\n      rangos[[i]]  <- a[i]:(a[i + 1] - 1)  \n    } else {\n      rangos[[i]] <- a[i]:NCOL(resultado)\n    }\n  }\n  \n  if(NCOL(resultado) > 1){\n    resultado <- t( apply(X = resultado, MARGIN = 1, FUN = function(x, rangos)  vapply(X = rangos, FUN = function(x, vector) max(vector[x]), FUN.VALUE = 1, x) , rangos) )\n    resultado <- apply(X = resultado, MARGIN = 1, FUN = min)\n  } else {\n    resultado <- t( apply(X = resultado, MARGIN = 1, FUN = function(x, rangos)  vapply(X = rangos, FUN = function(x, vector) max(vector[x]), FUN.VALUE = 1, x) , rangos) )\n    \n  }\n  resultado\n  \n}",
    "created" : 1434888253431.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "1315061168",
    "id" : "C3581C55",
    "lastKnownWriteTime" : 1434317990,
    "path" : "~/MEGA/MEGAsync/Universidad/Trabajo Fin de Grado/SDR/R/Difuso.R",
    "project_path" : "R/Difuso.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}