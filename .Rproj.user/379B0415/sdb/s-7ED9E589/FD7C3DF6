{
    "contents" : "#\n#\n#   THIS FILE CONTAINS SOME FUNCTIONS FOR DOING SOME STUFF INSIDE THE PACKAGE.\n#   THIS MEANS THAT THE FUNCTIONS USED HERE MUST NOT BE EXPORTED. (EXCEPT ONE)\n#\n#\n\n\n# Utils relative to obtain the fuzzy belonging degree\n\n#--------------------------------------------------------------------\n\n\n#\n#\n#   Gets the membership degree of all examples in the dataset over a single rule. (Use with lapply)\n#\n#     ONLY FOR CAN RULES\n# ejemplo es una matriz despues de usar .separar\n# rule_cat is the categorcal variables that participate in the rule\n# rule_num is the numerical variables that participate in the rule\n# catParticip and numParticip are logical vectors for tell the function which rules of each type participe in the rule\n# xmin, xmax, xmedio and xminCrisp and xmaxCrisp are the vectors with the fuzzy and crisp definition of the variables that participa in the rule\n# max_cat is a vector the maximum value for categorical values and max_num is the same but for numerical variables.\n\n.compara_CAN9 <- function(ejemplo, rule_cat, rule_num, catParticip, numParticip, xmin, xmedio, xmax, n_matrices, xminCrisp, xmaxCrisp, max_cat, max_num){\n  dispFuzzy <- numeric(NCOL(ejemplo)) + 1\n  dispCrisp <- integer(NCOL(ejemplo)) + 1L\n  \n  \n  \n  \n  #Computation of membership degree.\n  \n  #Categorical variables.\n  if(length(catParticip > 0)){\n    ej_cat <- as.integer( ejemplo[catParticip,] )\n    values <-  ceiling( ( which(ej_cat != rule_cat & ! (ej_cat == max_cat + 1 )) / (length(catParticip)) ) ) \n    #Examples no compatibles\n    dispFuzzy[values] <- 0L\n    dispCrisp[values] <- 0L\n  }\n  \n  \n  #Numerical Values \n  if(length(numParticip) > 0){\n    ej_num <- as.vector( ejemplo[numParticip, which(dispFuzzy > 0) ] )\n    #Fuzzy computation\n    pertenencia <- .grado_pertenencia5(x = ej_num, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices)\n    dispFuzzy[which(dispFuzzy > 0)] <- apply(X = pertenencia, MARGIN = 1, FUN = min)\n    \n    #Crisp Computation\n    pertenencia <- .gradoPertenenciaCrisp2(x = ej_num, xmin = xminCrisp, xmax = xmaxCrisp)\n    dispCrisp[which(dispCrisp > 0)] <- apply(X = pertenencia, MARGIN = 1, FUN = min)\n    \n  }\n  \n  \n  return(list( fuzzy = dispFuzzy, crisp = dispCrisp) )\n  \n}\n\n#\n#\n#\n# It works similar to compara_CAN9 but for DNF rules.\n#\n\n.comparaDNF4 <- function(ejemplo,  regla, regla_num, cat_particip, num_particip, max_regla_cat, max_regla_num, nLabels, fuzzySets, crispSet, valuesFuzzy, valuesCrisp){\n  ejemplo_cat <- as.vector( ejemplo[cat_particip, ] )\n  \n  dispFuzzy <- numeric(NCOL(ejemplo)) + 1\n  dispCrisp <- numeric(NCOL(ejemplo)) + 1\n  #No salen los mismo resultados a?n.\n  if(length(ejemplo_cat > 0)){  \n    valCat <- (max_regla_cat + 1) + ejemplo_cat\n    \n    #Categorical Values\n    fuera <- unique( ceiling(which(regla[valCat] == 0) / length(max_regla_cat)) )\n    \n    dispFuzzy[fuera] <- 0\n    dispCrisp[fuera] <- 0\n  }\n  \n  ejemplo_num <- ejemplo[num_particip, which(dispFuzzy > 0), drop = F] \n  \n  #Numerical Values\n  if(length(ejemplo_num) > 0){\n    \n    ejemplo_num <- ejemplo_num[valuesFuzzy[1,], ]\n    #Fuzzy Computation\n    dispFuzzy[which(dispFuzzy > 0)] <- .getMaxFuzzyForAVariable2(values = valuesFuzzy, ejemplo_num = ejemplo_num)\n    #Crisp Computation\n    dispCrisp[which(dispCrisp > 0)] <- .getMaxCrispForAVariable2(valuesCrisp, ejemplo_num)\n  }\n  \n  list(fuzzy = dispFuzzy, crisp = dispCrisp)\n  \n}\n\n\n#---------------------------------------------------------------------------\n#   RETURN THE VALUES FOR CALCULATE THE QUALITY MEASURES\n#\n# - Return:\n# -  [[1]] n(cond)  -> Ejemplos cubiertos por la regla\n# -  [[2]] n(Tv ? cond) -> ejemplos cubiertos que cumplen el consecuente\n# -  [[3]] FP -> Ejemplos que cumplen el antecedente pero no el consecuente (Falsos positivos)\n# -  [[4]] Ns -> Numero de ejemplos en el dataset\n# -  [[5]] n(TargetValue) -> numero de ejemplos que cumplen el consecuente\n# -  [[6]] numero de ejemplos cubiertos de cada clase\n# -  [[7]] numero de ejemplos de cada clase\n# -  [[8]] ejemplos correctamente cubiertos que son nuevos\n# -  [[9]] ejemplos de la clase objetivo que quedan por cubrir\n# -  [[10]] suma difusa de los ejemplos cubiertos\n# -  [[11]] suma difusa de los ejemplos correctamente cubiertos\n# -  [[12]] suma difusa de los ejemplos nuevos correctamente cubiertos\n# \n# ---------------------------------------------------------------\n\n\n.get_values6 <- function(gr_perts, nombre_clases, dataset, targetClass, examples_perClass, cov, Ns, N_vars , por_cubrir, marcar = FALSE, test = FALSE, difuso = FALSE, NMEEF = FALSE){\n  #Esto no es lo mejor, habr?a que buscar otra manera de utilizar la lista directamente\n  dataset <- matrix(unlist(dataset), nrow = length(dataset[[1]]), ncol = length(dataset))\n  \n  ejemplo_Cubiertos <- 0L\n  sumaFuzzyejCubiertos <- 0\n  ejemplosCorr_cubiertos <- 0L\n  sumaFuzzyejCorrectamenteCubiertos <- 0\n  ejemplosNuevos_Cubiertos <- 0L\n  sumaFuzzyEjNuevos <- 0\n  \n  #Datos sobre el dataset\n  \n  #   cov_examplesFuzzy <- replicate(length(nombre_clases), 0)  # Para el calculo de la significancia\n  #   names(cov_examplesFuzzy) <- nombre_clases\n  \n  cov_examplesCrisp <- integer(length(nombre_clases))  # Para el calculo de la significancia\n  names(cov_examplesCrisp) <- nombre_clases\n  \n  fuzzyPerts <- gr_perts[[1]]\n  crispPerts <- gr_perts[[2]]\n  \n  #Averiguamos los ejemplos cubiertos\n  coveredFuzzy <- which( fuzzyPerts > 0)\n  coveredCrisp <- which( crispPerts > 0)\n  \n  \n  #Ejemplos cubiertor por la regla de cada clase (Significancia)\n  #   tabla <- table( t( dataset[N_vars,coveredFuzzy]) )\n  #   cov_examplesFuzzy[ names( tabla )] <- tabla \n  tabla <- table( t( nombre_clases[ dataset[N_vars,coveredCrisp] + 1] ) )\n  cov_examplesCrisp[names( tabla )] <- tabla \n  \n  \n  #Ejemplos cubiertos por la regla\n  ejemplo_Cubiertos <- length(coveredCrisp)\n  sumaFuzzyejCubiertos <- sum(fuzzyPerts[coveredFuzzy])\n  \n  \n  #Ejemplos correctamente cubiertos\n  p <- nombre_clases[ dataset[N_vars,coveredFuzzy] + 1] == targetClass \n  p1 <- nombre_clases[ dataset[N_vars,coveredCrisp] + 1] == targetClass \n  \n  ejemplosCorr_cubiertos <- sum(p1)\n  sumaFuzzyejCorrectamenteCubiertos <- sum(fuzzyPerts[coveredFuzzy[p]])\n  \n  \n  #Ejemplos correctamente cubiertos que no estaban cubiertos anteriormente.  \n  i <- cov[coveredFuzzy] == FALSE\n  iC <- cov[coveredCrisp] == FALSE\n  obj_notCoveredFuzzy <- which(p & i)\n  obj_notCoveredCrisp <- which(p1 & iC)\n  ejemplosNuevos_Cubiertos <- length(obj_notCoveredCrisp) #NCOL( dataset[ , obj_notCovered])\n  sumaFuzzyEjNuevos <- sum(fuzzyPerts[coveredFuzzy[obj_notCoveredFuzzy]])\n  \n  #Marcar ejemplos nuevos cubiertos de la clase objetivo (Si es necesario)\n  if(marcar){\n    if(! difuso){\n      cov[coveredCrisp[obj_notCoveredCrisp]] <- TRUE #Si se usa SOPORTE CRISP\n    } else {\n      cov[coveredFuzzy[p & i]] <- TRUE # USAR CUANDO SE USA SOPORTE DIFUSO\n    }\n    \n    l <- list(ejemplo_Cubiertos, ejemplosCorr_cubiertos, NA, Ns, NROW(p[p]), cov_examplesCrisp, examples_perClass, ejemplosNuevos_Cubiertos, por_cubrir, sumaFuzzyejCubiertos, sumaFuzzyejCorrectamenteCubiertos, sumaFuzzyEjNuevos ) \n    conf <- .confianza(l)\n    if( ! test) return(list(cov, conf)) \n    return(list(cov, l) )\n  } else {\n    \n    #por_cubrir <- sum(obj_notCovered) \n    \n    #Return \n    if(!NMEEF){\n      return( list(ejemplo_Cubiertos, ejemplosCorr_cubiertos, NA, Ns, examples_perClass[[targetClass]], cov_examplesCrisp, examples_perClass, ejemplosNuevos_Cubiertos, por_cubrir, sumaFuzzyejCubiertos, sumaFuzzyejCorrectamenteCubiertos, sumaFuzzyEjNuevos ) )\n    }else{\n      cover <- (fuzzyPerts > 0 | crispPerts > 0) & nombre_clases[dataset[N_vars, ] + 1]== targetClass\n      return( list(ejemplo_Cubiertos, ejemplosCorr_cubiertos, NA, Ns, examples_perClass[[targetClass]], cov_examplesCrisp, examples_perClass, ejemplosNuevos_Cubiertos, por_cubrir, sumaFuzzyejCubiertos, sumaFuzzyejCorrectamenteCubiertos, sumaFuzzyEjNuevos, cover ) )\n    }\n  }\n  \n}\n\n\n\n.getVariableYValor <- function(value, max_valores){\n  variable <- which( (value / max_valores) <= 1)[1]  # Solo queremos el primer valor. \n  vInicioVariable <- 1\n  if(variable > 1){\n    vInicioVariable <- max_valores[variable - 1] + 1\n  }\n  valor <- value - vInicioVariable + 1\n  \n  return(c(variable, valor))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#---------------------------------------------------------------------\n# oTHER UTILS\n\n# \n# C.A.R. Hoare QuickSort Implementation\n# @param v The vector to be ordered\n# @param left First index of the subvector\n# @param right Last index of the subvector\n# @param index Index vector\n# @return A list with two fields, vector which is the ordered vector and indices which is the sorted indexes of the original vector \n# \nqsort <- function(v, left, right, index) {\n \n  \n  i = left\n  j = right\n  x = v[(left+right)/2]\n  while(i <= j){\n    while (v[i]<x && i<right)\n      i <- i + 1\n    while (x<v[j] && j>left)\n      j <- j - 1\n    if (i<=j) {\n      y = v[i];\n      v[i] = v[j];\n      v[j] = y;\n      aux = index[i];\n      index[i] = index[j];\n      index[j] = aux;\n      i <- i + 1\n      j <- j - 1\n    }\n}\n  if (left<j){\n   a <- qsort(v,left,j,index)\n    v[left:j] <- a$vector\n    index[left:j] <- a$indices\n  }\n  if (i<right){\n   b <- qsort(v,i,right,index);\n   v[i:right] <- b$vector\n   index[i:right] <- b$indices\n  }\n \n\n  \n  list(vector = v[left:right], indices = index[left:right])\n}\n\n\n\n\n#' Modifiy the number of Fuzzy Labels of the dataset.\n#' \n#' This function change the number of fuzzy labels defined in the current dataset.\n#' \n#' @details The fuzzy definitions used in the \\code{keel} class are triangular.\n#'     Because you can only specify the number of fuzzy definitions. All those definitions\n#'     has the same width.\n#' \n#' @param dataset The dataset to modify their fuzzy labels definitions\n#' @param nLabels The new number of fuzzy labels.\n#' \n#' @return  This function returns the same dataset with their fuzzy definitions modified.\n#'\nmodifyFuzzyCrispIntervals <- function(dataset, nLabels){\n \n    dataset[[\"fuzzySets\"]] <- .create_fuzzyIntervals(min = dataset$min, max = dataset$max, num_sets = nLabels, types = dataset$atributeTypes)\n    dataset[[\"crispSets\"]] <- .createCrispIntervals(fuzzyIntervals = dataset[[\"fuzzySets\"]])\n  \n    dataset\n}\n\n\n\n\n\n\n\n\n#'\n#' Change the targetVariable of a KEEL Dataset\n#' \n#' Change the actual target variable for another one if it is categorical.\n#' \n#' @param dataset The KEEL dataset class\n#' @param posVariable The position of the variable to set as target Variable.\n#' @return The dataset with te variables changed\n#' \nchangeTargetVariable <- function(dataset, posVariable){\n  if(class(dataset) != \"keel\") stop(\"The provided dataset is not a keel class\")\n  #if(posVariable >= dataset$nVars + 1) stop(\"posVariable is the same of the actual variable or is out of range\")\n  if(dataset[[3]][posVariable] != \"c\") stop(\"No categorical variable selected.\")\n  if(posVariable <= dataset$nVars){\n  #Swap variables.\n  dataset$data <- lapply(X = dataset$data , FUN = function(x, posVariable){ \n                       aux <- x[posVariable]; \n                       x[posVariable] <- x[length(x)]; \n                       x[length(x)] <- aux; \n                       x }, \n                       posVariable)\n  \n  #Swap Attribute Names\n  aux <- dataset[[2]][posVariable]\n  dataset[[2]][posVariable] <- dataset[[2]][length(dataset[[2]])]\n  dataset[[2]][length(dataset[[2]])] <- aux\n  \n  #swap conjuntos\n  dataset[[\"conjuntos\"]][posVariable] <- dataset[[\"max\"]][dataset[[\"nVars\"]] + 1]\n  \n  #Swap Min\n  aux <- dataset[[4]][posVariable]\n  dataset[[4]][posVariable] <- dataset[[4]][length(dataset[[4]])]\n  dataset[[4]][length(dataset[[4]])] <- aux\n  \n  #Swap Max\n  aux <- dataset[[5]][posVariable]\n  dataset[[5]][posVariable] <- dataset[[5]][length(dataset[[5]])]\n  dataset[[5]][length(dataset[[5]])] <- aux\n  \n  #Change class_names Values\n  dataset[[\"class_names\"]] <- dataset[[\"categoricalValues\"]][[posVariable]]\n  \n  #Swap categorical Values\n  aux <- dataset[[\"categoricalValues\"]][[posVariable]]\n  dataset[[\"categoricalValues\"]][[posVariable]] <- dataset[[\"categoricalValues\"]][[length(dataset[[\"categoricalValues\"]])]]\n  dataset[[\"categoricalValues\"]][[length(dataset[[\"categoricalValues\"]])]] <- aux\n  \n  #Calculate new value for examplesPerClass\n  clValues <- unlist(lapply(dataset$data, '[', dataset$nVars + 1))\n  examplesPerClass <- lapply(X = seq_len(length(dataset$class_names)) - 1, FUN = function(x, data) sum(data == x), clValues)\n  names(examplesPerClass) <- dataset$class_names\n  dataset$examplesPerClass <- examplesPerClass\n  \n  \n  }\n  \n  dataset\n}\n\n\n\n\n\n\n\n#\n#\n# Gets the variables that participate in a rule\n#\n#\n.getParticipantes <- function(regla, max_regla, DNFRules){\n  if(!DNFRules){\n    participantes <- as.logical( (regla < max_regla) ) #Cuidado que ?sto puede que que no est? bien. No valor de la regla no es comparable con el ejemplo\n  }else{\n    \n    participantes <- logical(length(max_regla) - 1)\n    for(i in 2:length(max_regla)){\n      ruleValues <- regla[(max_regla[i - 1] + 1):max_regla[i]]\n      participantes[i-1] <- !(all(ruleValues == 1) | all(ruleValues == 0))\n    }\n  }\n  \n  participantes\n  \n}\n\n\n\n\n\n#\n# Returns de dataset without the last (class) column\n#\n.separar <- function(dataset){\n  \n  lapply(dataset$data, FUN = function(x) x[-length(x)])\n  \n}\n\n\n\n\n\n\n#\n# returns de original dataes\n#\n.unir <- function(dataNoClass , classes){\n  lapply(X = 1:length(dataNoClass), FUN = function(num, x,y) append(x[[num]],y[[num]]), dataNoClass, clases)\n  \n}\n\n\n\n\n\n\n\n\n\n#\n# Returns a matrix for select the variables that participate in a DNF rule for calculating their belonging degree\n#\n.getMatrixSelector <- function(regla_num, valor){\n  \n  values <- unlist(lapply(X = seq_len(length(regla_num)), \n                          FUN = function(x, regla, valor){\n                            \n                            a <- which(regla[[x]] > 0)\n                            valores <- unlist(lapply(X = a, \n                                                     FUN = function(y, valor, mat){\n                                                       c(y, valor, mat)\n                                                     }, valor, x) )\n                            valores\n                          }, regla_num, valor))\n  \n  \n  matrix(data = values, nrow = length(values) / 3, ncol = 3, byrow = TRUE)\n  \n}\n\n\n\n\n\n\n\n#\n#\n# Obtain the fuzzy values of a DNF Rules\n#\n#\n.getFuzzyValues <- function(regla_num, fuzzy,  crisp = FALSE){\n  a <- .getMatrixSelector(regla_num = regla_num, valor = 1)\n  variables <- a[,3]\n  \n  if(! crisp){\n    xmin <- fuzzy[a]\n    a[,2] <- 2\n    xmedio <- fuzzy[a]\n    a[,2] <- 3\n    xmax <- fuzzy[a]\n    \n    rbind(variables, xmin, xmedio, xmax)\n    \n  } else {\n    xmin <- fuzzy[a]\n    a[,2] <- 2\n    xmax <- fuzzy[a]\n    \n    rbind(variables, xmin, xmax)\n  }\n  \n}\n\n\n\n\n\n\n\n\nnormalizeDNFRule <- function(regla, max){\n  if(!anyNA(regla)){\n    for(i in seq_len(length(max) - 1)){ \n      if(all(regla[(max[i] + 1):max[i+1]] == 1)){\n        regla[(max[i] + 1):max[i+1]] <- 0\n      }\n    }\n    \n    regla\n  } else{\n    regla\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#' Launch a web interface for use the algorithms easily\n#' @description This functions launch a Shiny app for using the algorithms\n#'     easily\n#' @export\n SDR_GUI <- function(){\n   shiny::runApp(appDir = system.file(\"shiny\", package=\"SDR\"), launch.browser = TRUE)\n   \n   invisible()\n }\n\n\n",
    "created" : 1434888270170.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "1018069664",
    "id" : "FD7C3DF6",
    "lastKnownWriteTime" : 1434896810,
    "path" : "~/MEGA/MEGAsync/Universidad/Trabajo Fin de Grado/SDR/R/Utils.R",
    "project_path" : "R/Utils.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}