{
    "contents" : "#'\n#' Reads a KEEL format file\n#' \n#' This function reads a KEEL dataset file and store the information\n#'   in a keel class. This function also create triangular fuzzy sets definitions\n#'   for execute in SDIGA, MESDIF or NMEEF-SD algorithms\n#'   \n#' @param file The path of the file in KEEL format\n#' @param nLabels The number of fuzzy labels to create on numerical variables.\n#' \n#' @author Ángel M. García-Vico <amgv0009@@red.ujaen.es>\n#' @details The KEEL format file has a fixed format, if the file hasn´t got that format, it launch an error\n#' @seealso KEEL Software Tool: \\url{http://www.keel.es}\n#'\nread.keel <- function(file, nLabels = 3){\n  \n  require(parallel)\n  \n  data <- .readFile(file)\n  value <- which(data == \"@data\") - 1\n  if(length(value) == 0) stop(\"No @data field found, this is not a KEEL format dataset. Aborting load...\")\n  properties <- data[1:value]\n  data <- data[(value + 2):length(data)]\n  \n  # PreparaciÃ³n de las propiedades de los datos\n  \n  properties <- lapply(X = properties, FUN = .preprocessHeader)\n  \n  num_atribs <- length(properties) - 3 # Obviamos valor de @relation, @inputs y @outputs\n  atribs_names <- character(num_atribs)\n  atribs_types <- character(num_atribs)\n  atribs_min <- numeric(num_atribs)\n  atribs_max <- numeric(num_atribs)\n  categorical_values <- vector(mode = \"list\", length = num_atribs)\n  \n  #Procesamos @relation\n  relation_pos <- grep(pattern = \"@relation\", x = properties, fixed = TRUE)\n  if(length(relation_pos) == 0) stop(\"No @relation field provided, this is not a KEEL format dataset. Aborting load... \")\n  relacion <- properties[[relation_pos]][2]\n  \n  #Procesamos el resto de atributos\n  atributes <- properties[- c(relation_pos, grep(pattern = \"@inputs|@output\", x = properties))]\n  aux <- vector(mode = \"list\", length = 5)\n  \n  if(length(atributes) == 0) stop(\"No @input or @output fields found, this is not a KEEL format dataset. Aborting load...\")\n  \n  for(i in seq_len(length(atributes))){\n    aux <- .processLine(line = atributes[[i]])\n    \n    atribs_names[i] <- aux[[1]]\n    atribs_types[i] <- aux[[2]]\n    atribs_min[i] <- aux[[3]]\n    atribs_max[i] <- aux[[4]]\n    categorical_values[[i]] <- aux[[5]]\n  }\n \n  \n  #PreparaciÃ³n de los datos\n  if(Sys.info()[1] != \"Windows\")\n    data <- mclapply(X = data, FUN = .processData, categorical_values, atribs_types, mc.cores = detectCores() - 1)\n  else #In windows mclapply doesn?t work\n    data <- mclapply(X = data, FUN = .processData, categorical_values, atribs_types, mc.cores = 1)\n  \n  \n  #PreparaciÃ³n del resto de atributos del dataset\n  \n  covered <- logical(length = length(data))                     \n  fuzzySets <- .create_fuzzyIntervals(min = atribs_min, max = atribs_max, num_sets = nLabels, types = atribs_types)\n  crispSets <- .createCrispIntervals(fuzzyIntervals = fuzzySets)\n  classNames <- categorical_values[[length(categorical_values)]]\n  clValues <- unlist(lapply(data, '[', length(atributes)))\n  examplesPerClass <- lapply(X = seq_len(length(classNames)) - 1, FUN = function(x, data) sum(data == x), clValues)\n  names(examplesPerClass) <- classNames\n  \n  conjuntos <- .dameConjuntos(data_types = atribs_types, max = atribs_max, n_labels = nLabels)\n  \n  lostData <- FALSE #Quitar esto\n  \n  lista <- list(relation = relacion, \n                atributeNames = atribs_names, \n                atributeTypes = atribs_types, \n                min = atribs_min, \n                max = atribs_max,\n                nVars = length(atribs_min) - 1,\n                data = data, \n                class_names = classNames, \n                examplesPerClass = examplesPerClass, \n                lostData = lostData, \n                covered = covered, \n                fuzzySets = fuzzySets,\n                crispSets = crispSets,\n                conjuntos = conjuntos,\n                categoricalValues = categorical_values,\n                Ns = length(data))\n  \n  \n  class(lista) <- \"keel\"\n  lista\n  \n}\n\n\n\n\n\n\n.read.parametersFile2 <- function(file){\n  \n  data <- .readFile(file)\n  data <- gsub(pattern = \"\\r\", replacement = \"\", x = data, fixed = TRUE) #Eliminar caracteres extraÃ±os.\n  \n  data <- strsplit(x = data, split = \" = \" )\n  \n  \n  #Mirar posicion de los parametros\n  alg <- grep(pattern = \"algorithm\", x = data, fixed = TRUE)\n  iData <- grep(pattern = \"inputData\", x = data, fixed = TRUE)\n  oData <- grep(pattern = \"outputData\", x = data, fixed = TRUE)\n  seed <- grep(pattern = \"seed\", x = data, fixed = TRUE)\n  labels <- grep(pattern = \"nLabels\", x = data, fixed = TRUE)\n  evals <- grep(pattern = \"nEval\", x = data, fixed = TRUE)\n  len <- grep(pattern = \"popLength\", x = data, fixed = TRUE)\n  cross <- grep(pattern = \"crossProb\", x = data, fixed = TRUE)\n  mut <- grep(pattern = \"mutProb\", x = data, fixed = TRUE)\n  rep <- grep(pattern = \"RulesRep\", x = data, fixed = TRUE)\n  tC <- grep(pattern = \"targetClass\", x = data, fixed = TRUE)\n  #MESDIF Parametros\n  elit <- grep(pattern = \"eliteLength\", x = data, fixed = TRUE)\n  ech <- grep(pattern = \"echo\", x = data, fixed = TRUE)\n  #SDIGA Parametros\n  ob1 <- grep(pattern = \"Obj1\", x = data, fixed = TRUE)\n  ob2 <- grep(pattern = \"Obj2\", x = data, fixed = TRUE)\n  ob3 <- grep(pattern = \"Obj3\", x = data, fixed = TRUE)\n  ob4 <- grep(pattern = \"Obj4\", x = data, fixed = TRUE)\n  w1 <- grep(pattern = \"w1\", x = data, fixed = TRUE)\n  w2 <- grep(pattern = \"w2\", x = data, fixed = TRUE)\n  w3 <- grep(pattern = \"w3\", x = data, fixed = TRUE)\n  search <- grep(pattern = \"lSearch\", x = data, fixed = TRUE)\n  miConf <- grep(pattern = \"minConf\", x = data, fixed = TRUE)\n  #NMEEF-SD Parametros\n  div <- grep(pattern = \"diversity\", x = data, fixed = TRUE)\n  rInit <- grep(pattern = \"ReInitCob\", x = data, fixed = TRUE)\n  pCob <- grep(pattern = \"porcCob\", x = data, fixed = TRUE)\n  dom <- grep(pattern = \"StrictDominance\", x = data, fixed = TRUE)\n  miCf <- grep(pattern = \"minCnf\", x = data, fixed = TRUE)\n  #--------------------------------------------------------\n  \n  if(length(alg) == 0) stop(\"Param file error: Algorithm not especified. \")\n  if(length(iData) == 0) stop(\"Param file error: inputData not especified. \")\n  if(length(oData) == 0) stop(\"Param file error: outputData not especified. \")\n  if(length(seed) == 0) stop(\"Param file error: Seed not especified. \")\n  if(length(labels) == 0) stop(\"Param file error: nLabels not especified. \")\n  if(length(evals) == 0) stop(\"Param file error: nEval not especified. \")\n  if(length(len) == 0) stop(\"Param file error: popLength not especified. \")\n  if(length(cross) == 0) stop(\"Param file error: crossProb not especified. \")\n  if(length(mut) == 0) stop(\"Param file error: mutProb not especified. \")\n  if(length(rep) == 0) stop(\"Param file error: RulesRep not especified. \")\n  if(length(tC) == 0) stop(\"Param file error: targetClass not especified. \")\n  \n  algoritmo <- data[[alg]][2]\n  if(! any(algoritmo == c(\"SDIGA\", \"MESDIF\", \"NMEEFSD\"))) stop(\"Param file error: Algorithm must be SDIGA, MESDIF or NMEEFSD (in upper case)\")\n  #General parameters\n  #datos de entrada\n  input_data <- character(2) # Dos inputs, training y tes\n  \n  input_string <- gsub(pattern = '\\\"', replacement = \"\", x = data[[iData]][2], fixed = TRUE)\n  input_data <- strsplit(x = input_string, split = \" \", fixed = TRUE)[[1]]\n  \n  output_data <- character(4) # Reglas, tra_qua, tra_seg y tst_quac\n  \n  input_string <- gsub(pattern = '\\\"', replacement = \"\", x = data[[oData]][2], fixed = TRUE)\n  output_data <- strsplit(x = input_string, split = \" \", fixed = TRUE)[[1]]\n  \n  semilla <- as.integer( data[[seed]][2] )\n  n_intervals <- as.integer ( data[[labels]][2] )\n  n_evals <- as.integer ( data[[evals]][2] )\n  popLenght <- as.integer( data[[len]][2] )\n  crossProb <- as.double( data[[cross]][2] )\n  prob_mutacion <- as.double( data[[mut]][2] )\n  rule_type <- data[[rep]][2]\n  target <- data[[tC]][2]\n  \n  #SDIGA own parameters\n  if(algoritmo == \"SDIGA\"){\n    \n    if(length(miConf) == 0) stop(\"Param file error: minConf not specified.\")\n    if(length(ob1) == 0) stop(\"Param file error: Obj1 not specified.\")\n    if(length(ob2) == 0) stop(\"Param file error: Obj2 not specified.\")\n    if(length(ob3) == 0) stop(\"Param file error: Obj3 not specified (If you donÂ´t want specify, you must write null).\")\n    if(length(w1) == 0) stop(\"Param file error: w1 not specified.\")\n    if(length(w2) == 0) stop(\"Param file error: w2 not specified.\")\n    if(length(w3) == 0) stop(\"Param file error: w3 not specified.\")\n    if(length(search) == 0) stop(\"Param file error: localSearch not specified.\")\n    \n    minimun_confidence <- as.double( data[[miConf]][2] )\n    Obj1 <- data[[ob1]][2]\n    Obj2 <- data[[ob2]][2]\n    Obj3 <- data[[ob3]][2]\n    peso1 <- as.double( data[[w1]][2] )\n    peso2 <- as.double( data[[w2]][2] )\n    peso3 <- as.double( data[[w3]][2] )\n    local_search <- data[[search]][2]\n    \n    lista <- list(algorithm = algoritmo, inputData = input_data, outputData = output_data, seed = semilla, nLabels = n_intervals, nEval = n_evals, popLength = popLenght, crossProb = crossProb, mutProb = prob_mutacion, minConf = minimun_confidence, RulesRep = rule_type, Obj1 = Obj1, Obj2 = Obj2, Obj3 = Obj3, w1 = peso1, w2= peso2, w3 = peso3, lSearch = local_search, targetClass = target)\n    \n  }\n  \n  #MESDIF own parameters\n  if(algoritmo == \"MESDIF\"){\n    \n    if(length(elit) == 0) stop(\"Param file error: elitePop not specified.\")\n    if(length(ech) == 0) stop(\"Param file error: echo not specified.\")\n    if(length(ob1) == 0) stop(\"Param file error: Obj1 not specified.\")\n    if(length(ob2) == 0) stop(\"Param file error: Obj2 not specified.\")\n    if(length(ob3) == 0) stop(\"Param file error: Obj3 not specified (If you donÂ´t want specify, you must write null).\")\n    if(length(ob4) == 0) stop(\"Param file error: Obj3 not specified (If you donÂ´t want specify, you must write null).\")\n    \n    \n    elite <- as.numeric(data[[elit]][2])\n    echo <- data[[ech]][2]\n    Obj1 <- data[[ob1]][2]\n    Obj2 <- data[[ob2]][2]\n    Obj3 <- data[[ob3]][2]\n    Obj4 <- data[[ob4]][2]\n    \n    \n    lista <- list(algorithm = algoritmo, inputData = input_data, outputData = output_data, seed = semilla, nLabels = n_intervals, nEval = n_evals, popLength = popLenght, crossProb = crossProb, mutProb = prob_mutacion, RulesRep = rule_type, targetClass = target, elitePop = elite, echo = echo, Obj1 = Obj1, Obj2 = Obj2, Obj3 = Obj3, Obj4 = Obj4)\n    \n  }\n  \n  #NMEEF-SD own parameters\n if(algoritmo == \"NMEEFSD\"){\n   #if(length(div) == 0) stop(\"Param file error: diversity not specified.\")\n   if(length(rInit) == 0) stop(\"Param file error: ReInitCob not specified.\")\n   if(length(pCob) == 0) stop(\"Param file error: porcCob not specified.\")\n   if(length(dom) == 0) stop(\"Param file error: StrictDominance not specified.\")\n   if(length(miCf) == 0) stop(\"Param file error: minCnf not specified.\")\n   \n   diversity <- data[[div]][2]\n   reInit <- data[[rInit]][2]\n   porcCob <- data[[pCob]][2]\n   dominance <- data[[dom]][2]\n   minConf <- data[[miCf]][2]\n   Obj1 <- data[[ob1]][2]\n   Obj2 <- data[[ob2]][2]\n   Obj3 <- data[[ob3]][2]\n   \n   lista <- list(algorithm = algoritmo, inputData = input_data, outputData = output_data, seed = semilla, nLabels = n_intervals, nEval = n_evals, popLength = popLenght, crossProb = crossProb, mutProb = prob_mutacion, RulesRep = rule_type, targetClass = target, StrictDominance = dominance, diversity = diversity, porcCob = porcCob, reInitPob = reInit, minConf = minConf, Obj1 = Obj1, Obj2 = Obj2, Obj3 = Obj3)\n   \n }\n  \n  lista\n  \n}\n\n#---------------------------------------------------------------------------\n# Shows information about parameters \n# --------------------------------------------------------------------------\n\n.show_parameters <- function(params, train, test){\n  \n  #Show parameters in the console\n  algo <- params$algorithm\n  cat(\"--------------------------------\", file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Algorithm:\", algo, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Relation:\", train$relation, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Training file:\", params$inputData[1], file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Test file:\", params$inputData[2], file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Rules Representation: \", if(tolower(params$RulesRep) == \"can\") \"CAN\" else \"DNF\", file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Number of evaluations:\", params$nEval, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Number of fuzzy partitions:\", params$nLabels, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Population Length:\", params$popLength, file = \"\", sep = \" \", fill = TRUE)\n  if(algo == \"MESDIF\") cat(\"Elite Population Length:\", params$elitePop, file = \"\", sep = \" \", fill = TRUE)\n  if(algo != \"SDIGA\") cat(\"Crossover Probability:\", params$crossProb, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Mutation Probability:\", params$mutProb, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Obj1:\", params$Obj1, \"  (Weigth:\", params$w1,\")\", file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Obj2:\", params$Obj2, \"  (Weigth:\", params$w2,\")\", file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Obj3:\", params$Obj3, \"  (Weigth:\", params$w3,\")\", file = \"\", sep = \" \", fill = TRUE)\n  if(algo == \"MESDIF\") cat(\"Obj4:\", params$Obj4, file = \"\", sep = \" \", fill = TRUE)\n  if(algo == \"SDIGA\") cat(\"Local Search optimization?:\", params$lSearch, file = \"\", sep = \" \", fill = TRUE)\n  if(algo == \"NMEEFSD\"){\n    cat(\"Reinitilization based on coverage?: \", params$reInitPob, file = \"\", fill = TRUE)\n    cat(\"Max Pct of variables in reinitialization: \", as.numeric(params$porcCob) * 100, \"%\", file = \"\", fill = TRUE)\n    cat(\"Compare individuals using strict dominance? \", params$StrictDominance, file = \"\", fill = TRUE)\n  }\n  cat(\"Number of examples in training:\", train$Ns, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"Number of examples in test:\", test$Ns, file = \"\", sep = \" \", fill = TRUE)\n  cat(\"--------------------------------\", file = \"\", sep = \" \", fill = TRUE)\n  \n  \n  #Save parameters in the outputFile\n  algo <- params$algorithm\n  cat(\"--------------------------------\" , \"\\n\",\n   \"Algorithm:\",algo ,\"\\n\",\n   \"Relation:\", train$relation, \"\\n\",\n   \"Training file:\", params$inputData[1], \"\\n\",\n   \"Test file:\", params$inputData[2], \"\\n\",\n   \"Rules Representation: \", if(tolower(params$RulesRep) == \"can\") \"CAN\" else \"DNF\", \"\\n\",\n   \"Number of evaluations:\", params$nEval,\"\\n\",\n   \"Number of fuzzy partitions:\", params$nLabels, \"\\n\",\n   \"Population Length:\", params$popLength, \"\\n\",\n  if(algo == \"MESDIF\") paste(\"Elite Population Length:\", params$elitePop, \"\\n\"),\n  if(algo != \"SDIGA\") paste(\"Crossover Probability:\", params$crossProb, \"\\n\"),\n   \"Mutation Probability:\", params$mutProb, \"\\n\",\n   paste( \"Obj1:\", params$Obj1, \"  (Weigth:\", params$w1,\")\", \"\\n\"),\n   paste( \"Obj2:\", params$Obj2, \"  (Weigth:\", params$w2,\")\", \"\\n\"),\n   paste( \"Obj3:\", params$Obj3, \"  (Weigth:\", params$w3,\")\", \"\\n\"),\n  if(algo == \"MESDIF\") paste(\"Obj4:\", params$Obj4, \"\\n\"),\n  if(algo == \"SDIGA\") paste(\"Local Search optimization?:\", params$lSearch, \"\\n\"),\n  if(algo == \"NMEEFSD\"){\n    paste(\"Reinitilization based on coverage?: \", params$reInitPob, \"\\n\",\n    \"Max Pct of variables in reinitialization: \", as.numeric(params$porcCob) * 100, \"%\", \"\\n\",\n    \"Compare individuals using strict dominance? \", params$StrictDominance, \"\\n\")\n  },\n  \"Number of examples in training:\", train$Ns, \"\\n\",\n   \"Number of examples in test:\", test$Ns, \"\\n\",\n   \"--------------------------------\", file = params$outputData[1], sep = \" \")\n  \n}\n\n\n#'\n#'@name .dameConjuntos\n#'@description Devuelve el numero de conjuntos (difusos o no) en funci?n del tipo de par?metro. \n#'   Si son datos continuos da como resultado el numero de conjuntos difusos. \n#'   En caso de ser categoricos devolvera el numero de categorias\n#'\n\n\n\n.dameConjuntos <- function(data_types, max, n_labels) {\n  data_types <- data_types[-length(data_types)]\n  \n  salida <- numeric(length(data_types))\n  cat <- which(data_types == 'c')\n  if(length(cat > 0)){ #Si no hay datos categoricos, todos tienen el valor de n_labels\n  salida[cat] <- max[cat]\n  salida[-cat] <- n_labels\n  } else {\n    salida[] <- n_labels\n  }\n  salida\n  \n}\n\n\n\n#\n#\n# This function prints a rule for show to the user\n#\n#\n.print.rule <- function(rule, max, names, consecuente, types, fuzzySets, categoricalValues, DNFRules = FALSE, rulesFile = \"rulesFile.txt\"){\n  if(! DNFRules){\n    participantes <- which(rule < max)\n    nombre <- names[participantes]\n    valores <- rule[participantes]\n    types <- types[participantes]\n    fuzzy <- fuzzySets[,,participantes, drop = F]\n    cate <- categoricalValues[participantes]\n    \n    val <- replicate(n = length(participantes), expr = NA)\n    \n    \n    for(p in seq_len(length(participantes))){\n      if(types[p] == 'c'){\n        val[p] <- cate[[p]][valores[p] + 1]\n      } else {\n        val[p] <- paste(\"Label\", valores[p], \"(\", fuzzy[valores[p]+1,1,p], \",\", fuzzy[valores[p]+1,2,p], \",\",fuzzy[valores[p]+1,3,p], \")\", sep = \" \")\n      }\n    }\n    nombre <- paste(\"Variable\", nombre, sep = \" \")\n    lineas <- paste(nombre, val, sep = \" = \")\n    lineas <- paste(lineas, collapse = \"\\n\")\n    cat(lineas, \"\\n\",\"THEN\", consecuente, file = \"\", sep = \" \", fill = TRUE)\n    \n    #Save in file\n    cat(lineas, \"\\n\",\"THEN\", consecuente, file = rulesFile, sep = \" \", fill = TRUE, append = TRUE)\n    \n  } else { #Print DNF rule\n    \n    max <- Reduce(f = '+', x = max, accumulate = TRUE)\n  \n    anterior <- 1\n    pos <- 1\n    lineas <- \"\"\n    for(i in max ){\n      variable <- rule[anterior:i]\n       noParticipa <- all( variable == 1) | all(variable == 0)\n       if(! noParticipa){\n         valores <- which(variable == 1)\n         nombreVariable <- names[pos]\n         if(types[pos] == 'c'){\n           nombresValores <- categoricalValues[[pos]][valores]\n           nombresValores <- paste(nombresValores, sep = \" \", collapse = \" OR \")\n         } else {\n           nombresValores <- paste(\"Label\", valores - 1, \"(\", fuzzySets[valores,1,pos], \",\", fuzzySets[valores,2,pos], \",\",fuzzySets[valores,3,pos], \")\", sep = \" \", collapse = \" OR \")\n         }\n         lineas <- paste(lineas, \"Variable\", nombreVariable, nombresValores, \"\\n\", sep = \" \")\n         \n         \n       }\n       pos <- pos + 1\n       anterior <- i + 1\n    }\n    cat(lineas, \"\\n\",\"THEN\", consecuente, file = \"\", sep = \" \", fill = TRUE)\n    #Save in file\n    cat(lineas, \"\\n\",\"THEN\", consecuente, file = rulesFile, sep = \" \", fill = TRUE, append = TRUE)\n    \n  }\n}\n\n\n\n\n#\n#\n# Function to get the name of the objective value in the parameters file\n# and return the corresponding functions.\n#\n#\n.parseObjetives <- function(parametros, algorithm, DNF){\n  Objetivos <- list(NA,NA,NA,NA) # prealocamos memoria\n  \n  if(algorithm == \"SDIGA\"){\n    \n  \n  if(parametros$Obj1 == \"CSUP\"){ #NO PONEMOS COMPLETITUD !! \n    Objetivos[[1]] <- .LocalSupport\n    Objetivos[[4]] <- FALSE\n  } else{\n    Objetivos[[1]] <- .FLocalSupport\n    Objetivos[[4]] <- TRUE\n  }\n  \n  if(parametros$Obj2 == \"CCNF\"){ \n    Objetivos[[2]] <- .confianza\n  } else{\n    Objetivos[[2]] <- .confianzaDifusa\n  }\n  \n  if(parametros$Obj3 == \"UNUS\"){\n    Objetivos[[3]] <- .norm_unusualness\n  } else if(parametros$Obj3 == \"SIGN\"){\n    Objetivos[[3]] <- .significance\n  } else if(parametros$Obj3 == \"COVE\"){\n    Objetivos[[3]] <- .coverage\n  }\n  \n  } else {\n    valores <- c(parametros$Obj1, parametros$Obj2, parametros$Obj3)\n    \n    for(i in seq_len(3)){\n      if(valores[i] == \"CSUP\")\n        Objetivos[[i]] <- .Csupport\n      if(valores[i] == \"FSUP\")\n        Objetivos[[i]] <- .Fsupport\n      if(valores[i] == \"CCNF\")\n        Objetivos[[i]] <- .confianza\n      if(valores[i] == \"FCNF\")\n        Objetivos[[i]] <- .confianzaDifusa\n      if(valores[i] == \"UNUS\")\n        Objetivos[[i]] <- .norm_unusualness\n      if(valores[i] == \"SIGN\")\n        Objetivos[[i]] <- .significance\n      if(valores[i] == \"COVE\")\n        Objetivos[[i]] <- .coverage\n      \n    }\n    \n    Objetivos[[4]] <- DNF\n  }\n  return(Objetivos)\n}\n\n\n\n\n#\n#\n# Preprocessing of a single line in the header of the KEEL file.\n#\n#\n.preprocessHeader <- function(line){\n  line <- sub(pattern = \" {\", replacement = \" \", x = line, fixed = TRUE) \n  line <- sub(pattern = \"{\", replacement = \" \", x = line, fixed = TRUE) \n  line <- sub(pattern = \"}\", replacement = \"\", x = line, fixed = TRUE) \n  line <- sub(pattern = \" [\", replacement = \" \", x = line, fixed = TRUE) \n  line <- sub(pattern = \"[\", replacement = \" \", x = line, fixed = TRUE) \n  line <- sub(pattern = \"]\", replacement = \"\", x = line, fixed = TRUE) \n  line <- gsub(pattern = \", \", replacement = \" \", x = line, fixed = TRUE) \n  line <- gsub(pattern = \"[ *] \", replacement = \" \", x = line) \n  #Return\n  unlist( strsplit( gsub(pattern = \",\", replacement = \" \", x = line, fixed = TRUE) , split = \" \") )\n}\n\n\n\n\n#\n#\n# This function parses all examples in the @data field\n#\n#\n.processData <- function(data, categoricalValues, types){\n  line <- data\n  line <- gsub(pattern = \", \", replacement = \" \", x = line, fixed = TRUE) \n  line <- gsub(pattern = \",\", replacement = \" \", x = line, fixed = TRUE) \n  line <- strsplit(x = line, split = \" \",fixed = TRUE)[[1]]\n  \n cat <- which(types == 'c')\n lc <- line[cat]\n cv <- categoricalValues[cat]\n for(i in seq_len(length(lc))){\n   pos <- which(cv[[i]] == lc[i])\n   if(length(pos) > 0){\n   lc[i] <- pos - 1\n   } else{\n     #LostData\n     lc[i] <- length(cv[[i]]) + 1\n   }\n }\n line[cat] <- lc\n \n  #Return\n  as.numeric(line)\n}\n\n\n#' Devuelve una lista con los siguientes valores:\n#' - Nombre del atributo\n#' - tipo \n#' - minimo\n#' - maximo\n#' - valores categoricos si los tuviera, NA en caso contrario\n\n.processLine <- function(line){\n  returnList <- vector(mode = \"list\", length = 5)\n  returnList[[1]] <- line[2] # Attribute name\n  \n if(line[3] != \"real\" & line[3] != \"integer\"){ # Dato categÃ³rico\n    returnList[[2]] <- 'c' # Attribute type\n    returnList[[3]] <- 0   #Minimum\n    returnList[[4]] <- length(line) - 2 #Maximun number of categorical values\n    returnList[[5]] <- line[3:length(line)]\n \n    } else { #Numerical Values\n   returnList[[2]] <- 'e'\n   returnList[[3]] <- as.numeric(line[4])\n   returnList[[4]] <- as.numeric(line[5])\n   returnList[[5]] <- NA\n }\n \n returnList\n}\n\n\n\n\n#\n#\n# This function reads an entire file in a block and the it is splitted by the \\n character.\n# It´s a 50 % faster than using scan\n#\n#\n.readFile <- function(file){\n  contents <- readChar(file, file.info(file)$size)\n  \n  #Return\n  strsplit(x = contents, split = \"\\n\", fixed = TRUE)[[1]]\n}",
    "created" : 1434888254888.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "415358049",
    "id" : "8A7D0E1E",
    "lastKnownWriteTime" : 1434903338,
    "path" : "~/MEGA/MEGAsync/Universidad/Trabajo Fin de Grado/SDR/R/leerDatos.R",
    "project_path" : "R/leerDatos.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}