{
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\n# library(graphics)\n#library(GA)\n\n#Sources-----------------\n# source(\"leerDatos.R\")\n# source(\"Difuso.R\")\n# source(\"ga.R\")\n# source(\"MESDIF.R\")\n# source(\"NMEEFSD.R\")\n# source(\"PruebasEficiencia.R\")\n# source(\"QualityMeasures.R\")\n# source(\"SDIGA.R\")\n#---------------------------\n\n#Limit size for an input file\nMAX_SIZE_MB = 10\noptions(shiny.maxRequestSize= MAX_SIZE_MB * 1024^2)\n\n# The colors for the graphs (obtened from Material Design: http://www.google.ch/design/spec/style/color.html#color-color-palette)\ncolors <- c(\"#E8F5E9\", \"#A5D6A7\", \"#4CAF50\", \"#388E3C\", \"#FFF9C4\", \"#FFF176\", \n            \"#FFEB3B\", \"#FDD835\", \"#F9A825\")\n\n\n\nshinyServer(function(input, output, session) {\n  \n  \n  # All this must be session variables instead of global ones.\n  dataTra <- NULL\n  datosTra <- NULL\n  \n  dataTst <- NULL\n  datosTst <- NULL\n  \n  rutaTra <- \"\"\n  rutaTst <- \"\"\n  \n  data <- NULL\n  datos <- NULL\n  graficoSectores <- T\n  fileAnterios <- \"Tra\"\n  \n  lastValue <- 0\n  \n  \n  \n  #on exit clean temporal file\n  on.exit({ \n    if(file.exists(paste(getwd(), \"/rulesFile.txt\",  sep = \"\"))) file.remove(paste(getwd(), \"/rulesFile.txt\",  sep = \"\"))\n    if(file.exists(paste(getwd(), \"/optionsFile.txt\",  sep = \"\"))) file.remove(paste(getwd(), \"/optionsFile.txt\",  sep = \"\"))\n    if(file.exists(paste(getwd(), \"/testQualityMeasures.txt\",  sep = \"\"))) file.remove(paste(getwd(), \"/testQualityMeasures.txt\",  sep = \"\"))\n  })\n  \n  \n  \n  \n  output$statistics <- renderTable({\n    #----Inputs de los que escucha ------\n    input$traTstRadio\n    input$classNames\n    input$traFile\n    input$tstFile\n    #------------------------------\n    if(input$targetClassSelect == \"NA\" || length(input$targetClassSelect) == 0 || is.null(input$targetClassSelect))\n      return(NULL)\n    \n     pos <- which(data[[2]] == input$targetClassSelect)\n     if(length(pos) > 0){\n       \n    if(data[[3]][pos] != 'c'){\n      resu <- summary(datos[which(data[[2]] == input$targetClassSelect), ])\n      as.matrix(resu)\n      \n    }else{\n      \n      posiciones <- NULL\n      for(i in input$classNames){\n        p <- which(data[[15]][[pos]][datos[pos,] + 1] == i)\n        if(length(p) > 0)\n          posiciones <- c(posiciones, p)\n      }\n      \n      resu <- summary(data[[2]][datos[which(data[[2]] == input$targetClassSelect), posiciones] + 1])\n      as.matrix(resu)\n    }\n     }\n  })\n\n\n  output$datasetInfo <- renderPlot({\n    \n    #----Inputs de los que escucha ------\n    tra <- input$traTstRadio\n    graficoSectores <- input$visualizacion == \"Pie Chart\"\n    input$traTstRadio\n    input$ejecutar\n    #------------------------------------\n    \n    if(input$targetClassSelect == \"NA\" || length(input$targetClassSelect) == 0 || is.null(input$targetClassSelect))\n      return(NULL)\n \n    pos <- which(data[[2]] == input$targetClassSelect)\n    if(length(pos) == 0)\n      return(NULL)\n    \n    categorico <- data[[3]][pos] == 'c'\n    \n    if(graficoSectores & categorico){\n    \n        posiciones <- NULL\n        for(i in input$classNames){\n          p <- which(data[[15]][[pos]][datos[pos,] + 1] == i)\n          if(length(p) > 0 )\n            posiciones <- c(posiciones, p)\n        }\n        if(!is.null(posiciones)){\n          tabla <- table(data[[15]][[pos]][datos[pos,]+1][posiciones])\n          pie(x = tabla,\n              labels = paste(names(tabla), tabla, sep = \": \"),\n              radius = 1, \n              clockwise = TRUE,\n              col = colors, \n              main = \"Distribution of examples over variables\"\n          )\n        }\n    \n    \n    } else {\n      updateRadioButtons(session, \"visualizacion\", selected = \"Histogram\")\n      if(categorico){\n        posiciones <- NULL\n        for(i in input$classNames){\n          p <- which(data[[15]][[pos]][datos[pos,] + 1] == i)\n          if(length(p) > 0 )\n            posiciones <- c(posiciones, p)\n        }\n        updateRadioButtons(session, \"visualizacion\", selected = \"Histogram\")\n        barplot(tabla <- table(data[[15]][[pos]][datos[pos,]+1][posiciones]),\n                main = \"Distribution of examples over variables\",\n                col = colors\n                )\n      } else if(input$visualizacion == \"Histogram\") {\n        updateRadioButtons(session, \"visualizacion\", selected = \"Histogram\")\n        hist(x = datos[pos,],\n             col = colors,\n             main = \"Distribution of examples over variables\",\n             ylab = \"Frequency\",\n             xlab = \"Value\")\n      } else if(input$visualizacion == \"Box Plot\"){\n        updateRadioButtons(session, \"visualizacion\", selected = \"Box Plot\")\n        boxplot(datos[pos,]) #Ponerlo mas bonito si eso.\n      }\n    }\n    \n  })\n  \n  \n  \n  \n  \n  # Observe Training File\n observe({\n   if(! is.null(input$traFile)){\n     tryCatch({\n    if(rutaTra != paste(input$traFile[,1],input$traFile[,4])){\n      file <- input$traFile\n      file.rename(file$datapath, paste(file$datapath, regmatches(x = file, m = gregexpr(pattern = \"\\\\.[[:alnum:]]+$\", text = file))[[1]], sep = \"\"))\n      file$datapath <- paste(file$datapath, regmatches(x = file, m = gregexpr(pattern = \"\\\\.[[:alnum:]]+$\", text = file))[[1]], sep = \"\")\n      rutaTra <<- paste(input$traFile[,1],input$traFile[,4])\n      dataTra <<- SDR::read.keel(file$datapath)\n      updateSelectInput(session = session, \n                        inputId = \"targetClassSelect\", \n                        label = \"Select the target variable\", \n                        choices = dataTra[[2]], selected = dataTra[[2]][length(dataTra[[2]])])\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(dataTra[[3]][length(dataTra[[2]])] == 'c') \n                                      c(\"All Values\", dataTra[[15]][[length(dataTra[[2]])]])\n                                  else\n                                    \"This is not a categorical variable!\"\n                          )\n      updateRadioButtons(session, \"traTstRadio\", \n                         label = \"Visualize file: \", \n                         choices = c(\"Training File\", \"Test File\"), \n                         selected = \"Training File\")\n      \n      data <<- dataTra\n      datosTra <<- matrix(unlist(dataTra$data), nrow = dataTra$nVars + 1)\n      datos <<- datosTra\n      .updateAttributes(session, dataTra[[2]][length(dataTra[[2]])], data)\n    }\n     } , error = function(e) print(e)) \n   }\n })\n  \n  \n  \n  # Observe Test File\n  observe({\n    if(! is.null(input$tstFile)){\n      if(rutaTst != paste(input$tstFile[,1], input$tstFile[,4])){\n        file <- input$tstFile\n        file.rename(file$datapath, paste(file$datapath, regmatches(x = file, m = gregexpr(pattern = \"\\\\.[[:alnum:]]+$\", text = file))[[1]], sep = \"\"))\n        file$datapath <- paste(file$datapath, regmatches(x = file, m = gregexpr(pattern = \"\\\\.[[:alnum:]]+$\", text = file))[[1]], sep = \"\")\n        rutaTst <<- paste(input$tstFile[,1], input$tstFile[,4])\n        dataTst <<- SDR::read.keel(file$datapath)\n        updateSelectInput(session = session, \n                          inputId = \"targetClassSelect\", \n                          label = \"Select the target variable\", \n                          choices = dataTst[[2]], selected = dataTst[[2]][length(dataTst[[2]])])\n        updateSelectInput(session = session, \n                          inputId = \"targetValueSelect\", \n                          label = \"Select the target value\", \n                          choices = if(dataTst[[3]][length(dataTst[[2]])] == 'c') \n                            c(\"All Values\", dataTst[[15]][[length(dataTst[[2]])]] )\n                          else\n                            \"This is not a categorical variable!\"\n        )\n        updateRadioButtons(session, \"traTstRadio\", \n                           label = \"Visualize file: \", \n                           choices = c(\"Training File\", \"Test File\"), \n                           selected = \"Test File\")\n        data <<- dataTst\n        datosTst <<- matrix(unlist(dataTst$data), nrow = dataTst$nVars + 1)\n        datos <<- datosTst\n        .updateAttributes(session, dataTst[[2]][length(dataTst[[2]])], data)\n        \n      }\n    }\n  })\n  \n  \n  \n  \n  \n  \n  #Observe Visualize File\n  observe({\n    file <- input$traTstRadio\n    if(file == \"Training File\" & fileAnterios == \"Tst\"){\n      fileAnterios <<- \"Tra\"\n      data <<- dataTra\n      datos <<- datosTra\n      updateSelectInput(session = session, \n                        inputId = \"targetClassSelect\", \n                        label = \"Select the target variable\", \n                        choices = data[[2]], selected = data[[2]][length(data[[2]])])\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(!is.null(data) ) if(data[[3]][length(data[[2]])] == 'c') \n                          c(\"All Values\", data[[15]][[length(data[[2]])]])\n                        else\n                          \"This is not a categorical variable!\"\n      )\n      \n      .updateAttributes(session, data[[2]][length(data[[2]])], data)\n      \n    } else if(file == \"Test File\" & fileAnterios == \"Tra\") {\n      fileAnterios <<- \"Tst\"\n      data <<- dataTst\n      datos <<- datosTst\n      updateSelectInput(session = session, \n                        inputId = \"targetClassSelect\", \n                        label = \"Select the target variable\", \n                        choices = data[[2]], selected = data[[2]][length(data[[2]])])\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(!is.null(data) )if(data[[3]][length(data[[2]])] == 'c') \n                          c(\"All Values\", data[[15]][[length(data[[2]])]])\n                        else\n                          \"This is not a categorical variable!\"\n      )\n      .updateAttributes(session, data[[2]][length(data[[2]])], data)\n   \n      }\n  })\n  \n  #Observe Target Variable\n  observe({\n    \n    pos <- which(data[[2]] == input$targetClassSelect)\n    if(length(pos) > 0){\n      updateSelectInput(session = session, \n                        inputId = \"targetValueSelect\", \n                        label = \"Select the target value\", \n                        choices = if(data[[3]][pos] == 'c') \n                          c(\"All Values\", data[[15]][[pos]])\n                        else\n                          \"This is not a categorical variable!\"\n      )\n      .updateAttributes(session, input$targetClassSelect, data)\n    }\n  })\n  \n  \n  #EJECUTAR ALGORITMO \n\n  observe({\n    input$ejecutar\n  \n    value <- input$ejecutar\n\n  \n    if(input$ejecutar <= lastValue) return(NULL)\n   \n    tryCatch({\n    # Read parameters and check errors\n    # ----------------------------------------------\n    if(any(is.null(dataTra), is.null(dataTst)) )\n      stop(\"You must supply a training file and a test file. \")\n    \n    if(dataTra[[1]] != dataTst[[1]])\n      stop(\"Training and test file must be the same relation.\")\n    \n    targetValue <- isolate(input$targetValueSelect)\n    if(targetValue == \"This is not a categorical variable!\")\n      stop(\"No categorical variable selected as target variable.\")\n    \n    if(targetValue == \"All Values\")\n      targetValue <- \"null\"\n    \n    #Set target Variable.\n\n      dataTst <<- SDR::changeTargetVariable(dataTst, which(input$targetClassSelect == dataTst[[2]]))\n      dataTra <<- SDR::changeTargetVariable(dataTra, which(input$targetClassSelect == dataTra[[2]]))\n    \n      \n    targetClass <- isolate(input$targetClassSelect)\n    algorithm <- isolate(input$algoritmo)\n    \n    nLabels <- isolate(input$nLabels)\n    rulesRep <- if(isolate(input$rulesRep == \"Canonical\")) \"can\" else \"dnf\"\n    nEvals <- isolate(input$nEval)\n    popSize <- isolate(input$popSize)\n    crossProb <- isolate(input$crossProb)\n    mutProb <- isolate(input$mutProb)\n    seed <- isolate(input$seed)\n    #------------------------------------------------------\n    \n\n    \n    # Preparation of specific parameters and execution of the algoritm.\n    switch(algorithm,\n           \"SDIGA\"= {\n             minConf <- isolate(input$minConf)\n             Obj1 <- .getObjetives(isolate(input$Obj1))\n             w1 <- isolate(input$w1)\n             Obj2 <- .getObjetives(isolate(input$Obj2))\n             w2 <- isolate(input$w2)\n             Obj3 <- .getObjetives(isolate(input$Obj3))\n             w3 <- isolate(input$w3)\n             lSearch = if(isolate(input$lSearch)) \"yes\" else \"no\"\n            \n             # Execute the algorithm\n             #sink(\"tempFile.txt\")\n             SDR::SDIGA(training = dataTra, \n                   test = dataTst, \n                   seed = seed, \n                   nLabels = nLabels, \n                   nEval = nEvals,\n                   popLength = popSize, \n                   mutProb = mutProb,\n                   RulesRep = rulesRep, \n                   Obj1 = Obj1, \n                   w1 = w1, \n                   Obj2 = Obj2, \n                   w2 = w2, \n                   Obj3 = Obj3, \n                   w3 = w3, \n                   minConf = minConf,\n                   lSearch = lSearch,\n                   targetClass = targetValue )\n             #sink(NULL)\n             \n            \n           },\n           \"MESDIF\" = {\n             \n             elitePop <- isolate(input$elitePop)\n             if(elitePop > popSize) stop(\"Elite population must be smaller than population size\")\n             Obj1 <- .getObjetives(isolate(input$Obj1M))\n             Obj2 <- .getObjetives(isolate(input$Obj2M))\n             Obj3 <- .getObjetives(isolate(input$Obj3M))\n             Obj4 <- .getObjetives(isolate(input$Obj4M))\n             crossProb <- isolate(input$crossProbM)\n             \n            \n             # Execute the algorithm\n             #sink(\"tempFile.txt\")\n             SDR::MESDIF(training = dataTra,\n                    test = dataTst,\n                    seed = seed,\n                    nLabels = nLabels,\n                    nEval = nEvals,\n                    popLength = popSize,\n                    eliteLength = elitePop,\n                    crossProb = crossProb,\n                    mutProb = mutProb,\n                    RulesRep = rulesRep,\n                    Obj1 = Obj1,\n                    Obj2 = Obj2,\n                    Obj3 = Obj3,\n                    Obj4 = Obj4,\n                    targetClass = targetValue)\n             #sink(NULL)\n             \n           },\n           \"NMEEF-SD\" = {\n             minCnf <- isolate(input$minConf)\n             Obj1 <- .getObjetives(isolate(input$Obj1N))\n             Obj2 <- .getObjetives(isolate(input$Obj2N))\n             Obj3 <- .getObjetives(isolate(input$Obj3N))\n             strictDominance <- if(isolate(input$strictDominance)) \"yes\" else \"no\"\n             reInit <- if(isolate(input$reInitPob)) \"yes\" else \"no\"\n             porcCob <- isolate(input$porcCob)\n             \n             #Execute te algorithm\n             SDR::NMEEF_SD(training = dataTra,\n                      test = dataTst,\n                      seed = seed,\n                      nLabels = nLabels,\n                      nEval = nEvals,\n                      popLength = popSize,\n                      mutProb = mutProb,\n                      crossProb = crossProb,\n                      RulesRep = rulesRep,\n                      Obj1 = Obj1,\n                      Obj2 = Obj2,\n                      Obj3 = Obj3,\n                      minCnf = minCnf,\n                      reInitCoverage = reInit,\n                      porcCob = porcCob,\n                      StrictDominance = strictDominance,\n                      targetClass = targetValue)\n           },\n           \"FuGePSD\" = {\n             # /**/\n             t_norm <- isolate(input$tnorm)\n             ruleWeight <- isolate(input$ruleWeight)\n             frm <- isolate(input$frm)\n             insProb <- isolate(input$insProb)\n             dropProb <- isolate(input$dropProb)\n             tSize <- isolate(input$tournamentSize)\n             gfw <- c(isolate(input$gfw1), isolate(input$gfw2), isolate(input$gfw3), isolate(input$gfw4) )\n             allClass <- isolate(input$allClass)\n             \n             SDR::FUGEPSD(paramFile = NULL,\n                          training = dataTra,\n                          test = dataTst,\n                          seed = seed,\n                          t_norm = t_norm,\n                          ruleWeight = ruleWeight,\n                          frm = frm,\n                          numGenerations = nEvals,\n                          numberOfInitialRules = popSize,\n                          crossProb = crossProb,\n                          mutProb = mutProb,\n                          insProb = insProb,\n                          dropProb = dropProb,\n                          tournamentSize = tSize,\n                          globalFitnessWeights = gfw,\n                          ALL_CLASS = allClass)\n           }\n    )\n    \n    },\n    error = function(e){\n      cat(as.character(e), file = \"rulesFile.txt\")\n      cat(as.character(e), file = \"optionsFile.txt\")\n      cat(as.character(e), file = \"testQualityMeasures.txt\")\n      return(NULL)\n    }\n    )\n\n    \n    if (input$ejecutar > 0){\n      updateTabsetPanel(session = session, inputId = \"tabSet\", selected = \"Rules generated\")\n    }\n    lastValue <<- value\n  })\n\n  \n  \n  observe({\n    algo <- input$algoritmo\n    if(algo == \"FuGePSD\"){\n      updateNumericInput(session, \"nEval\", label = \"Number of generations\", value = 300, min = 1, max = Inf, step = 1)\n      updateSelectInput(session, \"rulesRep\", \"Type of rules: \", choices = c(\"Canonical\"))\n    } else if(algo %in% c(\"SDIGA\", \"MESDIF\")){\n      updateNumericInput(session, \"nEval\", label = \"Number of evaluations\", value = 10000, min = 1, max = Inf, step = 1)\n      updateSelectInput(session, \"rulesRep\", \"Type of rules: \", choices = c(\"Canonical\", \"DNF (Disyuntive Normal Form)\"))\n    } else if (algo == \"NMEEF-SD\"){\n      updateNumericInput(session, \"nEval\", label = \"Number of evaluations\", value = 10000, min = 1, max = Inf, step = 1)\n      updateSelectInput(session, \"rulesRep\", \"Type of rules: \", choices = c(\"Canonical\"))\n    }\n  })\n  \n  \n  # RESULTADOS \n  \n  output$resultados <- renderDataTable({\n    \n    input$ejecutar\n    \n    algoritmo <- isolate(input$algoritmo)\n    if(algoritmo == \"FuGePSD\"){\n      file <- which(c(file.exists(\"rulesFile_f06_TRUE.txt\"), file.exists(\"rulesFile_f06_FALSE.txt\")))\n      file <- c(\"rulesFile_f06_TRUE.txt\", \"rulesFile_f06_FALSE.txt\")[file]\n      contents <- readChar(file, file.info(file)$size)\n      contents <- gsub(pattern = \"[0-9]+:\", replacement = \"\", x = contents)\n      contents <- strsplit(x = contents, split = \"\\n\", fixed = TRUE)[[1]]\n      contents <- contents[- c(1,2,3)]\n      #Eliminate the \"with rule weight\":\n      contents <- gsub(pattern = \"\\\\bwith Rule Weight\\\\b:\", replacement = \"\", x = contents)\n      reglas <- gsub(pattern = \"[[:blank:]]{2}-?[0-9.]+\", replacement = \"\", x = contents)\n      weigths <- strsplit(paste(contents, collapse = \" \"), split = \"  \")[[1]]\n      weigths <- weigths[which(seq_len(length(weigths)) %% 2 == 0)]\n      mat <- matrix(NA, nrow = length(reglas), ncol = 3)\n      colnames(mat) <- c(\"Num Rule\", \"Rule\", \"Weight\")\n      mat[,1] <- as.character(seq_len(length(reglas)))\n      mat[,2] <- reglas\n      mat[,3] <- weigths\n      \n      junk <- dir(\".\", \"[^QM].txt\")\n      options <- which(junk == \"optionsFile.txt\")\n      if(length(options) > 0)\n        junk <- junk[- options]\n      \n      file.remove(junk)\n      \n      as.data.frame(mat)\n      \n    } else {\n      if(file.exists(\"rulesFile.txt\")){\n      #get and parse the results\n      contents <- readChar(\"rulesFile.txt\", file.info(\"rulesFile.txt\")$size)\n      rules <- strsplit(contents, \"GENERATED RULE \", fixed = TRUE )\n      if(length(rules[[1]]) > 1){\n        rules <- substr(rules[[1]][2:length(rules[[1]])] , 3, stop = nchar(rules[[1]][2:length(rules[[1]])]))\n        \n        invalid <- grep(\" # Invalid (Low confidence or support)\", rules, fixed = T) \n        if(length(invalid) > 0) rules <- rules[ - invalid ]\n        \n        rules <- gsub(\" - Target value: .*\", \"\", rules, perl = T)\n        rules <- sub(\":\", \"\", rules, fixed = FALSE)\n        rules <- gsub(pattern = \"\\n\", x = rules, replacement = \"<br/>\", fixed = T)\n      }\n      file.remove(\"rulesFile.txt\")\n      \n      # Show the results\n      rules <- matrix(c(seq_len(length(rules)), rules), ncol = 2)\n      colnames(rules) <- c(\"Num Rule\", \"Rule\")\n     \n      as.data.frame(rules)\n      }\n    }\n}, escape = FALSE, options = list(pageLength = 10))\n  \n  \n  \n  \n  output$execInfo <- renderUI({\n    input$ejecutar\n    if(file.exists(\"optionsFile.txt\")){\n      #get and process results\n      contents <- readChar(\"optionsFile.txt\", file.info(\"optionsFile.txt\")$size)\n      contents <- gsub(pattern = \"\\n\", replacement = \"<br/>\", x = contents, fixed = TRUE)\n      file.remove(\"optionsFile.txt\")\n      \n      #Show results as html\n      strong( HTML(contents), style = \"font-family: 'consolas'\" )\n         \n    }\n  })\n  \n  \n  output$medidas <- renderDataTable({\n    input$ejecutar\n    algoritmo <- isolate(input$algoritmo)\n    if(algoritmo == \"FuGePSD\"){\n      if(file.exists(\"rulesFile_f06_TRUE_QM.txt\") || file.exists(\"rulesFile_f06_FALSE_QM.txt\")){\n        #get and process results\n        file <- which(c(file.exists(\"rulesFile_f06_TRUE_QM.txt\"), file.exists(\"rulesFile_f06_FALSE_QM.txt\")))\n        file <- c(\"rulesFile_f06_TRUE_QM.txt\", \"rulesFile_f06_FALSE_QM.txt\")[file]\n        contents <- readChar(file, file.info(file)$size)\n        contents <- gsub(x = contents, pattern = \"[^0-9.]+\",replacement = \" \")\n        contents <- strsplit(x = contents, split = \" \", fixed = TRUE)[[1]][-1]\n        contents <- as.numeric(contents)\n        \n        mat <- matrix(contents, ncol = 9, byrow = TRUE)\n        mat[seq_len(nrow(mat) - 1) , 1] <- NA\n        colnames(mat) <- c(\"nRules\", \"nVars\", \"Coverage\", \"Significance\", \"Unusualness\", \"Sensitivity\", \"Support\", \"FConfidence\", \"CConfidence\")\n        rownames(mat) <- c( seq_len((length(contents) / 9 - 1)), \"Global: \")\n        \n        junk <- dir(\".\", \"[*QM].txt\")\n    \n        file.remove(junk)\n        \n        #Show results as html\n        #as.table(mat)\n        as.data.frame(mat, stringsAsFactors = FALSE)\n      }\n    } else {\n      if(file.exists(\"testQM.txt\")){\n        #get and process results\n        contents <- readChar(\"testQM.txt\", file.info(\"testQM.txt\")$size)\n        contents <- gsub(x = contents, pattern = \"[^0-9.]+\",replacement = \" \")\n        contents <- strsplit(x = contents, split = \" \", fixed = TRUE)[[1]][-1]\n        contents <- as.numeric(contents)\n       \n        \n        mat <- matrix(contents, ncol = 10, byrow = TRUE)\n\n        mat[seq_len(nrow(mat) - 1) , 1] <- NA\n        colnames(mat) <- c(\"nRules\", \"nVars\", \"Coverage\", \"Significance\", \"Unusualness\", \"Accuracy\", \"CSupport\", \"FSupport\", \"CConfidence\", \"FConfidence\")\n      \n        file.remove(\"testQM.txt\")\n        as.data.frame(mat, stringsAsFactors = FALSE)\n       \n      }\n    }\n  })\n\n})\n\n.getObjetives <- function(obj){\n  switch(obj,\n         \"null\" = {\"null\"},\n          \"Crisp Support\" = {\"CSUP\"},\n         \"Fuzzy Support\" = {\"FSUP\"},\n         \"Crisp Confidence\" = {\"CCNF\"},\n         \"Fuzzy Confidence\" = {\"FCNF\"},\n         \"Coverage\" = {\"COVE\"},\n         \"Significance\" = {\"SIGN\"},\n         \"Unusualness\" = {\"UNUS\"}\n         )\n}\n\n\n.updateAttributes <- function(session, attribute, data){\n  if(attribute == \"NA\" || length(attribute) == 0 || is.null(attribute))\n    return(NULL)\n  \n    if( data[[3]][which(data[[2]] == attribute)] == 'c' )\n      updateCheckboxGroupInput(session, inputId = \"classNames\", label = \"Select attributes\", choices = data[[15]][[which(data[[2]] == attribute)]], selected = data[[15]][[which(data[[2]] == attribute)]], inline = T)\n    else\n      updateCheckboxGroupInput(session, \"classNames\", label = \"Select attributes\", choices = NA, inline = T)\n  \n}\n\n\nmakeSDIGAParamFile <- function(input, nLabels, ruleRep, nEvals, popSize, crossProb, mutProb, seed, minConf, Obj1, w1, Obj2, w2, Obj3, w3, lSearch, targetClass){\n  fichero <- paste(\n    \"algorithm = SDIGA\\n\",\n    \"inputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"outputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"seed = \", seed, \"\\n\",\n    \"nLabels = \", nLabels, \"\\n\",\n    \"nEval = \", nEvals, \"\\n\",\n    \"popLength = \", popSize, \"\\n\",\n    \"crossProb = \", crossProb, \"\\n\",\n    \"mutProb = \", mutProb, \"\\n\",\n    \"minConf = \", minConf, \"\\n\",\n    \"RulesRep = \", ruleRep, \"\\n\",\n    \"Obj1 = \", if(is.null(Obj1)) \"null\" else Obj1, \"\\n\",\n    \"Obj2 = \", if(is.null(Obj2)) \"null\" else Obj2, \"\\n\",\n    \"Obj3 = \", if(is.null(Obj3)) \"null\" else Obj3, \"\\n\",\n    \"w1 = \", w1, \"\\n\",\n    \"w2 = \", w2, \"\\n\",\n    \"w3 = \", w3, \"\\n\",\n    \"lSearch = \", lSearch, \"\\n\",\n    \"targetClass = \", if(targetClass == \"All Values\") \"null\" else targetClass, \"\\n\"\n    , sep = \"\"\n  )\n  \n  cat(fichero, file = \"param.txt\", append = FALSE)\n  fichero\n}\n\nmakeMESDIFParamFile <- function(input, nLabels, ruleRep, nEvals, popSize, eliteSize, crossProb, mutProb, seed, Obj1, Obj2, Obj3, Obj4, targetClass){\n  fichero <- paste(\n    \"algorithm = MESDIF\\n\",\n    \"inputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"outputData = \\\"\", input$traFile[,4], \"\\\" \\\"\", input$tstFile[,4],\"\\\"\\n\",\n    \"seed = \", seed, \"\\n\",\n    \"nLabels = \", nLabels, \"\\n\",\n    \"nEval = \", nEvals, \"\\n\",\n    \"popLength = \", popSize, \"\\n\",\n    \"eliteLength = \", eliteSize, \"\\n\",\n    \"crossProb = \", crossProb, \"\\n\",\n    \"mutProb = \", mutProb, \"\\n\",\n    \"RulesRep = \", ruleRep, \"\\n\",\n    \"Obj1 = \", if(is.null(Obj1)) \"null\" else Obj1, \"\\n\",\n    \"Obj2 = \", if(is.null(Obj2)) \"null\" else Obj2, \"\\n\",\n    \"Obj3 = \", if(is.null(Obj3)) \"null\" else Obj3, \"\\n\",\n    \"Obj4 = \", if(is.null(Obj4)) \"null\" else Obj4, \"\\n\",\n    \"echo = no\", \"\\n\",\n    \"targetClass = \", if(targetClass == \"All Values\") \"null\" else targetClass, \"\\n\"\n    , sep = \"\"\n  )\n  \n  cat(fichero, file = \"param.txt\", append = FALSE)\n  fichero\n}\n ",
    "created" : 1445169532837.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "327005240",
    "id" : "BD9FD881",
    "lastKnownWriteTime" : 1445171174,
    "path" : "E:/Escritorio/SDR/inst/shiny/server.R",
    "project_path" : "inst/shiny/server.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}