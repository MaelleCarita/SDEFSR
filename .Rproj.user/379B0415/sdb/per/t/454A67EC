{
    "contents" : "#\n#\n#   THIS FILE CONTAINS SOME FUNCTIONS FOR DOING SOME STUFF INSIDE THE PACKAGE.\n#   THIS MEANS THAT THE FUNCTIONS USED HERE MUST NOT BE EXPORTED. (EXCEPT ONE)\n#\n#\n\n\n# Utils relative to obtain the fuzzy belonging degree\n\n#--------------------------------------------------------------------\n\n\n\n#'\n#' Return the compatibility degrees of a rule with all instances of a given dataset.\n#' \n#' The rules passed to this functions MUST have a vector representation in CANONICA form. This function\n#' was made for being used mainly for the FuGePSD algorithm. \n#' \n#' @param ejemplo The instances of the dataset, a matrix with one example PER COLUMN and without the CLASS ATTRIBUTE.\n#' @param rule_cat Part of the rule with the categorical values.\n#' @param rule_num Part of the rule with the numerical values.\n#' @param catParticip vector indicating which categorical attributes participate in the rule and so, they must be evaluated.\n#' @param numParticip vector indicating which numerical attributes participate in the rule and so, they must be evaluated.\n#' @param xmin numeric vector which indicate the minimum value of the fuzzy sets of every numeric attribute that participate in the rule.\n#' @param xmedio numeric vector which indicate the medium value of the fuzzy sets of every numeric attribute that participate in the rule.\n#' @param xmax numeric vector which indicate the maximum value of the fuzzy sets of every numeric attribute that participate in the rule.\n#' @param n_matrices number of fuzzy sets that there are in the rule (The length of vectors xmin, xmedio and xmax)\n#' @param max_cat numeric vector indicating the maximum value of categorical values.\n#' @param max_num numeric vector indicating the maximum value for fuzzy partitions on every attribute\n#' @param t_norm The T-norm to use to compute the compatibility degree. 0 for minimum t-norm. Other value for product t-norm\n#' \n#' @return A vector with length 'number of examples' indicating their compatibility degree.\n#' \nRule.compatibility <- function(ejemplo, rule_cat, rule_num, catParticip, numParticip, xmin, xmedio, xmax, n_matrices,max_cat, max_num, t_norm){\n  dispFuzzy <- numeric(NCOL(ejemplo)) + 1\n  \n  #Computation of membership degree.\n  \n  #Categorical variables.\n  if(length(catParticip > 0)){\n    ej_cat <- as.integer( ejemplo[catParticip,] )\n    values <-  ceiling( ( which(ej_cat != rule_cat & ! (ej_cat == max_cat + 1 )) / (length(catParticip)) ) ) \n    #Examples no compatibles\n    dispFuzzy[values] <- 0L\n  }\n  \n  \n  #Numerical Values \n  if(length(numParticip) > 0){\n    ej_num <- as.vector( ejemplo[numParticip, which(dispFuzzy > 0) ] )\n    \n    #Fuzzy computation\n    #Computes compatibility degree of every value of the whole dataset with the rule\n    pertenencia <- .grado_pertenencia5(x = ej_num, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices)\n    \n    if(t_norm == 0) { # MINIMUM T-NORM \n      dispFuzzy[which(dispFuzzy > 0)] <- apply(X = pertenencia, MARGIN = 1, FUN = min)\n    } else { # PRODUCT T-NORM\n      dispFuzzy[which(dispFuzzy > 0)] <- apply(X = pertenencia, MARGIN = 1, FUN = prod)\n    }\n  }\n  \n  \n  dispFuzzy\n  \n}\n\n\n\n\n\n#\n#\n#   Gets the membership degree of all examples in the dataset over a single rule. (Use with lapply)\n#\n#     ONLY FOR CAN RULES\n# ejemplo es una matriz despues de usar .separar\n# rule_cat is the categorcal variables that participate in the rule\n# rule_num is the numerical variables that participate in the rule\n# catParticip and numParticip are logical vectors for tell the function which rules of each type participe in the rule\n# xmin, xmax, xmedio and xminCrisp and xmaxCrisp are the vectors with the fuzzy and crisp definition of the variables that participa in the rule\n# max_cat is a vector the maximum value for categorical values and max_num is the same but for numerical variables.\n\n.compara_CAN9 <- function(ejemplo, rule_cat, rule_num, catParticip, numParticip, xmin, xmedio, xmax, n_matrices, xminCrisp, xmaxCrisp, max_cat){\n  dispFuzzy <- numeric(NCOL(ejemplo)) + 1\n  dispCrisp <- integer(NCOL(ejemplo)) + 1L\n  \n  \n  \n  \n  #Computation of membership degree.\n  \n  #Categorical variables.\n  if(length(catParticip > 0)){\n    ej_cat <- as.integer( ejemplo[catParticip,] )\n    values <-  ceiling( ( which(ej_cat != rule_cat & ! (ej_cat == max_cat + 1 )) / (length(catParticip)) ) ) \n    #Examples no compatibles\n    dispFuzzy[values] <- 0L\n    dispCrisp[values] <- 0L\n  }\n  \n  \n  #Numerical Values \n  if(length(numParticip) > 0){\n    ej_num <- as.vector( ejemplo[numParticip, which(dispFuzzy > 0) ] )\n    #Fuzzy computation\n    pertenencia <- .grado_pertenencia5(x = ej_num, xmin = xmin, xmedio = xmedio, xmax = xmax, n_matrices = n_matrices)\n    dispFuzzy[which(dispFuzzy > 0)] <- apply(X = pertenencia, MARGIN = 1, FUN = min)\n    \n    #Crisp Computation\n    pertenencia <- .gradoPertenenciaCrisp2(x = ej_num, xmin = xminCrisp, xmax = xmaxCrisp)\n    dispCrisp[which(dispCrisp > 0)] <- apply(X = pertenencia, MARGIN = 1, FUN = min)\n    \n  }\n  \n  \n  return(list( fuzzy = dispFuzzy, crisp = dispCrisp) )\n  \n}\n\n#\n#\n#\n# It works similar to compara_CAN9 but for DNF rules.\n#\n\n.comparaDNF4 <- function(ejemplo,  regla, regla_num, cat_particip, num_particip, max_regla_cat, max_regla_num, nLabels, fuzzySets, crispSet, valuesFuzzy, valuesCrisp){\n  ejemplo_cat <- as.vector( ejemplo[cat_particip, ] )\n  \n  dispFuzzy <- numeric(NCOL(ejemplo)) + 1\n  dispCrisp <- numeric(NCOL(ejemplo)) + 1\n  #No salen los mismo resultados a?n.\n  if(length(ejemplo_cat > 0)){  \n    valCat <- (max_regla_cat + 1) + ejemplo_cat\n    \n    #Categorical Values\n    fuera <- unique( ceiling(which(regla[valCat] == 0) / length(max_regla_cat)) )\n    \n    dispFuzzy[fuera] <- 0\n    dispCrisp[fuera] <- 0\n  }\n  \n  ejemplo_num <- ejemplo[num_particip, which(dispFuzzy > 0), drop = F] \n  \n  #Numerical Values\n  if(length(ejemplo_num) > 0){\n    \n    ejemplo_num <- ejemplo_num[valuesFuzzy[1,], ]\n    #Fuzzy Computation\n    dispFuzzy[which(dispFuzzy > 0)] <- .getMaxFuzzyForAVariable2(values = valuesFuzzy, ejemplo_num = ejemplo_num)\n    #Crisp Computation\n    dispCrisp[which(dispCrisp > 0)] <- .getMaxCrispForAVariable2(valuesCrisp, ejemplo_num)\n  }\n  \n  list(fuzzy = dispFuzzy, crisp = dispCrisp)\n  \n}\n\n\n#---------------------------------------------------------------------------\n#   RETURN THE VALUES FOR CALCULATE THE QUALITY MEASURES\n#\n# - Return:\n# -  [[1]] n(cond)  -> Ejemplos cubiertos por la regla\n# -  [[2]] n(Tv ? cond) -> ejemplos cubiertos que cumplen el consecuente\n# -  [[3]] FP -> Ejemplos que cumplen el antecedente pero no el consecuente (Falsos positivos)\n# -  [[4]] Ns -> Numero de ejemplos en el dataset\n# -  [[5]] n(TargetValue) -> numero de ejemplos que cumplen el consecuente\n# -  [[6]] numero de ejemplos cubiertos de cada clase\n# -  [[7]] numero de ejemplos de cada clase\n# -  [[8]] ejemplos correctamente cubiertos que son nuevos\n# -  [[9]] ejemplos de la clase objetivo que quedan por cubrir\n# -  [[10]] suma difusa de los ejemplos cubiertos\n# -  [[11]] suma difusa de los ejemplos correctamente cubiertos\n# -  [[12]] suma difusa de los ejemplos nuevos correctamente cubiertos\n# \n# ---------------------------------------------------------------\n\n\n.get_values6 <- function(gr_perts, nombre_clases, dataset, targetClass, examples_perClass, cov, Ns, N_vars , por_cubrir, marcar = FALSE, test = FALSE, difuso = FALSE, NMEEF = FALSE){\n  #Esto no es lo mejor, habr?a que buscar otra manera de utilizar la lista directamente\n  dataset <- matrix(unlist(dataset), nrow = length(dataset[[1]]), ncol = length(dataset))\n  \n  ejemplo_Cubiertos <- 0L\n  sumaFuzzyejCubiertos <- 0\n  ejemplosCorr_cubiertos <- 0L\n  sumaFuzzyejCorrectamenteCubiertos <- 0\n  ejemplosNuevos_Cubiertos <- 0L\n  sumaFuzzyEjNuevos <- 0\n  \n  #Datos sobre el dataset\n  \n  #   cov_examplesFuzzy <- replicate(length(nombre_clases), 0)  # Para el calculo de la significancia\n  #   names(cov_examplesFuzzy) <- nombre_clases\n  \n  cov_examplesCrisp <- integer(length(nombre_clases))  # Para el calculo de la significancia\n  names(cov_examplesCrisp) <- nombre_clases\n  \n  fuzzyPerts <- gr_perts[[1]]\n  crispPerts <- gr_perts[[2]]\n  \n  #Averiguamos los ejemplos cubiertos\n  coveredFuzzy <- which( fuzzyPerts > 0)\n  coveredCrisp <- which( crispPerts > 0)\n  \n  \n  #Ejemplos cubiertor por la regla de cada clase (Significancia)\n  #   tabla <- table( t( dataset[N_vars,coveredFuzzy]) )\n  #   cov_examplesFuzzy[ names( tabla )] <- tabla \n  #tabla <- table( t( nombre_clases[ dataset[N_vars,coveredCrisp] + 1] ) )\n  tabla <- improvedTable(dataset[, coveredCrisp, drop = F], nombre_clases)\n  cov_examplesCrisp[names( tabla )] <- tabla \n  \n  \n  #Ejemplos cubiertos por la regla\n  ejemplo_Cubiertos <- length(coveredCrisp)\n  sumaFuzzyejCubiertos <- sum(fuzzyPerts[coveredFuzzy])\n  \n  \n  #Ejemplos correctamente cubiertos\n  p <- nombre_clases[ dataset[N_vars,coveredFuzzy] + 1] == targetClass \n  p1 <- nombre_clases[ dataset[N_vars,coveredCrisp] + 1] == targetClass \n  \n  ejemplosCorr_cubiertos <- sum(p1)\n  sumaFuzzyejCorrectamenteCubiertos <- sum(fuzzyPerts[coveredFuzzy[p]])\n  \n  \n  #Ejemplos correctamente cubiertos que no estaban cubiertos anteriormente.  \n  i <- cov[coveredFuzzy] == FALSE\n  iC <- cov[coveredCrisp] == FALSE\n  obj_notCoveredFuzzy <- which(p & i)\n  obj_notCoveredCrisp <- which(p1 & iC)\n  ejemplosNuevos_Cubiertos <- length(obj_notCoveredCrisp) #NCOL( dataset[ , obj_notCovered])\n  sumaFuzzyEjNuevos <- sum(fuzzyPerts[coveredFuzzy[obj_notCoveredFuzzy]])\n  \n  #Marcar ejemplos nuevos cubiertos de la clase objetivo (Si es necesario)\n  if(marcar){\n    if(! difuso){\n      cov[coveredCrisp[obj_notCoveredCrisp]] <- TRUE #Si se usa SOPORTE CRISP\n    } else {\n      cov[coveredFuzzy[p & i]] <- TRUE # USAR CUANDO SE USA SOPORTE DIFUSO\n    }\n    \n    l <- list(ejemplo_Cubiertos, ejemplosCorr_cubiertos, NA, Ns, NROW(p[p]), cov_examplesCrisp, examples_perClass, ejemplosNuevos_Cubiertos, por_cubrir, sumaFuzzyejCubiertos, sumaFuzzyejCorrectamenteCubiertos, sumaFuzzyEjNuevos ) \n    conf <- .confianza(l)\n    if( ! test) return(list(cov, conf)) \n    return(list(cov, l) )\n  } else {\n    \n    #por_cubrir <- sum(obj_notCovered) \n    \n    #Return \n    if(!NMEEF){\n      return( list(ejemplo_Cubiertos, ejemplosCorr_cubiertos, NA, Ns, examples_perClass[[targetClass]], cov_examplesCrisp, examples_perClass, ejemplosNuevos_Cubiertos, por_cubrir, sumaFuzzyejCubiertos, sumaFuzzyejCorrectamenteCubiertos, sumaFuzzyEjNuevos ) )\n    }else{\n      cover <- (fuzzyPerts > 0 | crispPerts > 0) & nombre_clases[dataset[N_vars, ] + 1]== targetClass\n      return( list(ejemplo_Cubiertos, ejemplosCorr_cubiertos, NA, Ns, examples_perClass[[targetClass]], cov_examplesCrisp, examples_perClass, ejemplosNuevos_Cubiertos, por_cubrir, sumaFuzzyejCubiertos, sumaFuzzyejCorrectamenteCubiertos, sumaFuzzyEjNuevos, cover ) )\n    }\n  }\n  \n}\n\n\n\n.getVariableYValor <- function(value, max_valores){\n  variable <- which( (value / max_valores) <= 1)[1]  # Solo queremos el primer valor. \n  vInicioVariable <- 1\n  if(variable > 1){\n    vInicioVariable <- max_valores[variable - 1] + 1\n  }\n  valor <- value - vInicioVariable + 1\n  \n  return(c(variable, valor))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#---------------------------------------------------------------------\n# oTHER UTILS\n\n# \n# C.A.R. Hoare QuickSort Implementation\n# @param v The vector to be ordered\n# @param left First index of the subvector\n# @param right Last index of the subvector\n# @param index Index vector\n# @return A list with two fields, vector which is the ordered vector and indices which is the sorted indexes of the original vector \n# \n.qsort <- function(v, left, right, index) {\n \n  \n  i = left\n  j = right\n  x = v[(left+right)/2]\n  while(i <= j){\n    while (v[i]<x && i<right)\n      i <- i + 1\n    while (x<v[j] && j>left)\n      j <- j - 1\n    if (i<=j) {\n      y = v[i];\n      v[i] = v[j];\n      v[j] = y;\n      aux = index[i];\n      index[i] = index[j];\n      index[j] = aux;\n      i <- i + 1\n      j <- j - 1\n    }\n}\n  if (left<j){\n   a <- .qsort(v,left,j,index)\n    v[left:j] <- a$vector\n    index[left:j] <- a$indices\n  }\n  if (i<right){\n   b <- .qsort(v,i,right,index);\n   v[i:right] <- b$vector\n   index[i:right] <- b$indices\n  }\n \n\n  \n  list(vector = v[left:right], indices = index[left:right])\n}\n\n\n\n\n#' Modifiy the number of Fuzzy Labels of the dataset.\n#' \n#' This function change the number of fuzzy labels defined in the current KEEL dataset.\n#' \n#' @details The fuzzy definitions used in the \\code{keel} class are triangular.\n#'     Because you can only specify the number of fuzzy definitions, all those definitions\n#'     has the same width. With this function you can re-calculate this triangular fuzzy sets.\n#' \n#' @param dataset The dataset to modify their fuzzy labels definitions. Must be a \\code{keel} class.\n#' @param nLabels The new number of fuzzy labels. An integer greater than zero.\n#' \n#' @return  This function returns the same dataset with their fuzzy definitions modified.\n#' \n#' @examples \n#'     modifyFuzzyCrispIntervals(habermanTra, 2)\n#'     modifyFuzzyCrispIntervals(habermanTra, 15)\n#'\n#'\n\nmodifyFuzzyCrispIntervals <- function(dataset, nLabels){\n    if(nLabels < 1)\n      stop(\"The number of fuzzy sets ('nLabels') must be greater than zero.\")\n  \n    dataset[[\"fuzzySets\"]] <- .create_fuzzyIntervals(min = dataset$min, max = dataset$max, num_sets = nLabels, types = dataset$atributeTypes)\n    dataset[[\"crispSets\"]] <- .createCrispIntervals(fuzzyIntervals = dataset[[\"fuzzySets\"]])\n  \n    dataset\n}\n\n\n\n\n\n\n\n\n#'\n#' Change the target Variable of a \\code{'keel'} Dataset\n#' \n#' Change the actual target variable for another one if it is categorical.\n#' \n#' @param dataset The KEEL dataset class\n#' @param variable The position (or the name) of the variable to set as target Variable.\n#' @return The dataset with the variables changed\n#' \n#' \n#' @examples \n#' changeTargetVariable(carTra, 3)\n#' changeTargetVariable(carTra, \"Doors\")\n#' \\dontrun{\n#' Throws an error because the variable selected is numerical:\n#' \n#' changeTargetVariable(habermanTra, 1)\n#' }\n#' \n#' \nchangeTargetVariable <- function(dataset, variable){\n  if(class(dataset) != \"keel\") stop( paste(\"'\",substitute(dataset),\"' is not a keel class\", sep = \"\"))\n  #if(variable >= dataset$nVars + 1) stop(\"variable is the same of the actual variable or is out of range\")\n  \n  if(is.character(variable)){\n    variable <- which(tolower(dataset$atributeNames) == tolower(variable))\n    if(length(variable) == 0)\n      stop(paste(variable, \"is not a variable of this dataset.\"))\n  }\n  \n  if(dataset[[3]][variable] != \"c\") stop(\"No categorical variable selected.\")\n  if(variable <= dataset$nVars){\n  #Swap variables.\n  dataset$data <- lapply(X = dataset$data , FUN = function(x, variable){ \n                       aux <- x[variable]; \n                       x[variable] <- x[length(x)]; \n                       x[length(x)] <- aux; \n                       x }, \n                       variable)\n  \n  #Swap Attribute Names\n  aux <- dataset[[2]][variable]\n  dataset[[2]][variable] <- dataset[[2]][length(dataset[[2]])]\n  dataset[[2]][length(dataset[[2]])] <- aux\n  \n  #swap conjuntos\n  dataset[[\"conjuntos\"]][variable] <- dataset[[\"max\"]][dataset[[\"nVars\"]] + 1]\n  \n  #Swap Min\n  aux <- dataset[[4]][variable]\n  dataset[[4]][variable] <- dataset[[4]][length(dataset[[4]])]\n  dataset[[4]][length(dataset[[4]])] <- aux\n  \n  #Swap Max\n  aux <- dataset[[5]][variable]\n  dataset[[5]][variable] <- dataset[[5]][length(dataset[[5]])]\n  dataset[[5]][length(dataset[[5]])] <- aux\n  \n  #Change class_names Values\n  dataset[[\"class_names\"]] <- dataset[[\"categoricalValues\"]][[variable]]\n  \n  #Swap categorical Values\n  aux <- dataset[[\"categoricalValues\"]][[variable]]\n  dataset[[\"categoricalValues\"]][[variable]] <- dataset[[\"categoricalValues\"]][[length(dataset[[\"categoricalValues\"]])]]\n  dataset[[\"categoricalValues\"]][[length(dataset[[\"categoricalValues\"]])]] <- aux\n  \n  #Calculate new value for examplesPerClass\n  clValues <- unlist(lapply(dataset$data, '[', dataset$nVars + 1))\n  examplesPerClass <- lapply(X = seq_len(length(dataset$class_names)) - 1, FUN = function(x, data) sum(data == x), clValues)\n  names(examplesPerClass) <- dataset$class_names\n  dataset$examplesPerClass <- examplesPerClass\n  \n  \n  }\n  \n  dataset\n}\n\n\n\n\n\n\n\n#\n#\n# Gets the variables that participate in a rule\n#\n#\n.getParticipantes <- function(regla, max_regla, DNFRules){\n  if(!DNFRules){\n    participantes <- as.logical( (regla < max_regla) ) #Cuidado que ?sto puede que que no est? bien. No valor de la regla no es comparable con el ejemplo\n  }else{\n    \n    participantes <- logical(length(max_regla) - 1)\n    for(i in 2:length(max_regla)){\n      ruleValues <- regla[(max_regla[i - 1] + 1):max_regla[i]]\n      participantes[i-1] <- !(all(ruleValues == 1) | all(ruleValues == 0))\n    }\n  }\n  \n  participantes\n  \n}\n\n\n\n\n\n#\n# Returns de dataset without the last (class) column\n#\n.separar <- function(dataset){\n  \n  lapply(dataset$data, FUN = function(x) x[-length(x)])\n  \n}\n\n\n#'\n#' Returns the class attribute of the examples of a dataset.\n#'\n.getClassAttributes <- function(dataset){\n  lapply(dataset, FUN = function(x) x[length(x)])\n}\n\n\n\n#\n# returns de original dataes\n#\n.unir <- function(dataNoClass , classes){\n  lapply(X = 1:length(dataNoClass), FUN = function(num, x,y) append(x[[num]],y[[num]]), dataNoClass, classes)\n  \n}\n\n\n\n\n\n\n\n\n\n#\n# Returns a matrix for select the variables that participate in a DNF rule for calculating their belonging degree\n#\n.getMatrixSelector <- function(regla_num, valor){\n  \n  values <- unlist(lapply(X = seq_len(length(regla_num)), \n                          FUN = function(x, regla, valor){\n                            \n                            a <- which(regla[[x]] > 0)\n                            valores <- unlist(lapply(X = a, \n                                                     FUN = function(y, valor, mat){\n                                                       c(y, valor, mat)\n                                                     }, valor, x) )\n                            valores\n                          }, regla_num, valor))\n  \n  \n  matrix(data = values, nrow = length(values) / 3, ncol = 3, byrow = TRUE)\n  \n}\n\n\n\n\n\n\n\n#\n#\n# Obtain the fuzzy values of a DNF Rule\n#\n#\n.getFuzzyValues <- function(regla_num, fuzzy,  crisp = FALSE){\n  a <- .getMatrixSelector(regla_num = regla_num, valor = 1)\n  variables <- a[,3]\n  \n  if(! crisp){\n    xmin <- fuzzy[a]\n    a[,2] <- 2\n    xmedio <- fuzzy[a]\n    a[,2] <- 3\n    xmax <- fuzzy[a]\n    \n    rbind(variables, xmin, xmedio, xmax)\n    \n  } else {\n    xmin <- fuzzy[a]\n    a[,2] <- 2\n    xmax <- fuzzy[a]\n    \n    rbind(variables, xmin, xmax)\n  }\n  \n}\n\n\n\n\n\n\n#\n# Normalize a DNF by means of put all the non-participating variables filled with 0's.\n#\n.normalizeDNFRule <- function(regla, max){\n  if(!anyNA(regla)){\n    for(i in seq_len(length(max) - 1)){ \n      if(all(regla[(max[i] + 1):max[i+1]] == 1)){\n        regla[(max[i] + 1):max[i+1]] <- 0\n      }\n    }\n    \n    regla\n  } else{\n    regla\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#' Launch a web interface for use the algorithms easily.\n#' @description Launches a Shiny-based interface for the package in your browser.\n#'     \n#' @details The package \\code{SDR} provide simple, shiny-based web interface for performs the taks \n#'     easily. The interface only work with new datasets loaded directly in the platform.\n#'   \n#'     The web application is structured as follows:\n#' \\itemize{\n#'     \\item{ The first you have to do is load your training and test files. This files must be valids KEEL format files.}\n#'     \\item{ After chose your datasets, you can view information about the dataset or execute the algorithm}\n#'     \\item{ You can choose the target variable or the variable to visualize and choose the target value or execute the algorithm for all the values.}\n#'     \\item{ Choosed the target variable, you can  choose the algorithm to execute and change his parameters with the controls provided.}\n#'     \\item{ After you can execute the algorithm. The results are exposed in three tabs that are at the top of the page, just at the right of the \"Exploratory Analysis\" tab.}\n#' }\n#'     The tables can be sorted for each value and also you can search and filter values.\n#'     \n#'     \n#' @examples\n#'\\dontrun{\n#' library(SDR)\n#' SDR_GUI()\n#'}\n#'     \n#' @export\n SDR_GUI <- function(){\n   packages <- installed.packages()[,1]\n   if(! \"shiny\" %in% packages){\n     if(tolower(.yesno(\"Package 'shiny' is not installed and must be installed to run this GUI. Do you want to install it? (Y/n): \")) == \"y\"){\n       install.packages(\"shiny\")\n       cat(\"Launching interface...\")\n       shiny::runApp(appDir = system.file(\"shiny\", package=\"SDR\"), launch.browser = TRUE)\n       \n       invisible()\n     } else {\n       cat(\"Package not installed. Execution aborted.\")\n     }\n   } else {\n     shiny::runApp(appDir = system.file(\"shiny\", package=\"SDR\"), launch.browser = TRUE)\n     \n     invisible()\n   }\n }\n\n\n\n\n\n# Make a yes/no question to the user\n.yesno <- function(texto){\n  line <- readline(texto)\n  line\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n######################################################################\n#                                                                    #\n#                   MATHEMATICAL UTILS                               #    \n#                                                                    #\n#                                                                    #\n######################################################################\n\n\n#'\n#' returns an integer between low and high. EXCLUDING high\n#' @param low Lower bound (included)\n#' @param high Upper bound (NOT included)\n#' @return a uniform-distributed integer value in [low, high)\n#' \n.randInt <- function(low, high){\n  floor( low + (high - low) * runif(1) )\n}\n\n\n\n#'\n#' returns an integer between low and high. INCLUDING high\n#' @param low Lower bound (included)\n#' @param high Upper bound (included)\n#' @return a uniform-distributed integer value in [low, high)\n#' \n#' \n.randIntClosed <- function(low, high){\n  floor( low + ((high + 1) - low) * runif(1) )\n}\n\n\n\n#'\n#' returns an integer between low and high. EXCLUDING low and high\n#' @param low Lower bound (NOT included)\n#' @param high Upper bound (NOT included)\n#' @return a uniform-distributed integer value in [low, high)\n#' \n.randIntClosed <- function(low, high){\n  floor( (low+1) + (high - (low+1)) * runif(1) )\n}\n\n\n#'\n#' returns a number between low and high. EXCLUDING high\n#' @param low Lower bound (included)\n#' @param high Upper bound (NOT included)\n#' @return a uniform-distributed integer value in [low, high)\n#' \n.randDouble <- function(low, high){\n  low + (high - low) * runif(1) \n}\n\n\n\n#'\n#' returns a number between low and high. Including high and EXCLUDING excluded\n#' @param low Lower bound (included)\n#' @param high Upper bound (NOT included)\n#' @param excluded. The number to exclude, it does not check if it is in the range [low,high]\n#' @return a uniform-distributed integer value in [low, high)\n#' \n.randIntExcluded <- function(low, high, excluded){\n  number <- .randIntClosed(low, high)\n  while(number == excluded){\n    number <- .randIntClosed(low, high)\n  }\n  number\n}\n\n\n\n\n#'\n#' Parse a time differente to \"x hours, y minutes and z seconds\"\n#'\n#' @param actual End time in UNIX int format (i.e. as.numeric(Sys.time()))\n#' @param initial Initial time in Unix format.\n#'\n#' @return A human-readable string with time difference.\n#'\nparseTime <- function(actual, initial){\n  dif <- actual - initial\n  horas <- 0\n  minutos <- 0\n  segundos <- 0\n  \n  if(dif >= 3600){\n    horas <- floor(dif / 3600)\n    dif <- dif %% 3600\n  }\n  \n  if(dif >= 60){\n    minutos <- floor(dif / 60)\n    segundos <- dif %% 60\n  } else {\n    segundos <- dif\n  }\n  \n  \n  paste(horas, \" hours, \", minutos, \" minutes and \", round(segundos, 2) , \" seconds.\", sep = \"\")\n}\n\n\n#'\n#' Improved table creation for .get_values6\n#' \n#' @param dataset A matrix with the data\n#' @param classNames a vector with the names of the attributes.\n#' \n#' @return a named vector with the number of instances per class.\n#' \nimprovedTable <- function(dataset, classNames){\n  tabla <-\n    vapply(\n      X = seq_len(length(classNames)) - 1, FUN = function(x, data)\n        sum(data == x), integer(1), dataset[nrow(dataset),]\n    )\n  names(tabla) <- classNames\n  tabla\n}\n\n\n\n#' S3 function to summary a keel object\n#' \n#' Summary relevant data of a \\code{keel} dataset.\n#' \n#' @param object A \\code{keel} class.\n#' \n#' @details This function show important information about the \\code{keel} dataset for the user. Note that it does not \n#' show all the information available. The rest is only for the algorithms. The values that appear are accesible by the\n#' \\code{$} operator, e.g. dataset$relation or dataset$examplesPerClass.\n#' \n#'@examples \n#'  \n#'summary(carTra) \n#' \n#'@export\nsummary.keel <- function(object){\n  cat(paste(\"Summary of the keel object: '\", substitute(object),\"'\", sep = \"\"),\n      paste(\"\\t- relation:\", object$relation),\n      paste(\"\\t- nVars:\", object$nVars),\n      paste(\"\\t- Ns:\", object$Ns),\n      paste(\"\\t- attributeNames:\", paste(object$atributeNames, collapse = \", \")),\n      paste(\"\\t- class_names:\", paste(object$class_names, collapse = \", \")),\n      paste(\"\\t- examplesPerClass:\" ,paste(unlist(object$examplesPerClass), collapse = \", \"))\n      , sep = \"\\n\")\n}\n\n\n\n#'  S3 function to print in console the contents of the dataset\n#'  \n#'  This function shows the matrix of data uncoded.\n#'  \n#'  @param object The \\code{keel} object to view\n#' \n#'  @details This function show the matix of data. Internally, a \\code{keel} object has a list of of examples\n#'  and this examples are coded numerically. This function decode these exameples and convert the list into a matrix.\n#'  \n#'  @return a matrix with the dataset uncoded.\n#'  \n#' @export\nprint.keel <- function(object){\n  data <- lapply(object$data,\n                 function(x, categoricos)\n                   vapply(seq_len(length(x)), function(i, ejemplo, cateValues){\n                     if(is.na(cateValues[[i]][1])){\n                       as.character(ejemplo[i])\n                     } else{\n                       cateValues[[i]][ejemplo[i] + 1]\n                     }\n                   }, character(1), x, categoricos)\n                 \n                 , object$categoricalValues\n                 \n  )\n  \n  matrix(data = unlist(data), ncol = object$nVars + 1, byrow = TRUE, dimnames = list(NULL,object$atributeNames))\n}\n",
    "created" : 1444981965727.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2799654173",
    "id" : "454A67EC",
    "lastKnownWriteTime" : 1445347347,
    "path" : "E:/Escritorio/SDR/R/Utils.R",
    "project_path" : "R/Utils.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}