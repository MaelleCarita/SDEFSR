{
    "contents" : "\n\n\n\n\n#-------------------------------------------------------------------------------------\n#                Operador de mutaci-n\n#\n#  - cromosoma:                 cromosoma a modificar\n#  - max_valor_variables:       vector con los valores m-ximos de las variables (aqu- el m-ximo indicar- valor de no participaci-n.)\n#  - DNF_Rule:                  -Estoy usando reglas DNF-\n#-------------------------------------------------------------------------------------\n\n.mutate <- function(cromosoma, variable, max_valor_variables, DNF_Rule){\n                                            \n \n  mutation_type <- sample(x = 1:2, size = 1)   # Tipo 1 - tipo 2 aleatoriamente\n  \n  \n  if(! DNF_Rule){  #Reglas can-nicas\n    if(mutation_type == 1L){\n      \n      cromosoma[variable] <- max_valor_variables[variable] #Se pone el valor de no participacion\n      \n    } else {  #Asigna valor aleatorio en la variable (Incluye valor de eliminacion)\n      \n      value <- sample(x = 0:(max_valor_variables[variable] ), size = 1)\n      cromosoma[variable] <- value \n      \n    }\n    \n  } else { #Reglas DNF\n    \n     variable <- variable + 1\n     rango <- (max_valor_variables[variable - 1] + 1):max_valor_variables[variable]\n   \n    \n    if(mutation_type == 1){  #Valor de no participaci-n de la variable\n      \n      cromosoma[rango] <- 0\n      \n    } else {  #Asigna valor aleatorio en la variable\n      \n      cromosoma[rango] <- sample(x = 0:1 , size = length(rango), replace = TRUE)\n      \n    }\n    \n  }\n  \n  \n  \n  cromosoma  # Return\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n#' @title Subgroup Discovery Iterative Genetic Algorithm (SDIGA)\n#' @description Perfoms a subgroup discovery task executing the algorithm SDIGA\n#' \n#' @param parameters_file The path of the parameters file. \\code{NULL} If you want to use training and test \\code{keel} variables\n#' @param training A \\code{keel} class variable with training data.\n#' @param test A \\code{keel} class variable with training data.\n#' @param output character vector with the paths of where store information file, rules file and test quality measures file, respectively.\n#' @param seed An integer to set the seed used for generate random numbers.\n#' @param nLabels Number of fuzzy labels defined in the datasets.\n#' @param nEval An integer for set the maximum number of evaluations in the evolutive process.\n#' @param popLength An integer to set the number of individuals in the population.\n#' @param mutProb Sets the mutation probability. A number in [0,1].\n#' @param RulesRep Representation used in the rules. \"can\" for canonical rules, \"dnf\" for DNF rules.\n#' @param Obj1 Sets the Objective number 1. See \\code{Objective values} for more information about the possible values.\n#' @param w1 Sets the weight of \\code{Obj1}.\n#' @param Obj2 Sets the Objective number 2. See \\code{Objective values} for more information about the possible values.\n#' @param w2 Sets the weight of \\code{Obj2}.\n#' @param Obj3 Sets the Objective number 3. See \\code{Objective values} for more information about the possible values.\n#' @param w3 Sets the weight of \\code{Obj3}.\n#' @param minConf Sets the minimum confidence that must have the rule returned by the genetic algorithm after the local optimitation phase. A number in [0,1].\n#' @param lSearch Sets if the local optimitation phase must be performed. A string with \"yes\" or \"no\".\n#' @param targetClass A string specifing the value the target variable. \\code{null} for search for all possible values.\n#' \n#' \n#' @details This function sets as target variable the last one that appear in the KEEL file. If you want \n#'     to change the target variable, you can use \\link{changeTargetVariable} for this objective.  \n#'     The target variable MUST be categorical, if it is not, throws an error.\n#'     \n#'     If you specify in \\code{paramFile} something distintc to \\code{NULL} the rest of the parameters are\n#'     ignored and the algorithm tries to read the file specified. See \"Parameters file structure\" below \n#'     if you want to use a parameters file.\n#'     \n#' @section How does this algorithm work?:\n#'     This algorithm has a genetic algorithm in his core. This genetic algorithm returns only the best\n#'     rule of the population and it is executed so many times until a stop condition is reached. The stop condition is \n#'     that the rule returned must cover at least one new example (not covered by previous rules) and must have a confidence\n#'     greater than a minimum.\n#'     \n#'    After returning the rule, a local improvement could be applied for make the rule more general. This local improve is done\n#'    by means of a hill-climbing local search.\n#'    \n#'    The genetic algorithm cross only the two best individuals. But the mutation operator is applied over all the population,\n#'    individuals from cross too.\n#'    \n#' @section Parameters file structure:\n#'   The \\code{parameters_file} argument points to a file which has the necesary parameters for SDIGA works.\n#'   This file \\strong{must} be, at least, those parameters (separated by a carriage return):\n#'   \\itemize{\n#'     \\item \\code{algorithm}  Specify the algorithm to execute. In this case. \"SDIGA\"\n#'     \\item \\code{inputData}  Specify two paths of KEEL files for training and test. In case of specify only the name of the file, the path will be the working directory.\n#'     \\item \\code{seed}  Sets the seed for the random number generator\n#'     \\item \\code{nLabels}  Sets the number of fuzzy labels to create when reading the files\n#'     \\item \\code{nEval}  Set the maximun number of \\strong{evaluations of rules} for stop the genetic process\n#'     \\item \\code{popLength}  Sets number of individuals of the main population\n#'     \\item \\code{mutProb}  Mutation probability of the genetic algorithm. Value in [0,1]\n#'     \\item \\code{RulesRep}  Representation of each chromosome of the population. \"can\" for canonical representation. \"dnf\" for DNF representation.\n#'     \\item \\code{Obj1} Sets the objective number 1. \n#'     \\item \\code{w1} Sets the weigth assigned to the objective number 1. Value in [0,1]\n#'     \\item \\code{Obj2} Sets the objective number 2. \n#'     \\item \\code{w2} Sets the weigth assigned to the objective number 2. Value in [0,1]\n#'     \\item \\code{Obj3} Sets the objective number 3. \n#'     \\item \\code{w3} Sets the weigth assigned to the objective number 3. Value in [0,1]\n#'     \\item \\code{minConf} Sets the minimum confidence of the rule for checking the stopping criteria of the iterative process\n#'     \\item \\code{lSearch} Perform the local search algorithm after the execution of the genetic algorithm? Values: \"yes\" or \"no\"\n#'     \\item \\code{targetClass}  Value of the target variable to search for subgroups. The target variable \\strong{is always the last variable.}. Use \\code{null} to search for every value of the target variable\n#'   }\n#'   \n#'   An example of parameter file could be:\n#'  \\preformatted{\n#' algorithm = SDIGA\n#' inputData = \"irisD-10-1tra.dat\" \"irisD-10-1tst.dat\"\n#' outputData = \"irisD-10-1-INFO.txt\" \"irisD-10-1-Rules.txt\" \"irisD-10-1-TestMeasures.txt\"\n#' seed = 0\n#' nLabels = 3\n#' nEval = 500\n#' popLength = 100\n#' mutProb = 0.01\n#' minConf = 0.6\n#' RulesRep = can\n#' Obj1 = Comp\n#' Obj2 = Unus\n#' Obj3 = null\n#' w1 = 0.7\n#' w2 = 0.3\n#' w3 = 0.0\n#' lSearch = yes\n#' }\n#' \n#' \n#' @section Objective values:\n#'      You can use the following quality measures in the ObjX value of the parameter file using this values:\n#'       \\itemize{\n#'         \\item Unusualness -> \\code{unus}\n#'         \\item Crisp Support -> \\code{csup}\n#'         \\item Crisp Confidence -> \\code{ccnf}\n#'         \\item Fuzzy Support -> \\code{fsup}\n#'         \\item Fuzzy Confidence -> \\code{fcnf}\n#'         \\item Coverage -> \\code{cove}\n#'         \\item Significance -> \\code{sign}\n#'       }\n#'     \n#'     If you dont want to use a objetive value you must specify \\code{null}\n#' \n#' \n#' @return The algorithm shows in the console the following results:\n#' \\enumerate{\n#'  \\item The parameters used in the algorithm\n#'  \\item The rules generated.\n#'  \\item The quality measures for test of every rule and the global results.\n#' }\n#' \n#'     Also, the algorithms save those results in the files specified in the \\code{output} parameter of the algorithm or \n#'     in the \\code{outputData} parameter in the parameters file.\n#' \n#' \n#' \n#' @references \n#' M. J. del Jesus, P. Gonzalez, F. Herrera, and M. Mesonero, \"Evolutionary\n#' Fuzzy Rule Induction Process for Subgroup Discovery: A case study in\n#' marketing,\" IEEE Transactions on Fuzzy Systems, vol. 15, no. 4, pp.\n#' 578-592, 2007.\n#' \n#' @examples \n#' SDIGA(parameters_file = NULL, \n#'       training = habermanTra, \n#'       test = habermanTst, \n#'       output = c(\"optionsFile.txt\", \"rulesFile.txt\", \"testQM.txt\"),\n#'       seed = 0, \n#'       nLabels = 3,\n#'       nEval = 300, \n#'       popLength = 100, \n#'       mutProb = 0.01, \n#'       RulesRep = \"can\",\n#'       Obj1 = \"CSUP\", \n#'       w1 = 0.7,\n#'       Obj2 = \"CCNF\",\n#'       w2 = 0.3,\n#'       Obj3 = \"null\",\n#'       w3 = 0,\n#'       minConf = 0.6,\n#'       lSearch = \"yes\",\n#'       targetClass = \"positive\")\n#' \\dontrun{\n#' SDIGA(parameters_file = NULL, \n#'       training = habermanTra, \n#'       test = habermanTst, \n#'       output = c(\"optionsFile.txt\", \"rulesFile.txt\", \"testQM.txt\"),\n#'       seed = 0, \n#'       nLabels = 3,\n#'       nEval = 300, \n#'       popLength = 100, \n#'       mutProb = 0.01, \n#'       RulesRep = \"can\",\n#'       Obj1 = \"CSUP\", \n#'       w1 = 0.7,\n#'       Obj2 = \"CCNF\",\n#'       w2 = 0.3,\n#'       Obj3 = \"null\",\n#'       w3 = 0,\n#'       minConf = 0.6,\n#'       lSearch = \"yes\",\n#'       targetClass = \"positive\")\n#'       }\n#' @export\nSDIGA <- function(parameters_file = NULL, \n                  training = NULL, \n                  test = NULL, \n                  output = c(\"optionsFile.txt\", \"rulesFile.txt\", \"testQM.txt\"),\n                  seed = 0, \n                  nLabels = 3,\n                  nEval = 10000, \n                  popLength = 100, \n                  mutProb = 0.01, \n                  RulesRep = \"can\",\n                  Obj1 = \"CSUP\", \n                  w1 = 0.7,\n                  Obj2 = \"CCNF\",\n                  w2 = 0.3,\n                  Obj3 = \"null\",\n                  w3 = 0,\n                  minConf = 0.6,\n                  lSearch = \"yes\",\n                  targetClass = \"null\")\n{\n  \n  \n  \n  if(is.null(parameters_file)){\n    #Generate our \"parameters file\"\n    if(class(training) != \"keel\" | class(test) != \"keel\")\n      stop(\"'training' or 'test' parameters is not a KEEL class\")\n    \n    if(is.null(training) | is.null(test)) \n      stop(\"Not provided a 'test' or 'training' file and neither a parameter file. Aborting...\")\n    \n    if(training[[1]] != test[[1]] )\n      stop(\"datasets ('training' and 'test') does not have the same relation name.\")\n    \n    if(length(output) != 3 )\n      stop(\"You must specify three files to save the results.\")\n    \n    \n    parametros <- list(seed = seed, \n                       algorithm = \"SDIGA\",\n                       outputData = output,\n                       nEval = nEval, \n                       popLength = popLength,\n                       nLabels = nLabels,\n                       mutProb = mutProb,\n                       RulesRep = RulesRep,\n                       Obj1 = Obj1, \n                       w1 = w1, \n                       Obj2 = Obj2, \n                       w2 = w2,\n                       Obj3 = Obj3,\n                       w3 = w3, \n                       lSearch = lSearch,\n                       minConf = minConf,\n                       targetClass = targetClass)\n      \n  } else {\n  # Parametros --------------------------\n  parametros <- .read.parametersFile2(file = parameters_file)  # parametros del algoritmo\n    if(parametros$algorithm != \"SDIGA\")\n      stop(\"Parameters file is not for \\\"SDIGA\\\"\")\n  \n  test <- read.keel(file = parametros$inputData[2], nLabels = parametros$nLabels)        # test data\n  \n  training <- read.keel(file = parametros$inputData[1], nLabels = parametros$nLabels )   # training data\n  }\n  \n  #Check if the last variable is categorical.\n  if(training$atributeTypes[length(training$atributeTypes)] != 'c' | test$atributeTypes[length(test$atributeTypes)] != 'c')\n    stop(\"Target variable is not categorical.\")\n  \n  #Check number of fuzzy labels, if not the same, change it.\n   if(dim(training$fuzzySets)[1] != nLabels){\n     training <- modifyFuzzyCrispIntervals(training, nLabels)\n   }\n    if(dim(test$fuzzySets)[1] != nLabels){\n      test <- modifyFuzzyCrispIntervals(test, nLabels)\n    }\n  \n  file.remove(parametros$outputData[which(file.exists(parametros$outputData))])\n\n  \n  if(tolower(parametros$RulesRep) == \"can\"){\n    DNF = FALSE\n  } else {\n    DNF = TRUE\n  }\n  \n  Objetivos <- .parseObjetives(parametros = parametros, \"SDIGA\", DNF)\n  if(all(is.na(Objetivos[1:3]))) stop(\"No objetive values selected. You must select, at least, one objective value. Aborting...\")\n\n  Pesos <- c(parametros$w1, parametros$w2, parametros$w3)\n  if(sum(Pesos) == 0) stop(\"Sum of weigths must be a value greater than zero.\")\n  \n  Mejor <- TRUE  \n  \n  reglas <- list()\n  \n  .show_parameters(params = parametros, train = training, test = test)\n  contador <- 0\n  \n  cate <- training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'c'\n  num <- training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'r' | training[[\"atributeTypes\"]][- length(training[[\"atributeTypes\"]])] == 'e'\n  \n  \n  #---------------------------------------------------\n  \n  \n  #----- OBTENCION DE LAS REGLAS -------------------\n  if(parametros$targetClass != \"null\"){ # Ejecuci-n para una clase\n    #Check if target class is valid\n    targetClass <- parametros$targetClass\n    if(! any(training$class_names == targetClass)) stop(\"No valid target value provided.\")\n    cat(\"\\n\", \"\\n\", \"Searching rules for only one value of the target class...\", \"\\n\", \"\\n\", file =\"\", fill = TRUE)  \n    \n    \n    cat(\" - Target value:\", targetClass , file = \"\", sep = \" \", fill = TRUE)\n    cat(\"\\n - Target value:\", targetClass , file = parametros$outputData[2], sep = \" \", fill = TRUE, append = TRUE)\n    primera_regla <- TRUE\n    Mejor = TRUE\n    por_cubrir = training$examplesPerClass[[targetClass]]\n    \n    while(Mejor){\n      Mejor <- FALSE\n      \n      rule <- .ejecutarga(algorithm = \"SDIGA\", dataset = training, targetClass = targetClass, n_vars = training$nVars, por_cubrir = por_cubrir, nLabels = parametros$nLabels, N_evals = parametros$nEval,  tam_pob = parametros$popLength, p_mut = parametros$mutProb, seed = parametros$seed, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, cate = cate, num = num)\n      maxRule <-  if(!DNF) training$conjuntos else c(0, Reduce(f = '+', x = training[[\"conjuntos\"]], accumulate = TRUE))\n      values <- .fit13(regla = rule, dataset = training, noClass = matrix(unlist(.separar(training)), nrow = length(training[[2]]) - 1, ncol = length(training[[7]])), targetClass = targetClass, por_cubrir = por_cubrir, n_Vars = training$nVars, nLabels = parametros$nLabels, max_regla = maxRule, marcar = TRUE, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, difuso = Objetivos[[4]], test = TRUE, cate = cate, num = num)[[2]]\n      \n      if(tolower(parametros$lSearch) == \"yes\") rule <- .Busqueda_Local(att_obj = targetClass, regla = rule, DNF_Rules = DNF, dataset = training , confianza_minima = parametros$minConf, x = values, max_regla = maxRule, por_cubrir = por_cubrir, nLabels = parametros$nLabels, Objetivos = Objetivos, cate = cate, num = num)\n      x <- .marcar_ejemplos(regla = rule, dataset = training, targetClass = targetClass, nVars = training$nVars, maxRegla = maxRule, por_cubrir = por_cubrir, nLabels = parametros$nLabels, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, cate = cate, num = num)\n      \n      if(x$cubreNuevos && x$confidence > parametros$minConf || primera_regla){\n        primera_regla <- FALSE\n        Mejor <- TRUE\n        contador <- contador + 1\n        training$covered <- x$covered[[1]]\n        cat(\"\\n\",\" GENERATED RULE\", contador, \":\",file = \"\", sep = \" \", fill = TRUE)\n        cat(\"\\n\",\" GENERATED RULE\", contador, \":\",file = parametros$outputData[2], sep = \" \", fill = TRUE, append = TRUE)\n        .print.rule(rule = rule, max = training$conjuntos, names = training$atributeNames, consecuente = targetClass, types = training$atributeTypes,fuzzySets = training$fuzzySets, categoricalValues = training$categoricalValues, DNF, rulesFile = parametros$outputData[2])\n        cat(\"\\n\", file = \"\")\n        rule[length(rule) + 1] <- targetClass\n        reglas[[contador]] <- rule\n        por_cubrir <- x$porCubrir\n        if(por_cubrir <= 0) Mejor <- FALSE #Si no quedan ejemplos por cubrir no volvemos a llamar al gen-tico.\n        \n      } else {\n        cat(\" GENERATED RULE\", \":\",file = \"\", sep = \" \", fill = TRUE)\n        cat(\"# Invalid (Low confidence or support)\", \"\\n\",\"\\n\", file = \"\", sep= \" \", fill = TRUE)\n        \n        cat(\"\\n GENERATED RULE\", \":\", \"\\n\",\n          \"# Invalid (Low confidence or support)\", \"\\n\", file = parametros$outputData[2], sep= \" \", fill = TRUE, append = TRUE)\n        \n      }\n      \n    }\n    \n    \n    \n  } else {  #Ejecucion para todas las clases\n    cat(\"\\n\", \"\\n\", \"Searching rules for all values of the target class...\", \"\\n\", \"\\n\", file =\"\", fill = TRUE)  \n    for(i in seq_len(length(training[[\"class_names\"]]))) {\n    #for(i in training$class_names[ seq_len(length(training$class_names)) ]){\n      targetClass <- training[[\"class_names\"]][i]\n      cat(\" - Target value:\", targetClass , file = \"\", sep = \" \", fill = TRUE)\n      cat(\" \\n - Target value:\", targetClass , file = parametros$outputData[2], sep = \" \", fill = TRUE, append = TRUE)\n      primera_regla <- TRUE\n      Mejor = TRUE\n      por_cubrir = training$examplesPerClass[[i]]\n      \n      while(Mejor){\n        Mejor <- FALSE\n        \n        rule <- .ejecutarga(algorithm = \"SDIGA\", dataset = training, targetClass = targetClass, n_vars = training$nVars, por_cubrir = por_cubrir, nLabels = parametros$nLabels, N_evals = parametros$nEval,  tam_pob = parametros$popLength, p_mut = parametros$mutProb, seed = parametros$seed, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, cate = cate, num = num)\n        maxRule <-  if(!DNF) training$conjuntos else c(0, Reduce(f = '+', x = training[[\"conjuntos\"]], accumulate = TRUE))\n      \n        values <- .fit13(regla = rule, dataset = training, noClass = matrix(unlist(.separar(training)), nrow = length(training[[2]]) - 1, ncol = length(training[[7]])), targetClass = targetClass, por_cubrir = por_cubrir, n_Vars = training$nVars, nLabels = parametros$nLabels, max_regla = maxRule, marcar = TRUE, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, difuso = Objetivos[[4]], test = TRUE, cate = cate, num = num)[[2]]\n        \n        if(tolower(parametros$lSearch) == \"yes\"){\n          rule <- .Busqueda_Local(att_obj = targetClass, regla = rule, DNF_Rules = DNF, dataset = training , confianza_minima = parametros$minConf, x = values, max_regla = maxRule, por_cubrir = por_cubrir, nLabels = parametros$nLabels, Objetivos = Objetivos, cate = cate, num = num)\n        }\n       \n          x <- .marcar_ejemplos(regla = rule, dataset = training, targetClass = targetClass, nVars = training$nVars, maxRegla = maxRule, por_cubrir = por_cubrir, nLabels = parametros$nLabels, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, cate = cate, num = num)\n        \n        if(x$cubreNuevos && x$confidence > parametros$minConf || primera_regla){\n          primera_regla <- FALSE\n          Mejor <- TRUE\n          contador <- contador + 1\n          training$covered <- x$covered[[1]]\n          cat(\"\\n\",\" GENERATED RULE\", contador, \":\",file = \"\", sep = \" \", fill = TRUE)\n          cat(\"\\n\",\" GENERATED RULE\", contador, \":\",file = parametros$outputData[2], sep = \" \", fill = TRUE, append = TRUE)\n          .print.rule(rule = rule, max = training$conjuntos, names = training$atributeNames, consecuente = targetClass, types = training$atributeTypes,fuzzySets = training$fuzzySets, categoricalValues = training$categoricalValues, DNF, rulesFile = parametros$outputData[2])\n          cat(\"\\n\", file = \"\")\n          rule[length(rule) + 1] <- targetClass\n          reglas[[contador]] <- rule\n          por_cubrir <- x$porCubrir\n          if(por_cubrir <= 0) Mejor <- FALSE #Si no quedan ejemplos por cubrir no volvemos a llamar al gen-tico.\n          \n        } else {\n          cat(\" GENERATED RULE\", \":\",file = \"\", sep = \" \", fill = TRUE)\n          cat(\"# Invalid (Low confidence or support)\", \"\\n\",\"\\n\", file = \"\", sep= \" \", fill = TRUE)\n          \n          cat(\"\\n GENERATED RULE\", \":\", \"\\n\",\n              \"# Invalid (Low confidence or support)\", \"\\n\",\"\\n\", file = parametros$outputData[2], sep= \" \", fill = TRUE, append = TRUE)\n          \n        }\n        \n      }\n    }\n    \n    \n  }\n  \n  #---------------------------------------------------\n  \n  cat(\"\\n\", \"\\n\", \"Testing rules...\", \"\\n\", \"\\n\", file = \"\", sep = \" \", fill = TRUE)\n  \n  #--------  Testeo de las reglas --------------------\n  sumNvars <- 0\n  sumCov <- 0\n  sumFsup <- 0\n  sumCsup <- 0\n  sumCconf <- 0\n  sumFconf <- 0\n  sumUnus <- 0\n  sumSign <- 0\n  sumAccu <- 0\n  \n  n_reglas <- length(reglas)\n  for(i in 1:n_reglas){\n    val <- .probeRule2(rule = reglas[[i]][-length(reglas[[i]])], testSet = test, targetClass = reglas[[i]][length(reglas[[i]])], numRule = i, parametros = parametros, Objetivos = Objetivos, Pesos = Pesos, cate = cate, num = num, DNF = DNF)\n    test[[\"covered\"]] <- val[[\"covered\"]]\n    sumNvars <- sumNvars + val[[\"nVars\"]]\n    sumCov <- sumCov + val[[\"coverage\"]]\n    sumFsup <- sumFsup + val[[\"fsupport\"]]\n    sumCconf <- sumCconf + val[[\"cconfidence\"]]\n    sumFconf <- sumFconf + val[[\"fconfidence\"]]\n    sumUnus <- sumUnus + val[[\"unusualness\"]]\n    sumSign <- sumSign + val[[\"significance\"]]\n    sumAccu <- sumAccu + val[[\"accuracy\"]]\n  }\n  \n  \n  \n  #Medidas de calidad globales\n  cat(\"Global:\", file =\"\", fill = TRUE)\n  cat(paste(\"\\t - N_rules:\", length(reglas), sep = \" \"),\n      paste(\"\\t - N_vars:\", round(sumNvars / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Coverage:\", round(sumCov / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Significance:\", round(sumSign / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Unusualness:\", round(sumUnus / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Accuracy:\", round(sumAccu / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - CSupport:\", round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6), sep = \" \"),\n      paste(\"\\t - FSupport:\", round(sumFsup / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - FConfidence:\", round(sumFconf / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - CConfidence:\", round(sumCconf / n_reglas, 6), sep = \" \"),\n      file = \"\", sep = \"\\n\"\n  )\n  \n\n  cat( \"Global:\",\n     paste(\"\\t - N_rules:\", length(reglas), sep = \" \"),\n      paste(\"\\t - N_vars:\", round(sumNvars / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Coverage:\", round(sumCov / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Significance:\", round(sumSign / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Unusualness:\", round(sumUnus / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - Accuracy:\", round(sumAccu / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - CSupport:\", round(sum(test[[\"covered\"]] / test[[\"Ns\"]]), 6), sep = \" \"),\n      paste(\"\\t - FSupport:\", round(sumFsup / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - FConfidence:\", round(sumFconf / n_reglas, 6), sep = \" \"),\n      paste(\"\\t - CConfidence:\", round(sumCconf / n_reglas, 6), sep = \" \"),\n      file = parametros$outputData[3], sep = \"\\n\", append = TRUE\n  )\n  \n  \n  \n  \n  #---------------------------------------------------\n  \n  #reglas  # Return\n  \n}\n\n\n\n.probeRule2 <- function(rule, testSet, targetClass, numRule, parametros, Objetivos, Pesos, cate, num, DNF = FALSE){\n  stopifnot(class(testSet) == \"keel\")\n   \n  maxRegla <- .dameConjuntos(data_types = testSet[[3]], max = testSet[[5]], n_labels = parametros$nLabels)\n   \n  if(DNF) maxRegla <- c(0,Reduce(f= '+', x = maxRegla, accumulate = TRUE))\n  \n  # OJO QUE CUENTAS LAS REGLAS ANTERIOREs, LOS EJEMPLOS POR CUBRIR DE CADA REGLA NO SON LOS INICIALES\n  # HAY QUE SUBIR LA VARIABLE POR_CUBRIR A UN NIVEL SUPERIOR\n  p <- .fit13(regla = rule, dataset = testSet, noClass = matrix(unlist(.separar(testSet)), nrow = length(cate)), targetClass = targetClass, por_cubrir = testSet$examplesPerClass[[targetClass]], n_Vars = testSet$nVars, nLabels = parametros$nLabels, max_regla = maxRegla, marcar = TRUE, Objetivos = Objetivos, Pesos = Pesos, DNFRules = DNF, difuso = Objetivos[[4]], test = TRUE, cate = cate, num = num)\n  values <- p[[2]]\n  testSet[[\"covered\"]] <- testSet[[\"covered\"]] | p[[1]] #For the global quality measure\n  \n  Cov <- round(.coverage(values), 6)\n  sig <- round(.significance(values), 6)\n  unus <- round(.unusualness(values), 6)\n  acc <- round(.accuracy(values), 6)\n  Csup <- round(.Csupport(values), 6)\n  Fsup <- round(.Fsupport(values), 6)\n  Ccnf <- round(.confianza(values), 6)\n  Fcnf <- round(.confianzaDifusa(values), 6)\n  \n  if(DNF) {\n    participantes <- .getParticipantes(regla = rule,  max_regla = maxRegla, DNFRules = TRUE) \n    nVars <- sum(participantes) + 1\n  } else{\n    nVars <- sum(rule < testSet[[\"conjuntos\"]]) + 1 # +1 Por la variable del consecuente.\n  }\n  cat(\"Rule\", numRule,\":\", file = \"\", sep = \" \", fill = TRUE)\n  cat(paste(\"\\t - N_vars:\", nVars, sep = \" \"),\n      paste(\"\\t - Coverage:\", Cov, sep = \" \"),\n      paste(\"\\t - Significance:\", sig, sep = \" \"),\n      paste(\"\\t - Unusualness:\", unus, sep = \" \"),\n      paste(\"\\t - Accuracy:\", acc, sep = \" \"),\n      paste(\"\\t - CSupport:\", Csup, sep = \" \"),\n      paste(\"\\t - FSupport:\", Fsup, sep = \" \"),\n      paste(\"\\t - CConfidence:\", Ccnf, sep = \" \"),\n      paste(\"\\t - FConfidence:\", Fcnf, sep = \" \"),\n      file = \"\", sep = \"\\n\"\n  )\n  cat(\"\\n\", file = \"\", sep = \"\\n\")\n  \n  \n  \n  \n  cat(paste(\"Rule\", numRule,\":\"),\n      paste(\"\\t - N_vars:\", nVars, sep = \" \"),\n      paste(\"\\t - Coverage:\", Cov, sep = \" \"),\n      paste(\"\\t - Significance:\", sig, sep = \" \"),\n      paste(\"\\t - Unusualness:\", unus, sep = \" \"),\n      paste(\"\\t - Accuracy:\", acc, sep = \" \"),\n      paste(\"\\t - CSupport:\", Csup, sep = \" \"),\n      paste(\"\\t - FSupport:\", Fsup, sep = \" \"),\n      paste(\"\\t - CConfidence:\", Ccnf, sep = \" \"),\n      paste(\"\\t - FConfidence:\", Fcnf, \"\\n\", sep = \" \"),\n      file = parametros$outputData[3], sep = \"\\n\", append = TRUE\n  )\n  \n#Return\n    list( covered = testSet[[\"covered\"]], \n                nVars = nVars,\n                coverage = Cov, \n                significance = sig, \n                unusualness = unus,\n                accuracy = acc,\n                csupport = Csup,\n                fsupport = Fsup,\n                cconfidence = Ccnf,\n                fconfidence = Fcnf) \n}\n\n\n\n#--------------------------------------------------------------------------------------------------\n#                 Borra una variable de una regla\n#\n# - regla: La regla a modificar\n# - variable: La variable a eliminar\n# - max_valor_variables: Numero de conjuntos difusos para cada variable\n# - DNF_Rules: -Uso reglas DNF-\n#\n#--------------------------------------------------------------------------------------------------\n\n.borrar_gen <- function(regla, variable, max_valor_variables, DNF_Rules){\n  \n  if(!DNF_Rules){ # Reglas canonicas\n    \n    regla[variable] <- max_valor_variables[variable]  #valor de no participacion\n    \n    \n  } else {   #Reglas DNF\n    \n   rango <- (max_valor_variables[variable] + 1):max_valor_variables[variable + 1]\n   regla[rango] <- 0\n   \n  }\n  \n  regla   #Return\n  \n}\n\n\n\n\n#--------------------------------------------------------------------------------------------------\n#         B-squeda local etapa de post-procesamiento de SDIGA\n#\n# - regla: La regla a optimizar\n# - DNF_Rules: -Uso reglas DNF-\n# - dataset: el conjunto de ejemplos marcados en caso de est-n cubiertos.\n# - max_valor_variables: n-mero de conjuntos difusos de cada variable\n# - .confianza_minima: valor m--nimo de .confianza a dar\n# - Valores devueltos por la funcion ejemplos_cubiertos\n#\n#--------------------------------------------------------------------------------------------------\n\n\n.Busqueda_Local <- function(att_obj, regla, DNF_Rules, dataset, confianza_minima, x, max_regla, por_cubrir, nLabels, Objetivos, cate, num){\n  mejor_regla <- regla\n   soporte_regla <- .significance(x)\n  participantes <- .getParticipantes(regla = regla, max_regla = max_regla, DNFRules = DNF_Rules)\n  \n  if(soporte_regla == 1 || sum(participantes) == 1 ){\n    return(regla) # If local support it is 1 or rule has only one attribute, we can not improve the rule\n  }\n  \n    mejor_soporte <-  soporte_regla\n    mejor = TRUE\n    longitud = if(DNF_Rules) length(max_regla) - 1 else length(max_regla)\n    while(mejor){\n      mejor = FALSE\n      participantes <- .getParticipantes(regla = mejor_regla, max_regla = max_regla, DNFRules = DNF_Rules)\n      for(i in seq_len(longitud) ){ # Para cada gen de la regla\n     \n        if(participantes[i]){\n          regla_m <- .borrar_gen(regla = mejor_regla, variable = i, max_valor_variables = max_regla, DNF_Rules = DNF_Rules)\n          x1 <- .fit13(regla = regla_m, dataset = dataset, noClass = matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass = att_obj, por_cubrir = por_cubrir, n_Vars = dataset$nVars, nLabels = nLabels, max_regla = max_regla, marcar = TRUE, Objetivos = Objetivos, DNFRules = DNF_Rules, difuso = Objetivos[[4]], test = TRUE, cate = cate, num = num)\n          if(length(x1) > 1){\n            x1 <- x1[[2]]\n            supp1 <- .significance(x1)\n          } else {\n            supp1 <- 0 # It is the empty rule\n          }\n          \n          if( supp1 >= mejor_soporte ){\n            \n            c1 <- .confianza(x1)\n            c2 <-  .confianza(x)\n            \n            if( (supp1 > mejor_soporte) &&  c1 >= c2 ){\n              mejor_soporte <- supp1\n              mejor_regla <- regla_m\n              mejor = TRUE\n             }\n          }\n        }\n        \n      }\n      \n    }\n    \n  x1 <- .fit13(regla = mejor_regla, dataset = dataset, noClass = matrix(unlist(.separar(dataset)), nrow = length(dataset[[2]]) - 1, ncol = length(dataset[[7]])), targetClass = att_obj, por_cubrir = por_cubrir, n_Vars = dataset$nVars, nLabels = nLabels, max_regla = max_regla, marcar = TRUE, Objetivos = Objetivos, DNFRules = DNF_Rules, difuso = Objetivos[[4]], test = TRUE, cate = cate, num = num)[[2]]\n  \n  if(.confianza(x1) >= confianza_minima){\n    mejor_regla\n  } else {\n    regla\n  }\n  \n}\n\n",
    "created" : 1444985772912.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "102291495",
    "id" : "DB30CA90",
    "lastKnownWriteTime" : 1445002452,
    "path" : "E:/Escritorio/SDR/R/SDIGA.R",
    "project_path" : "R/SDIGA.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}